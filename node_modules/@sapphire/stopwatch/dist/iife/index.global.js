var SapphireStopwatch = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };

  // src/index.ts
  var _start, _end;
  var _Stopwatch = class _Stopwatch {
    /**
     * Starts a new stopwatch
     */
    constructor(digits = 2) {
      /**
       * The number of digits to appear after the decimal point when returning the friendly duration.
       */
      __publicField(this, "digits");
      /**
       * The start time of this stopwatch
       */
      __privateAdd(this, _start, void 0);
      /**
       * The end time of this stopwatch
       */
      __privateAdd(this, _end, void 0);
      this.digits = digits;
      __privateSet(this, _start, performance.now());
      __privateSet(this, _end, null);
    }
    /**
     * The duration of this stopwatch since start or start to end if this stopwatch has stopped.
     */
    get duration() {
      return __privateGet(this, _end) ? __privateGet(this, _end) - __privateGet(this, _start) : performance.now() - __privateGet(this, _start);
    }
    /**
     * If the stopwatch is running or not.
     */
    get running() {
      return Boolean(!__privateGet(this, _end));
    }
    /**
     * Restarts the stopwatch (Returns a running state)
     */
    restart() {
      __privateSet(this, _start, performance.now());
      __privateSet(this, _end, null);
      return this;
    }
    /**
     * Resets the Stopwatch to 0 duration (Returns a stopped state)
     */
    reset() {
      __privateSet(this, _start, performance.now());
      __privateSet(this, _end, __privateGet(this, _start));
      return this;
    }
    /**
     * Starts the Stopwatch
     */
    start() {
      if (!this.running) {
        __privateSet(this, _start, performance.now() - this.duration);
        __privateSet(this, _end, null);
      }
      return this;
    }
    /**
     * Stops the Stopwatch, freezing the duration
     */
    stop() {
      if (this.running)
        __privateSet(this, _end, performance.now());
      return this;
    }
    /**
     * Defines toString behavior
     */
    toString() {
      const time = this.duration;
      if (time >= 1e3)
        return `${(time / 1e3).toFixed(this.digits)}s`;
      if (time >= 1)
        return `${time.toFixed(this.digits)}ms`;
      return `${(time * 1e3).toFixed(this.digits)}\u03BCs`;
    }
  };
  _start = new WeakMap();
  _end = new WeakMap();
  __name(_Stopwatch, "Stopwatch");
  var Stopwatch = _Stopwatch;

  exports.Stopwatch = Stopwatch;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.global.js.map