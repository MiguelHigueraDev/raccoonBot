export * from '@sapphire/discord-utilities';
import { CategoryChannel, DMChannel, PartialDMChannel, NewsChannel, StageChannel, TextChannel, ThreadChannel, VoiceChannel, GuildChannel, Channel, Message, ChatInputCommandInteraction, UserContextMenuCommandInteraction, MessageContextMenuCommandInteraction, AutocompleteInteraction, StringSelectMenuInteraction, ButtonInteraction, Interaction, PartialTextBasedChannelFields, EmojiIdentifierResolvable, User, CollectorFilter, MessageReaction, CollectorOptions, GuildEmoji, ReactionEmoji, EmojiResolvable, MessageCreateOptions, InteractionButtonComponentData, LinkButtonComponentData, StringSelectMenuComponentData, UserSelectMenuComponentData, RoleSelectMenuComponentData, MentionableSelectMenuComponentData, ChannelSelectMenuComponentData, APIMessage, CommandInteraction, InteractionCollector, EmbedBuilder, BaseMessageOptions, WebhookMessageEditOptions, SelectMenuComponentOptionData, MessageComponentInteraction, CollectedInteraction, ModalSubmitInteraction, JSONEncodable, APIActionRowComponent, APIMessageActionRowComponent, ActionRowData, ActionRowComponentOptions, MessageActionRowComponentBuilder, Guild, InteractionReplyOptions, InteractionUpdateOptions, MessageReplyOptions, MessageEditOptions, APIEmbed, Collection, Snowflake, EmbedData, EmbedField, ButtonComponentData, ButtonBuilder, PartialGroupDMChannel, PublicThreadChannel, PrivateThreadChannel, VoiceBasedChannel, BaseInteraction, GuildMember, APIGuildMember, APIInteractionGuildMember, APIInteractionDataResolvedGuildMember } from 'discord.js';
import { ArgumentTypes, Awaitable, Ctor, Nullish } from '@sapphire/utilities';

/**
 * A union of all the various types of channels that Discord.js has
 */
type ChannelTypes = CategoryChannel | DMChannel | PartialDMChannel | NewsChannel | StageChannel | TextChannel | ThreadChannel | VoiceChannel | GuildChannel | Channel;
/**
 * A union of all the channel types that a message can come from
 */
type TextBasedChannelTypes = Message['channel'];
/**
 * A union of all the voice-based channel types that Discord.js has
 */
type VoiceBasedChannelTypes = VoiceChannel | StageChannel;
/**
 * A union of all the channel types that belong to a guild, not including {@link ThreadChannel}
 */
type NonThreadGuildBasedChannelTypes = Extract<ChannelTypes, GuildChannel>;
/**
 * A union of all the channel types that belong to a guild, including {@link ThreadChannel}
 */
type GuildBasedChannelTypes = NonThreadGuildBasedChannelTypes | ThreadChannel;
/**
 * A union of guild based message channels, not including {@link ThreadChannel}
 */
type NonThreadGuildTextBasedChannelTypes = Extract<TextBasedChannelTypes, GuildChannel>;
/**
 * A union of guild based message channels, including {@link ThreadChannel}
 */
type GuildTextBasedChannelTypes = NonThreadGuildTextBasedChannelTypes | ThreadChannel;
/**
 * The types of a channel, with the addition of `'UNKNOWN'`
 */
type ChannelTypeString = ChannelTypes['type'] | 'UNKNOWN';
/**
 * A union of {@link ChatInputCommandInteraction}, {@link UserContextMenuCommandInteraction} and {@link MessageContextMenuCommandInteraction}. Similar to {@link CommandInteraction} class but as a type union.
 */
type ChatInputOrContextMenuCommandInteraction = ChatInputCommandInteraction | UserContextMenuCommandInteraction | MessageContextMenuCommandInteraction;
/**
 * A union of {@link ChatInputCommandInteraction}{@link UserContextMenuCommandInteraction}, {@link MessageContextMenuCommandInteraction}, {@link AutocompleteInteraction}, {@link StringSelectMenuInteraction} and {@link ButtonInteraction}
 */
type NonModalInteraction = ChatInputOrContextMenuCommandInteraction | AutocompleteInteraction | StringSelectMenuInteraction | ButtonInteraction;
/**
 * A union of {@link ChatInputCommandInteraction}{@link UserContextMenuCommandInteraction}, {@link MessageContextMenuCommandInteraction}, {@link AutocompleteInteraction}, {@link StringSelectMenuInteraction}, {@link ButtonInteraction}, and {@link ModalSubmitInteraction}
 */
type AnyInteraction = Interaction;
/**
 * A union of {@link ChatInputCommandInteraction}, {@link UserContextMenuCommandInteraction}, {@link MessageContextMenuCommandInteraction}, {@link StringSelectMenuInteraction}, {@link ButtonInteraction}, and {@link ModalSubmitInteraction}
 */
type AnyInteractableInteraction = Exclude<AnyInteraction, AutocompleteInteraction>;

/**
 * A type to extend multiple discord types and simplify usage in {@link MessagePrompter}
 */
type MessagePrompterMessage = ArgumentTypes<PartialTextBasedChannelFields['send']>[0];
type MessagePrompterChannelTypes = Exclude<ChannelTypes, VoiceBasedChannelTypes | CategoryChannel>;

interface IMessagePrompterStrategyOptions {
    timeout?: number;
    explicitReturn?: boolean;
    editMessage?: Message;
}
interface IMessagePrompterConfirmStrategyOptions extends IMessagePrompterStrategyOptions {
    confirmEmoji?: string | EmojiIdentifierResolvable;
    cancelEmoji?: string | EmojiIdentifierResolvable;
}
interface IMessagePrompterNumberStrategyOptions extends IMessagePrompterStrategyOptions {
    start?: number;
    end?: number;
    numberEmojis?: string[] | EmojiIdentifierResolvable[];
}
interface IMessagePrompterReactionStrategyOptions extends IMessagePrompterStrategyOptions {
    reactions: string[] | EmojiIdentifierResolvable[];
}

declare abstract class MessagePrompterBaseStrategy {
    /**
     * The type of strategy that was used
     */
    type: string;
    /**
     * The timeout that was used in the collector
     */
    timeout: number;
    /**
     * Whether to return an explicit object with data, or the strategies' default
     */
    explicitReturn: boolean;
    /**
     * The message that has been sent in {@link MessagePrompter.run}
     */
    appliedMessage: Message | null;
    /**
     * The message that will be sent in {@link MessagePrompter.run}
     */
    message: MessagePrompterMessage;
    /**
     * The message the bot will edit to send its prompt in {@link MessagePrompter.run}
     */
    editMessage: Message | undefined;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(type: string, message: MessagePrompterMessage, options?: IMessagePrompterStrategyOptions);
    abstract run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<unknown[]>): Awaitable<unknown>;
    protected collectReactions(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>, reactions: string[] | EmojiIdentifierResolvable[]): Promise<IMessagePrompterExplicitReturnBase>;
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitReactions function
     */
    protected createReactionPromptFilter(reactions: string[] | EmojiIdentifierResolvable[], authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): CollectorOptions<[MessageReaction, User]>;
    /**
     * The default strategy options
     */
    static defaultStrategyOptions: IMessagePrompterStrategyOptions;
}

interface IMessagePrompterExplicitReturnBase {
    emoji?: GuildEmoji | ReactionEmoji;
    reaction?: string | EmojiIdentifierResolvable;
    strategy: MessagePrompterBaseStrategy;
    appliedMessage: Message;
    message: MessagePrompterMessage;
}
interface IMessagePrompterExplicitConfirmReturn extends IMessagePrompterExplicitReturnBase {
    confirmed: boolean;
}
interface IMessagePrompterExplicitNumberReturn extends IMessagePrompterExplicitReturnBase {
    number: number;
}
interface IMessagePrompterExplicitMessageReturn extends IMessagePrompterExplicitReturnBase {
    response?: Message;
}

declare class MessagePrompterConfirmStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterConfirmStrategyOptions {
    /**
     * The confirm emoji used
     */
    confirmEmoji: string | EmojiResolvable;
    /**
     * The cancel emoji used
     */
    cancelEmoji: string | EmojiResolvable;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param message The message to be sent {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options?: IMessagePrompterConfirmStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals confirm.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
     * @returns A promise that resolves to a boolean denoting the value of the input (`true` for yes, `false` for no).
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitConfirmReturn | boolean>;
    /**
     * The default confirm emoji used for {@link MessagePrompterConfirmStrategy}
     */
    static confirmEmoji: string | EmojiResolvable;
    /**
     * The default cancel emoji used for {@link MessagePrompterConfirmStrategy}
     */
    static cancelEmoji: string | EmojiResolvable;
}

declare class MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterStrategyOptions {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.
     * The handler will wait for one (1) message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
     * @returns A promise that resolves to the message object received.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[Message]>): Promise<IMessagePrompterExplicitMessageReturn | Message>;
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitMessages function
     */
    private createMessagePromptFilter;
}

declare class MessagePrompterNumberStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterNumberStrategyOptions {
    /**
     * The available number emojis
     */
    numberEmojis: EmojiIdentifierResolvable[];
    /**
     * The available number emojis
     */
    start: number;
    /**
     * The available number emojis
     */
    end: number;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterNumberStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals number.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
     * @returns A promise that resolves to the selected number within the range.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitNumberReturn | number>;
    /**
     * The default available number emojis
     */
    static numberEmojis: string[];
}

declare class MessagePrompterReactionStrategy extends MessagePrompterBaseStrategy implements MessagePrompterReactionStrategy {
    /**
     * The emojis used
     */
    reactions: EmojiIdentifierResolvable[];
    /**
     * Constructor for the {@link MessagePrompterReactionStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterReactionStrategyOptions);
    /**
     * This executes the {@link MessagePrompterReactionStrategy} and sends the message.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
     * @returns A promise that resolves to the reaction object.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitReturnBase | string | EmojiResolvable>;
}

interface StrategyReturns {
    confirm: IMessagePrompterExplicitConfirmReturn | boolean;
    message: IMessagePrompterExplicitMessageReturn | Message;
    number: IMessagePrompterExplicitNumberReturn | number;
    reaction: IMessagePrompterExplicitReturnBase | string | EmojiResolvable;
}
interface StrategyOptions {
    confirm: IMessagePrompterConfirmStrategyOptions;
    message: IMessagePrompterStrategyOptions;
    number: IMessagePrompterNumberStrategyOptions;
    reaction: IMessagePrompterReactionStrategyOptions;
}
interface StrategyFilters {
    confirm: [MessageReaction, User];
    message: [Message];
    number: [MessageReaction, User];
    reaction: [MessageReaction, User];
}
/**
 * This is a {@link MessagePrompter}, a utility that sends a message, prompting for user input. The prompt can resolve to any kind of input.
 * There are several specifiable types to prompt for user input, and they are as follows:
 * - Confirm
 *   This will send a simple Yes/No prompt, using reactions.
 * - Number
 *   This will prompt for an integer. By default it will be a number between 0 and 10 (inclusive), however you can also specify your own custom range (inclusive).
 * - Reactions
 *   This can be any kind of reaction emoji that Discord supports, and as many as you want. This type will return that reaction instead of a boolean.
 * - Message
 *   This will prompt the user and require a response in the form of a message. This can be helpful if you require a user to upload an image for example, or give text input.
 *
 * You must either use this class directly or extend it.
 *
 * {@link MessagePrompter} uses reactions to prompt for a yes/no answer and returns it.
 * You can modify the confirm and cancel reaction used for each message, or use the {@link MessagePrompter.defaultPrompts}.
 * {@link MessagePrompter.defaultPrompts} is also static so you can modify these directly.
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you sure you want to continue?');
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Choose a number between 5 and 10?', 'number', {
 * 		start: 5,
 * 		end: 10
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you happy or sad?', 'reaction', {
 * 		reactions: ['🙂', '🙁']
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Do you love me?', 'message');
 * const result = await handler.run(channel, author);
 * ```
 */
declare class MessagePrompter<S extends keyof StrategyReturns = 'confirm'> {
    /**
     * The strategy used in {@link MessagePrompter.run}
     */
    strategy: MessagePrompterBaseStrategy;
    /**
     * Constructor for the {@link MessagePrompter} class
     * @param message The message to send.
     * @param strategy The strategy name or Instance to use
     * @param strategyOptions The options that are passed to the strategy
     */
    constructor(message: MessagePrompterMessage | MessagePrompterBaseStrategy, strategy?: S, strategyOptions?: S extends keyof StrategyOptions ? StrategyOptions[S] : never);
    /**
     * This executes the {@link MessagePrompter} and sends the message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
     */
    run<Filter extends S extends keyof StrategyFilters ? StrategyFilters[S] : unknown[]>(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<Filter>): S extends keyof StrategyReturns ? Promise<StrategyReturns[S]> : never;
    /**
     * The available strategies
     */
    static strategies: Map<keyof StrategyReturns, Ctor<ConstructorParameters<typeof MessagePrompterConfirmStrategy> | ConstructorParameters<typeof MessagePrompterNumberStrategy> | ConstructorParameters<typeof MessagePrompterReactionStrategy> | ConstructorParameters<typeof MessagePrompterMessageStrategy>, MessagePrompterConfirmStrategy | MessagePrompterNumberStrategy | MessagePrompterReactionStrategy | MessagePrompterMessageStrategy>>;
    /**
     * The default strategy to use
     */
    static defaultStrategy: keyof StrategyReturns;
}

type MessageBuilderFileResolvable = NonNullable<MessageCreateOptions['files']>[number];
type MessageBuilderResolvable = Omit<MessageCreateOptions, 'embed' | 'disableMentions' | 'reply'> & {
    embeds?: MessageCreateOptions['embeds'];
};
/**
 * A message builder class, it implements the {@link MessageCreateOptions} interface.
 */
declare class MessageBuilder implements MessageCreateOptions {
    /**
     * Whether or not the message should be spoken aloud.
     * @default false
     */
    tts?: MessageCreateOptions['tts'];
    /**
     * The nonce for the message.
     * @default ''
     */
    nonce?: MessageCreateOptions['nonce'];
    /**
     * The content for the message. If set to undefined and the builder is used to edit, the content will not be
     * replaced.
     */
    content?: MessageCreateOptions['content'];
    /**
     * The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be replaced.
     * @remark There is a maximum of 10 embeds in 1 message
     */
    embeds?: MessageCreateOptions['embeds'];
    /**
     * Which mentions should be parsed from the message content.
     */
    allowedMentions?: MessageCreateOptions['allowedMentions'];
    /**
     * Files to send with the message. This should not be set when editing a message, as Discord does not support
     * editing file attachments.
     */
    files?: MessageCreateOptions['files'];
    constructor(options?: MessageBuilderResolvable);
    /**
     * Sets the value for the {@link MessageBuilder.tts} field.
     * @param tts Whether or not the message should be spoken aloud.
     */
    setTTS(tts?: boolean): this;
    /**
     * Sets the value for the {@link MessageBuilder.nonce} field.
     * @param nonce The nonce for the message.
     */
    setNonce(nonce?: string): this;
    /**
     * Sets the value for the {@link MessageBuilder.content} field.
     * @param content The content for the message. If set to undefined and the builder is used to edit, the content will
     * not be replaced.
     */
    setContent(content?: string): this;
    /**
     * Sets the value for the {@link MessageBuilder.embed} field.
     * @param embeds The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be
     * replaced. There is a maximum of 10 embeds per message
     * @remark When providing more than 10 embeds, the array will automatically be sliced down to the first 10.
     */
    setEmbeds(embeds?: MessageCreateOptions['embeds']): this;
    /**
     * Sets the value for the {@link MessageBuilder.allowedMentions} field.
     * @param allowedMentions Which mentions should be parsed from the message content.
     */
    setAllowedMentions(allowedMentions?: MessageCreateOptions['allowedMentions']): this;
    /**
     * Adds a new value for the {@link MessageBuilder.files} field array.
     * @param file The file to add to the {@link MessageBuilder.files} field array.
     */
    addFile(file: MessageBuilderFileResolvable): this;
    /**
     * Sets a single value for the {@link MessageBuilder.files} field array.
     * @param file The file to send with the message. This should not be set when editing a message, as Discord does not
     * support editing file attachments.
     */
    setFile(file: MessageBuilderFileResolvable): this;
    /**
     * Sets the value for the {@link MessageBuilder.files} field.
     * @param files The files to send with the message. This should not be set when editing a message, as Discord does
     * not support editing file attachments.
     */
    setFiles(files?: MessageBuilderFileResolvable[]): this;
    /**
     * The default values for all MessageBuilder instances.
     */
    static defaults: MessageBuilderResolvable;
}

/**
 * Represents an action that can be performed in a paginated message.
 */
type PaginatedMessageAction = PaginatedMessageActionButton | PaginatedMessageActionLink | PaginatedMessageActionStringMenu | PaginatedMessageActionUserMenu | PaginatedMessageActionRoleMenu | PaginatedMessageActionMentionableMenu | PaginatedMessageActionChannelMenu;
/**
 * Represents an action that can be run in a paginated message.
 */
interface PaginatedMessageActionRun {
    /**
     * Runs the action with the given context.
     * @param context The context object containing information about the paginated message.
     * @returns A promise that resolves when the action is complete.
     */
    run?(context: PaginatedMessageActionContext): Awaitable<unknown>;
}
/**
 * To utilize buttons you can pass an object with the structure of {@link PaginatedMessageActionButton} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const StopAction: PaginatedMessageActionButton = {
 *   customId: 'CustomStopAction',
 *   emoji: '⏹️',
 *   run: ({ collector }) => {
 *     collector.stop();
 *   }
 * }
 * ```
 */
type PaginatedMessageActionButton = InteractionButtonComponentData & PaginatedMessageActionRun;
/**
 * To utilize links you can pass an object with the structure of {@link PaginatedMessageActionLink} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 *  You can also give the object directly.
 *
 * const LinkSapphireJs: PaginatedMessageActionLink = {
 *   url: 'https://sapphirejs.dev',
 *   label: 'Sapphire Website',
 *   emoji: '🔗'
 * }
 * ```
 */
type PaginatedMessageActionLink = LinkButtonComponentData;
/**
 * To utilize String Select Menus you can pass an object with the structure of {@link PaginatedMessageActionStringMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const StringMenu: PaginatedMessageActionStringMenu = {
 *   customId: 'CustomStringSelectMenu',
 *   type: ComponentType.StringSelect,
 *   run: ({ handler, interaction }) => interaction.isStringSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
 * }
 * ```
 */
type PaginatedMessageActionStringMenu = PaginatedMessageActionRun & StringSelectMenuComponentData;
/**
 * To utilize User Select Menus you can pass an object with the structure of {@link PaginatedMessageActionUserMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const UserMenu: PaginatedMessageActionUserMenu = {
 *   customId: 'CustomUserSelectMenu',
 *   type: ComponentType.UserSelect,
 *   run: ({ interaction }) => {
 *     if (interaction.isChannelSelectMenu()) {
 *       console.log(interaction.values[0])
 *     }
 *   }
 * }
 * ```
 */
type PaginatedMessageActionUserMenu = PaginatedMessageActionRun & UserSelectMenuComponentData & {
    options?: never;
};
/**
 * To utilize Role Select Menus you can pass an object with the structure of {@link PaginatedMessageActionRoleMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const RoleMenu: PaginatedMessageActionRoleMenu = {
 *   customId: 'CustomRoleSelectMenu',
 *   type: ComponentType.RoleSelect,
 *   run: ({ interaction }) => {
 *     if (interaction.isRoleSelectMenu()) {
 *       console.log(interaction.values[0])
 *     }
 *   }
 * }
 * ```
 */
type PaginatedMessageActionRoleMenu = PaginatedMessageActionRun & RoleSelectMenuComponentData & {
    options?: never;
};
/**
 * To utilize Mentionable Select Menus you can pass an object with the structure of {@link PaginatedMessageActionMentionableMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const MentionableMenu: PaginatedMessageActionMentionableMenu = {
 *   customId: 'CustomMentionableSelectMenu',
 *   type: ComponentType.MentionableSelect,
 *   run: ({ interaction }) => {
 *     if (interaction.isMentionableSelectMenu()) {
 *       console.log(interaction.values[0])
 *     }
 *   }
 * }
 * ```
 */
type PaginatedMessageActionMentionableMenu = PaginatedMessageActionRun & MentionableSelectMenuComponentData & {
    options?: never;
};
/**
 * To utilize Channel Select Menus you can pass an object with the structure of {@link PaginatedMessageActionChannelMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const ChannelMenu: PaginatedMessageActionChannelMenu = {
 *   customId: 'CustomChannelSelectMenu',
 *   type: ComponentType.ChannelSelect,
 *   channelTypes: [ChannelType.GuildText],
 *   run: ({ interaction }) => {
 *     if (interaction.isChannelSelectMenu()) {
 *       console.log(interaction.values[0])
 *     }
 *   }
 * }
 * ```
 */
type PaginatedMessageActionChannelMenu = PaginatedMessageActionRun & ChannelSelectMenuComponentData & {
    options?: never;
};
/**
 * The context to be used in {@link PaginatedMessageActionButton}.
 */
interface PaginatedMessageActionContext {
    interaction: PaginatedMessageInteractionUnion;
    handler: PaginatedMessage;
    author: User;
    channel: Message['channel'];
    response: APIMessage | Message | CommandInteraction | ButtonInteraction | PaginatedMessageInteractionUnion;
    collector: InteractionCollector<PaginatedMessageInteractionUnion>;
}
/**
 * Options for configuring a paginated message.
 */
interface PaginatedMessageOptions {
    /**
     * The pages to display in this {@link PaginatedMessage}.
     */
    pages?: PaginatedMessagePage[];
    /**
     * Custom actions to provide when sending the paginated message.
     */
    actions?: PaginatedMessageAction[];
    /**
     * The {@link EmbedBuilder} or {@link MessageOptions} options to apply to the entire {@link PaginatedMessage}.
     */
    template?: EmbedBuilder | BaseMessageOptions;
    /**
     * The prefix to display before the page index.
     * @seealso {@link PaginatedMessage.pageIndexPrefix}
     */
    pageIndexPrefix?: string;
    /**
     * The separator to display between the embed footer and the page index.
     * @seealso {@link PaginatedMessage.embedFooterSeparator}
     */
    embedFooterSeparator?: string;
    /**
     * Additional options that are applied to each message when sending it to Discord.
     * Be careful with using this, misusing it can cause issues, such as sending empty messages.
     * @remark **This is for advanced usages only!**
     *
     * @default null
     */
    paginatedMessageData?: Omit<PaginatedMessageMessageOptionsUnion, 'components'> | null;
}
/**
 * The pages that are used for {@link PaginatedMessage.pages}
 *
 * Pages can be either a {@link Message},
 * or an {@link Awaitable} function that returns a {@link Message}.
 *
 * Furthermore, {@link MessageOptions} can be used to
 * construct the pages without state. This library also provides {@link MessageBuilder}, which can be used as a chainable
 * alternative to raw objects, similar to how {@link MessageEmbed}
 * works.
 *
 * Ideally, however, you should use the utility functions
 * {@link PaginatedMessage.addPageBuilder `addPageBuilder`}, {@link PaginatedMessage.addPageContent `addPageContent`}, and {@link PaginatedMessage.addPageEmbed `addPageEmbed`}
 * as opposed to manually constructing {@link PaginatedMessagePage `MessagePages`}. This is because a {@link PaginatedMessage} does a lot of post-processing
 * on the provided pages and we can only guarantee this will work properly when using the utility methods.
 */
type PaginatedMessagePage = ((index: number, pages: PaginatedMessagePage[], handler: PaginatedMessage) => Awaitable<PaginatedMessageMessageOptionsUnion>) | PaginatedMessageMessageOptionsUnion;
/**
 * Represents a resolved page for a paginated message.
 * It can be either a `BaseMessageOptions` object with the `flags` property omitted,
 * or a `WebhookMessageEditOptions` object.
 */
type PaginatedMessageResolvedPage = Omit<BaseMessageOptions, 'flags'> | WebhookMessageEditOptions;
/**
 * The type of the custom function that can be set for the {@link PaginatedMessage.selectMenuOptions}
 */
type PaginatedMessageSelectMenuOptionsFunction = (pageIndex: number, internationalizationContext: PaginatedMessageInternationalizationContext) => Awaitable<Omit<SelectMenuComponentOptionData, 'value'>>;
/**
 * The type of the custom function that can be set for the {@link PaginatedMessage.wrongUserInteractionReply}
 */
type PaginatedMessageWrongUserInteractionReplyFunction = (targetUser: User, interactionUser: User, internationalizationContext: PaginatedMessageInternationalizationContext) => Awaitable<Parameters<MessageComponentInteraction['reply']>[0]>;
/**
 * Represents the resolvable type for the embeds property of a paginated message.
 */
type PaginatedMessageEmbedResolvable = BaseMessageOptions['embeds'];
/**
 * Represents the union of options for a paginated message.
 */
type PaginatedMessageMessageOptionsUnion = Omit<PaginatedMessageResolvedPage, 'components'> & {
    actions?: PaginatedMessageAction[];
};
/**
 * Represents the union type of interactions for a paginated message, excluding the ModalSubmitInteraction.
 */
type PaginatedMessageInteractionUnion = Exclude<CollectedInteraction, ModalSubmitInteraction>;
/**
 * Represents a union type for components in a paginated message.
 * It can be one of the following types:
 * - `JSONEncodable<APIActionRowComponent<APIMessageActionRowComponent>>`
 * - `ActionRowData<ActionRowComponentOptions | MessageActionRowComponentBuilder>`
 * - `APIActionRowComponent<APIMessageActionRowComponent>`
 */
type PaginatedMessageComponentUnion = JSONEncodable<APIActionRowComponent<APIMessageActionRowComponent>> | ActionRowData<ActionRowComponentOptions | MessageActionRowComponentBuilder> | APIActionRowComponent<APIMessageActionRowComponent>;
/**
 * @internal This is a duplicate of the same interface in `@sapphire/plugin-i18next`
 * Duplicated here for the type of the parameters in the functions
 *
 * Context for {@link InternationalizationHandler.fetchLanguage} functions.
 * This context enables implementation of per-guild, per-channel, and per-user localization.
 */
interface PaginatedMessageInternationalizationContext {
    /** The {@link Guild} object to fetch the preferred language for, or `null` if the language is to be fetched in a DM. */
    guild: Guild | null;
    /** The {@link DiscordChannel} object to fetch the preferred language for. */
    channel: Message['channel'] | StageChannel | VoiceChannel | null;
    /** The user to fetch the preferred language for. */
    user: User | null;
    /** The {@link Interaction.guildLocale} provided by the Discord API */
    interactionGuildLocale?: Interaction['guildLocale'];
    /** The {@link Interaction.locale} provided by the Discord API */
    interactionLocale?: Interaction['locale'];
}
/**
 * Represents the parameters for safely replying to an interaction.
 * @template T - The type of message method ('edit', 'reply', or never).
 */
interface SafeReplyToInteractionParameters<T extends 'edit' | 'reply' | never = never> {
    /**
     * The message or interaction to reply to.
     */
    messageOrInteraction: APIMessage | Message | AnyInteractableInteraction;
    /**
     * The content to use when editing a reply to an interaction.
     */
    interactionEditReplyContent: WebhookMessageEditOptions;
    /**
     * The content to use when replying to an interaction.
     */
    interactionReplyContent: InteractionReplyOptions;
    /**
     * The content to use when updating a component interaction.
     */
    componentUpdateContent: InteractionUpdateOptions;
    /**
     * The method to use when sending a message.
     */
    messageMethod?: T;
    /**
     * The content to use when sending a message using the 'reply' method.
     */
    messageMethodContent?: T extends 'reply' ? MessageReplyOptions : MessageEditOptions;
}
/**
 * Represents the possible reasons for stopping a paginated message.
 */
type PaginatedMessageStopReasons = 'time' | 'idle' | 'user' | 'messageDelete' | 'channelDelete' | 'threadDelete' | 'guildDelete' | 'limit' | 'componentLimit' | 'userLimit';
/**
 * Represents a resolvable object that can be used to create an embed in Discord.
 * It can be either a JSON-encodable object or an APIEmbed object.
 */
type EmbedResolvable = JSONEncodable<APIEmbed> | APIEmbed;

/**
 * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).
 * You must either use this class directly or extend it.
 *
 * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.
 * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.
 *
 * {@link PaginatedMessage} uses {@linkplain https://discord.js.org/docs/packages/discord.js/main/MessageComponent:TypeAlias MessageComponent} buttons that perform the specified action when clicked.
 * You can either use your own actions or the {@link PaginatedMessage.defaultActions}.
 * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.
 *
 * {@link PaginatedMessage} also uses pages via {@linkplain https://discord.js.org/docs/packages/discord.js/main/Message:Class Messages}.
 *
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage();
 * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.
 * // For more details see each method's documentation.
 *
 * myPaginatedMessage.addPageEmbed((embed) => {
 *		embed
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return embed;
 * });
 *
 * myPaginatedMessage.addPageBuilder((builder) => {
 *		const embed = new EmbedBuilder()
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return builder
 *			.setContent('example content')
 *			.setEmbeds([embed]);
 * });
 *
 * myPaginatedMessage.addPageContent('Example');
 *
 * myPaginatedMessage.run(message)
 * ```
 *
 * @remark You can also provide a EmbedBuilder template. This will be applied to every page.
 * If a page itself has an embed then the two will be merged, with the content of
 * the page's embed taking priority over the template.
 *
 * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer
 * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`
 * the resulting footer will be `1/2 - Powered by Sapphire Framework`
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage({
 * 	template: new EmbedBuilder().setColor('#FF0000').setFooter('- Powered by Sapphire framework')
 * });
 * ```
 *
 * @remark To utilize actions you can implement IPaginatedMessageAction into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = '▶️';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction = {
 *   customId: 'CustomStopAction',
 *   run: ({ collector }) => {
 *     collector.stop();
 *   }
 * }
 * ```
 */
declare class PaginatedMessage {
    #private;
    /**
     * The default actions of this handler.
     */
    static defaultActions: PaginatedMessageAction[];
    /**
     * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client the `'CHANNEL'` partial.
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     *
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setEmitPartialDMChannelWarning(newBoolean)`
     * @default true
     */
    static emitPartialDMChannelWarning: boolean;
    /**
     * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
     * @default ['@sapphire/paginated-messages.stop']
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setStopPaginatedMessageCustomIds(customIds)`
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.stopPaginatedMessageCustomIds = ['my-custom-stop-custom-id'];
     * ```
     */
    static stopPaginatedMessageCustomIds: string[];
    /**
     * The reasons sent by {@linkplain https://discord.js.org/docs/packages/discord.js/main/InteractionCollector:Class#end InteractionCollector#end}
     * event when the message (or its owner) has been deleted.
     */
    static deletionStopReasons: string[];
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ""
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.pageIndexPrefix = 'Page';
     * // This will make the footer of the embed something like "Page 1/2"
     * ```
     */
    static pageIndexPrefix: string;
    /**
     * Custom separator for the page index in the embed footer.
     * @default "•"
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by passing `embedFooterSeparator` in the options of the constructor.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.embedFooterSeparator = '|';
     * // This will make the separator of the embed footer something like "Page 1/2 | Today at 4:20"
     * ```
     */
    static embedFooterSeparator: string;
    /**
     * The messages that are currently being handled by a {@link PaginatedMessage}
     * The key is the ID of the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
     * This is important when having an editable commands solution.
     */
    static readonly messages: Map<string, PaginatedMessage>;
    /**
     * The current {@link InteractionCollector} handlers that are active.
     * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
     * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
     */
    static readonly handlers: Map<string, PaginatedMessage>;
    /**
     * A generator for {@link MessageSelectOption} that will be used to generate the options for the {@link StringSelectMenuBuilder}.
     * We do not allow overwriting the {@link MessageSelectOption#value} property with this, as it is vital to how we handle
     * select menu interactions.
     *
     * @param pageIndex The index of the page to add to the {@link StringSelectMenuBuilder}. We will add 1 to this number because our pages are 0 based,
     * so this will represent the pages as seen by the user.
     * @default
     * ```ts
     * {
     * 	label: `Page ${pageIndex}`
     * }
     * ```
     * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.selectMenuOptions = (pageIndex) => ({
     * 	 label: `Go to page: ${pageIndex}`,
     * 	 description: 'This is a description'
     * });
     * ```
     */
    static selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction;
    /**
     * A generator for {@link MessageComponentInteraction#reply} that will be called and sent whenever an untargeted user interacts with one of the buttons.
     * When modifying this it is recommended that the message is set to be ephemeral so only the user that is pressing the buttons can see them.
     * Furthermore, we also recommend setting `allowedMentions: { users: [], roles: [] }`, so you don't have to worry about accidentally pinging anyone.
     *
     * When setting just a string, we will add `{ ephemeral: true, allowedMentions: { users: [], roles: [] } }` for you.
     *
     * @param targetUser The {@link User} this {@link PaginatedMessage} was intended for.
     * @param interactionUser The {@link User} that actually clicked the button.
     * @default
     * ```ts
     * import { userMention } from 'discord.js';
     *
     * {
     * 	content: `Please stop interacting with the components on this message. They are only for ${userMention(targetUser.id)}.`,
     * 	ephemeral: true,
     * 	allowedMentions: { users: [], roles: [] }
     * }
     * ```
     * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     * import { userMention } from 'discord.js';
     *
     * // We  will add ephemeral and no allowed mention for string only overwrites
     * PaginatedMessage.wrongUserInteractionReply = (targetUser) =>
     *     `These buttons are only for ${userMention(targetUser.id)}. Press them as much as you want, but I won't do anything with your clicks.`;
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     * import { userMention } from 'discord.js';
     *
     * PaginatedMessage.wrongUserInteractionReply = (targetUser) => ({
     * 	content: `These buttons are only for ${userMention(
     * 		targetUser.id
     * 	)}. Press them as much as you want, but I won't do anything with your clicks.`,
     * 	ephemeral: true,
     * 	allowedMentions: { users: [], roles: [] }
     * });
     * ```
     */
    static wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction;
    /**
     * Resolves the template for the PaginatedMessage.
     *
     * @param template - The template to resolve.
     * @returns The resolved template as a BaseMessageOptions object.
     */
    private static resolveTemplate;
    /**
     * The pages to be converted to {@link PaginatedMessage.messages}
     */
    pages: PaginatedMessagePage[];
    /**
     * The response message used to edit on page changes.
     */
    response: Message | AnyInteractableInteraction | null;
    /**
     * The collector used for handling component interactions.
     */
    collector: InteractionCollector<PaginatedMessageInteractionUnion> | null;
    /**
     * The pages which were converted from {@link PaginatedMessage.pages}
     */
    messages: (PaginatedMessageResolvedPage | null)[];
    /**
     * The actions which are to be used.
     */
    actions: Map<string, PaginatedMessageAction>;
    /**
     * The page-specific actions which are to be used.
     */
    pageActions: (Map<string, PaginatedMessageAction> | null)[];
    /**
     * The handler's current page/message index.
     */
    index: number;
    /**
     * The amount of milliseconds to idle before the paginator is closed.
     * @default 14.5 minutes
     * @remark This is to ensure it is a bit before interactions expire.
     */
    idle: number;
    /**
     * The template for this {@link PaginatedMessage}.
     * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
     */
    template: PaginatedMessageMessageOptionsUnion;
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
     */
    pageIndexPrefix: string;
    /**
     * Custom separator to show after the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.embedFooterSeparator``` (static property)
     */
    embedFooterSeparator: string;
    /**
     * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
     * @default ```PaginatedMessage.stopPaginatedMessageCustomIds``` (static property)
     */
    stopPaginatedMessageCustomIds: string[];
    /**
     * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client having the `'CHANNEL'` partial.
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     *
     * @default ```PaginatedMessage.emitPartialDMChannelWarning``` (static property)
     */
    emitPartialDMChannelWarning: boolean;
    /**
     * Data for the paginated message.
     */
    protected paginatedMessageData: Omit<PaginatedMessageMessageOptionsUnion, 'components'> | null;
    /**
     * The placeholder for the select menu.
     */
    protected selectMenuPlaceholder: string | undefined;
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the maximum amount of pages in the {@link SelectMenu}.
     *
     * @default false
     */
    protected hasEmittedMaxPageWarning: boolean;
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the {@link PaginatedMessage} being called in a `DMChannel`
     * without the client having the `'Channel'` partial.
     *
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     * @default false
     */
    protected hasEmittedPartialDMChannelWarning: boolean;
    /**
     * Determines whether the default footer that shows the current page number should be added to the embeds.
     *
     * @note If this is set to false, i.e.e through {@link setShouldAddFooterToEmbeds}, then {@link embedFooterSeparator}
     * is never applied.
     *
     * @default true
     */
    protected shouldAddFooterToEmbeds: boolean;
    /**
     * Function that returns the select menu options for the paginated message.
     * @param message The paginated message.
     * @returns The select menu options.
     */
    protected selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction;
    /**
     * Function that handles the reply when a user interacts with the paginated message incorrectly.
     */
    protected wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction;
    /**
     * Constructor for the {@link PaginatedMessage} class
     * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
     */
    constructor({ pages, actions, template, pageIndexPrefix, embedFooterSeparator, paginatedMessageData }?: PaginatedMessageOptions);
    /**
     * Sets the {@link PaginatedMessage.selectMenuOptions} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param newOptions The new options generator to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setSelectMenuOptions(newOptions: PaginatedMessageSelectMenuOptionsFunction): this;
    /**
     * Sets the {@link PaginatedMessage.selectMenuPlaceholder} for this instance of {@link PaginatedMessage}.
     *
     * This applies only to the string select menu from the {@link PaginatedMessage.defaultActions}
     * that offers "go to page" (we internally check the customId for this)
     *
     * This will only apply to this one instance and no others.
     * @param placeholder The new placeholder to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setSelectMenuPlaceholder(placeholder: string | undefined): this;
    /**
     * Sets the {@link PaginatedMessage.wrongUserInteractionReply} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param wrongUserInteractionReply The new `wrongUserInteractionReply` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setWrongUserInteractionReply(wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction): this;
    /**
     * Sets the {@link PaginatedMessage.stopPaginatedMessageCustomIds} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param stopPaginatedMessageCustomIds The new `stopPaginatedMessageCustomIds` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds: string[]): this;
    /**
     * Sets the {@link PaginatedMessage.emitPartialDMChannelWarning} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param emitPartialDMChannelWarning The new `emitPartialDMChannelWarning` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setEmitPartialDMChannelWarning(emitPartialDMChannelWarning: boolean): this;
    /**
     * Sets the handler's current page/message index.
     * @param index The number to set the index to.
     */
    setIndex(index: number): this;
    /**
     * Sets the amount of time to idle before the paginator is closed.
     * @param idle The number to set the idle to.
     */
    setIdle(idle: number): this;
    /**
     * Sets the value of {@link shouldAddFooterToEmbeds} property and returns the instance of the class.
     * @param newValue - The new value for {@link shouldAddFooterToEmbeds}.
     * @returns The instance of the class with the updated {@link shouldAddFooterToEmbeds} value.
     */
    setShouldAddFooterToEmbeds(newValue: boolean): this;
    /**
     * Clears all current actions and sets them. The order given is the order they will be used.
     * @param actions The actions to set. This can be either a Button, Link Button, or Select Menu.
     * @param includeDefaultActions Whether to merge in the {@link PaginatedMessage.defaultActions} when setting the actions.
     * If you set this to true then you do not need to manually add `...PaginatedMessage.defaultActions` as seen in the first example.
     * The default value is `false` for backwards compatibility within the current major version.
     *
     * @remark You can retrieve the default actions for the regular pagination
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   ...PaginatedMessage.defaultActions,
     * ])
     * ```
     *
     * @remark You can add custom Message Buttons by providing `style`, `customId`, `type`, `run` and at least one of `label` or `emoji`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     style: 'PRIMARY',
     *     label: 'My Button',
     *     customId: 'custom_button',
     *     type: ComponentType.Button,
     *     run: (context) => console.log(context)
     *   }
     * ], true);
     * ```
     *
     * @remark You can add custom Message **Link** Buttons by providing `style`, `url`, `type`, and at least one of `label` or `emoji`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     style: 'LINK',
     *     label: 'Sapphire Website',
     *     emoji: '🔷',
     *     url: 'https://sapphirejs.dev',
     *     type: ComponentType.Button
     *   }
     * ], true);
     * ```
     *
     * @remark You can add custom Select Menus by providing `customId`, `type`, and `run`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     customId: 'custom_menu',
     *     type: ComponentType.StringSelect,
     *     run: (context) => console.log(context) // Do something here
     *   }
     * ], true);
     * ```
     */
    setActions(actions: PaginatedMessageAction[], includeDefaultActions?: boolean): this;
    /**
     * Adds actions to the existing ones. The order given is the order they will be used.
     * @param actions The actions to add.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.
     */
    addActions(actions: PaginatedMessageAction[]): this;
    /**
     * Adds an action to the existing ones. This will be added as the last action.
     * @param action The action to add.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.
     */
    addAction(action: PaginatedMessageAction): this;
    /**
     * Checks whether or not the handler has a specific page.
     * @param index The index to check.
     */
    hasPage(index: number): boolean;
    /**
     * Clears all current pages and messages and sets them. The order given is the order they will be used.
     * @param pages The pages to set.
     */
    setPages(pages: PaginatedMessagePage[]): this;
    /**
     * Adds a page to the existing ones. This will be added as the last page.
     * @remark While you can use this method you should first check out
     * {@link PaginatedMessage.addPageBuilder},
     * {@link PaginatedMessage.addPageContent} and
     * {@link PaginatedMessage.addPageEmbed} as
     * these are easier functional methods of adding pages and will likely already suffice for your needs.
     *
     * @param page The page to add.
     */
    addPage(page: PaginatedMessagePage): this;
    /**
     * Update the current page.
     * @param page The content to update the page with.
     *
     * @remark This method can only be used after {@link PaginatedMessage.run} has been used.
     */
    updateCurrentPage(page: PaginatedMessagePage): Promise<this>;
    /**
     * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { EmbedBuilder } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder((builder) => {
     * 		const embed = new EmbedBuilder()
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbeds([embed]);
     * });
     * ```
     * @example
     * ```typescript
     * const { EmbedBuilder } = require('discord.js');
     * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new EmbedBuilder()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const builder = new MessageBuilder()
     * 	.setContent('example content')
     * 	.setEmbeds([embed]);
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder(builder);
     * ```
     */
    addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { EmbedBuilder } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageBuilder(async (builder) => {
     * 		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		const embed = new EmbedBuilder()
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbeds([embed]);
     * });
     * ```
     */
    addAsyncPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => Promise<MessageBuilder>)): this;
    /**
     * Adds a page to the existing ones using simple message content. This will be added as the last page.
     * @param content The content to set.
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageContent('example content');
     * ```
     */
    addPageContent(content: string): this;
    /**
     * Adds a page to the existing ones using a {@link EmbedBuilder}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new EmbedBuilder()`, or an already constructed {@link EmbedBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed((embed) => {
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return embed;
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new EmbedBuilder()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed(embed);
     * ```
     */
    addPageEmbed(embed: EmbedResolvable | ((embed: EmbedBuilder) => EmbedResolvable)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link EmbedBuilder}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new EmbedBuilder()`, or an already constructed {@link EmbedBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbed(async (embed) => {
     *		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return embed;
     * });
     * ```
     */
    addAsyncPageEmbed(embed: EmbedResolvable | ((builder: EmbedBuilder) => Awaitable<EmbedResolvable>)): this;
    /**
     * Adds a page to the existing ones asynchronously using multiple {@link EmbedBuilder}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link EmbedBuilder}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new EmbedBuilder()`, or an array of already constructed {@link EmbedBuilder}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
     * 		embed1
     * 			.setColor('#FF0000')
     * 			.setDescription('example description 1');
     *
     * 		embed2
     * 			.setColor('#00FF00')
     * 			.setDescription('example description 2');
     *
     * 		embed3
     * 			.setColor('#0000FF')
     * 			.setDescription('example description 3');
     *
     * 		return [embed1, embed2, embed3];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new EmbedBuilder()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new EmbedBuilder()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new EmbedBuilder()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addPageEmbeds(embeds: EmbedResolvable[] | ((embed1: EmbedBuilder, embed2: EmbedBuilder, embed3: EmbedBuilder, embed4: EmbedBuilder, embed5: EmbedBuilder, embed6: EmbedBuilder, embed7: EmbedBuilder, embed8: EmbedBuilder, embed9: EmbedBuilder, embed10: EmbedBuilder) => EmbedResolvable[])): this;
    /**
     * Adds a page to the existing ones using multiple {@link EmbedBuilder}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link EmbedBuilder}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new EmbedBuilder()`, or an array of already constructed {@link EmbedBuilder}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
     * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
     *
     * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
     * 		switch (index) {
     * 			case '0': {
     * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '1': {
     * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '2': {
     * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
     * 				break;
     * 			}
     * 		}
     * 	}
     *
     * 	return [embed0, embed1, embed2];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new EmbedBuilder()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new EmbedBuilder()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new EmbedBuilder()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addAsyncPageEmbeds(embeds: EmbedResolvable[] | ((embed1: EmbedBuilder, embed2: EmbedBuilder, embed3: EmbedBuilder, embed4: EmbedBuilder, embed5: EmbedBuilder, embed6: EmbedBuilder, embed7: EmbedBuilder, embed8: EmbedBuilder, embed9: EmbedBuilder, embed10: EmbedBuilder) => Awaitable<EmbedResolvable[]>)): this;
    /**
     * Add pages to the existing ones. The order given is the order they will be used.
     * @param pages The pages to add.
     */
    addPages(pages: PaginatedMessagePage[]): this;
    /**
     * Clear all actions for a page and set the new ones.
     * @param actions The actions to set.
     * @param index The index of the page to set the actions to. **This is 0-based**.
     *
     * @remark Internally we check if the provided index exists.
     * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
     * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
     * - {@link PaginatedMessage.addAsyncPageEmbed}
     * - {@link PaginatedMessage.addPageBuilder}
     * - {@link PaginatedMessage.addPageContent}
     * - {@link PaginatedMessage.addPageEmbed}
     * - {@link PaginatedMessage.addPageEmbeds}
     * - {@link PaginatedMessage.addPages}
     * - {@link PaginatedMessage.setPages}
     *
     * @remark Add a select menu to the first page, while preserving all default actions:
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setPageActions([
     *   {
     *     customId: 'custom_menu',
     *     type: ComponentType.StringSelect,
     *     run: (context) => console.log(context) // Do something here
     *   }
     * ], 0);
     * ```
     * @see {@link PaginatedMessage.setActions} for more examples on how to structure the action.
     */
    setPageActions(actions: PaginatedMessageAction[], index: number): this;
    /**
     * Add the provided actions to a page.
     * @param actions The actions to add.
     * @param index The index of the page to add the actions to.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.
     *
     * @remark Internally we check if the provided index exists.
     * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
     * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
     * - {@link PaginatedMessage.addAsyncPageEmbed}
     * - {@link PaginatedMessage.addPageBuilder}
     * - {@link PaginatedMessage.addPageContent}
     * - {@link PaginatedMessage.addPageEmbed}
     * - {@link PaginatedMessage.addPageEmbeds}
     * - {@link PaginatedMessage.addPages}
     * - {@link PaginatedMessage.setPages}
     */
    addPageActions(actions: PaginatedMessageAction[], index: number): this;
    /**
     * Add the provided action to a page.
     * @param action The action to add.
     * @param index The index of the page to add the action to.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.
     *
     * @remark Internally we check if the provided index exists.
     * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
     * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
     * - {@link PaginatedMessage.addAsyncPageEmbed}
     * - {@link PaginatedMessage.addPageBuilder}
     * - {@link PaginatedMessage.addPageContent}
     * - {@link PaginatedMessage.addPageEmbed}
     * - {@link PaginatedMessage.addPageEmbeds}
     * - {@link PaginatedMessage.addPages}
     * - {@link PaginatedMessage.setPages}
     */
    addPageAction(action: PaginatedMessageAction, index: number): this;
    /**
     * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
     * The handler will start collecting message component interactions.
     *
     * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.
     * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.
     *
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message or an interaction
     * (either a {@link CommandInteraction}, {@link ContextMenuInteraction}, or an interaction from {@link PaginatedMessageInteractionUnion}),
     * but it can also be another message from your client, i.e. to indicate a loading state.
     *
     * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.
     * If `messageOrInteraction` is an instance of {@link Message} then this defaults to {@link Message.author messageOrInteraction.author},
     * and if it is an instance of {@link CommandInteraction} then it defaults to {@link CommandInteraction.user messageOrInteraction.user}.
     */
    run(messageOrInteraction: Message | AnyInteractableInteraction, target?: User): Promise<this>;
    /**
     * Executed whenever {@link PaginatedMessage.run} is called.
     */
    resolvePagesOnRun(messageOrInteraction: Message | AnyInteractableInteraction, target: User): Promise<void>;
    /**
     * Executed whenever an action is triggered and resolved.
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.
     * @param index The index to resolve.
     */
    resolvePage(messageOrInteraction: Message | AnyInteractableInteraction, target: User, index: number): Promise<PaginatedMessageResolvedPage>;
    /**
     * Clones the current handler into a new instance.
     */
    clone(): PaginatedMessage;
    /**
     * Get the options of a page.
     * @param index The index of the page.
     */
    getPageOptions(index: number): Promise<PaginatedMessageMessageOptionsUnion | undefined>;
    /**
     * Sets up the message.
     *
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message or an interaction
     * (either a {@link CommandInteraction}, {@link ContextMenuInteraction}, or an interaction from {@link PaginatedMessageInteractionUnion}),
     * but it can also be another message from your client, i.e. to indicate a loading state.
     */
    protected setUpMessage(messageOrInteraction: Message | AnyInteractableInteraction): Promise<void>;
    /**
     * Sets up the message's collector.
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * @param targetUser The user the handler is for.
     */
    protected setUpCollector(messageOrInteraction: Message<boolean> | AnyInteractableInteraction, targetUser: User): void;
    /**
     * Handles the load of a page.
     * @param page The page to be loaded.
     * @param index The index of the current page.
     */
    protected handlePageLoad(page: PaginatedMessagePage, index: number): Promise<PaginatedMessageMessageOptionsUnion>;
    /**
     * Handles the loading of actions.
     * @param actions The actions to be loaded.
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * @param targetUser The user the handler is for.
     */
    protected handleActionLoad(actions: PaginatedMessageAction[], messageOrInteraction: Message | AnyInteractableInteraction, targetUser: User): Promise<MessageActionRowComponentBuilder[]>;
    /**
     * Handles the `collect` event from the collector.
     * @param targetUser The user the handler is for.
     * @param channel The channel the handler is running at.
     * @param interaction The button interaction that was received.
     */
    protected handleCollect(targetUser: User, channel: Message['channel'], interaction: PaginatedMessageInteractionUnion): Promise<void>;
    /**
     * Handles the `end` event from the collector.
     * @param reason The reason for which the collector was ended.
     */
    protected handleEnd(_: Collection<Snowflake, PaginatedMessageInteractionUnion>, reason: PaginatedMessageStopReasons): Promise<void>;
    /**
     * Applies footer to the last embed of the page
     * @param message The message options
     * @param index The current index
     * @returns The message options with the footer applied
     */
    protected applyFooter(message: PaginatedMessageMessageOptionsUnion, index: number): PaginatedMessageMessageOptionsUnion;
    /**
     * Constructs a {@link PaginatedMessageInternationalizationContext}
     * @param messageOrInteraction The message or interaction for which the {@link PaginatedMessageInternationalizationContext} should be resolved.
     * @param targetUser The target user for whom this interaction is
     * @returns A constructed {@link PaginatedMessageInternationalizationContext}
     */
    protected resolvePaginatedMessageInternationalizationContext(messageOrInteraction: Message | AnyInteractableInteraction, targetUser: User): PaginatedMessageInternationalizationContext;
    /**
     * Applies a template to the provided options, merging them together and applying the template's embeds.
     *
     * @param template - The template to apply.
     * @param options - The options to merge with the template.
     * @returns The merged options with the template's embeds applied.
     */
    private applyTemplate;
    /**
     * Applies a template embed to the page embeds.
     * If the page embeds are nullish, it returns the template embed as an array.
     * If the template embed is nullish, it returns the page embeds.
     * Otherwise, it merges the template embed with the first page embed.
     *
     * @param templateEmbed - The template embed to apply.
     * @param pageEmbeds - The page embeds to apply the template to.
     * @returns The resulting embeds after applying the template.
     */
    private applyTemplateEmbed;
    /**
     * Merges the template embed with an array of page embeds.
     *
     * @param templateEmbed - The template embed to merge.
     * @param pageEmbeds - The array of page embeds to merge.
     * @returns The merged embeds.
     */
    private mergeEmbeds;
    /**
     * Merges two arrays together.
     * @template T - The type of elements in the arrays.
     * @param {T[]} template - The first array to merge.
     * @param {T[]} array - The second array to merge.
     * @returns {undefined | T[]} - The merged array or undefined if both arrays are nullish.
     */
    private mergeArrays;
    /**
     * Retrieves the PaginatedMessageAction associated with the provided customId and index.
     *
     * @param customId - The customId of the action.
     * @param index - The index of the action in the pageActions array.
     * @returns The PaginatedMessageAction associated with the customId and index, or undefined if not found.
     */
    private getAction;
}
/**
 * The `PaginatedMessage` interface represents a paginated message.
 */
interface PaginatedMessage {
    /**
     * The `constructor` field represents the constructor of the `PaginatedMessage` interface.
     * It is of type `typeof PaginatedMessage`, which means it refers to the type of the `PaginatedMessage` interface itself.
     */
    constructor: typeof PaginatedMessage;
}

/**
 * This is a LazyPaginatedMessage. Instead of resolving all pages that are functions on {@link PaginatedMessage.run} will resolve when requested.
 */
declare class LazyPaginatedMessage extends PaginatedMessage {
    /**
     * Only resolves the page corresponding with the handler's current index.
     */
    resolvePagesOnRun(messageOrInteraction: Message | AnyInteractableInteraction, target: User): Promise<void>;
    /**
     * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.
     * @param messageOrInteraction The message or interaction that triggered this {@link LazyPaginatedMessage}.
     * @param target The user who will be able to interact with the buttons of this {@link LazyPaginatedMessage}.
     * @param index The index to resolve. Defaults to handler's current index.
     */
    resolvePage(messageOrInteraction: Message | AnyInteractableInteraction, target: User, index: number): Promise<PaginatedMessageResolvedPage>;
    addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this;
    addPageContent(content: string): this;
    addPageEmbed(embed: EmbedResolvable | ((builder: EmbedBuilder) => EmbedResolvable)): this;
    addPageEmbeds(embeds: EmbedResolvable[] | ((embed1: EmbedBuilder, embed2: EmbedBuilder, embed3: EmbedBuilder, embed4: EmbedBuilder, embed5: EmbedBuilder, embed6: EmbedBuilder, embed7: EmbedBuilder, embed8: EmbedBuilder, embed9: EmbedBuilder, embed10: EmbedBuilder) => EmbedResolvable[])): this;
}

/**
 * This is a utility of {@link PaginatedMessage}, except it exclusively adds pagination inside a field of an embed.
 * You must either use this class directly or extend it.
 *
 * It differs from PaginatedMessageEmbedFields as the items here are the shape you want, and are then concatenated
 * in a single field with a given formatter function, whereas PaginatedMessageEmbedFields takes fields as the items
 * and add them to the embed.
 *
 * @example
 * ```typescript
 * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
 *
 * new PaginatedFieldMessageEmbed()
 *    .setTitleField('Test pager field')
 *    .setTemplate({ embed })
 *    .setItems([
 *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
 *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
 *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
 *     ])
 *    .formatItems((item) => `${item.title}\n${item.value}`)
 *    .setItemsPerPage(2)
 *    .make()
 *    .run(message);
 * ```
 */
declare class PaginatedFieldMessageEmbed<T> extends PaginatedMessage {
    /**
     * The `embedTemplate` field represents the template for the embed message. It is of type `APIEmbed`.
     * It is initialized with a new `EmbedBuilder` instance converted to JSON.
     */
    private embedTemplate;
    /**
     * The `totalPages` field represents the total number of pages in the paginated message. It is of type `number`.
     * It is initialized to 0.
     */
    private totalPages;
    /**
     * The `items` field represents the items to be displayed in the paginated message. It is an array of type `T`.
     * It is initialized to an empty array.
     */
    private items;
    /**
     * The `itemsPerPage` field represents the number of items to be displayed per page. It is of type `number`.
     * It is initialized to 10.
     */
    private itemsPerPage;
    /**
     * The `fieldTitle` field represents the title of the field in the embed message. It is of type `string`.
     * It is initialized to an empty string.
     */
    private fieldTitle;
    /**
     * Set the items to paginate.
     * @param items The pages to set
     */
    setItems(items: T[]): this;
    /**
     * Set the title of the embed field that will be used to paginate the items.
     * @param title The field title
     */
    setTitleField(title: string): this;
    /**
     * Sets the amount of items that should be shown per page.
     * @param itemsPerPage The number of items
     */
    setItemsPerPage(itemsPerPage: number): this;
    /**
     * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link EmbedBuilder} instance or an object with embed options.
     *
     * @param template EmbedBuilder
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     * import { EmbedBuilder } from 'discord.js';
     *
     * new PaginatedFieldMessageEmbed().setTemplate(new EmbedBuilder().setTitle('Test pager embed')).make().run(message);
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed().setTemplate({ title: 'Test pager embed' }).make().run(message);
     * ```
     */
    setTemplate(template: EmbedData | EmbedResolvable | ((embed: EmbedBuilder) => EmbedResolvable)): this;
    /**
     * Sets a format callback that will be mapped to each embed field in the array of items when the embed is paginated. This should convert each item to a format that is either text itself or can be serialized as text.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     * @param formatter The formatter callback to be applied to each embed item
     */
    formatItems(formatter: (item: T, index: number, array: T[]) => any): this;
    /**
     * Build the pages of the given array.
     *
     * You must call the {@link PaginatedFieldMessageEmbed.make} and {@link PaginatedFieldMessageEmbed.run} methods last, in that order, for the pagination to work.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     */
    make(): this;
    /**
     * Generates the pages for the paginated field message embed.
     * Each page contains a cloned template with modified fields and data.
     */
    private generatePages;
    /**
     * Paginates an array of items.
     *
     * @template T The type of items in the array.
     * @param items The array of items to paginate.
     * @param currentPage The current page number.
     * @param perPageItems The number of items per page.
     * @returns The paginated array of items.
     */
    private paginateArray;
    /**
     * Resolves the template for the embed.
     *
     * @param template - The template for the embed. It can be an EmbedResolvable, EmbedData, or a function that takes an EmbedBuilder and returns an EmbedResolvable.
     * @returns The resolved APIEmbed object.
     */
    private resolveTemplate;
}

/**
 * This is a utility of {@link PaginatedMessage}, except it exclusively paginates the fields of an embed.
 * You must either use this class directly or extend it.
 *
 * It differs from PaginatedFieldMessageEmbed as the items here are whole fields, that are added to the embed,
 * whereas PaginatedFieldMessageEmbed concatenates the items in a single field with a given formatter function.
 *
 * @example
 * ```typescript
 * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
 *
 * new PaginatedMessageEmbedFields()
 * 	.setTemplate({ title: 'Test pager embed', color: '#006080' })
 * 	.setItems([
 * 		{ name: 'Sapphire Framework', value: 'discord.js Framework' },
 * 		{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
 * 		{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
 * 	])
 * 	.setItemsPerPage(2)
 * 	.make()
 * 	.run(message);
 * ```
 */
declare class PaginatedMessageEmbedFields extends PaginatedMessage {
    /**
     * The `embedTemplate` field represents the template for the embed message. It is of type `APIEmbed`.
     * It is initialized with a new `EmbedBuilder` instance converted to JSON.
     */
    private embedTemplate;
    /**
     * The `totalPages` field represents the total number of pages in the paginated message. It is of type `number`.
     * It is initialized to 0.
     */
    private totalPages;
    /**
     * The array of embed fields in the PaginatedMessageEmbedFields class.
     */
    private items;
    /**
     * The `itemsPerPage` field represents the number of items to be displayed per page. It is of type `number`.
     * It is initialized to 10.
     */
    private itemsPerPage;
    /**
     * Set the items to paginate.
     * @param items The pages to set
     */
    setItems(items: EmbedField[]): this;
    /**
     * Sets the amount of items that should be shown per page.
     * @param itemsPerPage The number of items
     */
    setItemsPerPage(itemsPerPage: number): this;
    /**
     * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.
     * All fields in the given template will be overwritten when calling {@link PaginatedMessageEmbedFields.make}.
     *
     * @param template MessageEmbed
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     * import { EmbedBuilder } from 'discord.js';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setTemplate(new EmbedBuilder().setColor('#006080').setTitle('Test pager embed'))
     * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
     * 	.make()
     * 	.run(message);
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setTemplate({ title: 'Test pager embed', color: '#006080' })
     * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
     * 	.make()
     * 	.run(message);
     * ```
     */
    setTemplate(template: EmbedResolvable | ((embed: EmbedBuilder) => EmbedResolvable)): this;
    /**
     * Build the pages of the given array.
     *
     * You must call the [[PaginatedMessageEmbedFields.make]] and [[PaginatedMessageEmbedFields.run]] methods last, in that order, for the pagination to work.
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setItems([
     * 		{ name: 'Sapphire Framework', value: 'discord.js Framework' },
     * 		{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     * 		{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     * 	])
     * 	.setItemsPerPage(3)
     * 	.make()
     * 	.run(message);
     * ```
     */
    make(): this;
    /**
     * Generates the pages for the paginated message.
     * It clones the embed template, sets the fields, color, and adds the data to each page.
     */
    private generatePages;
    /**
     * Paginates an array of EmbedFields.
     *
     * @param items - The array of EmbedFields to paginate.
     * @param currentPage - The current page number.
     * @param perPageItems - The number of items per page.
     * @returns The paginated array of EmbedFields.
     */
    private paginateArray;
    /**
     * Resolves the template for the PaginatedMessageEmbedFields.
     *
     * @param template - The template to resolve. It can be an EmbedResolvable, EmbedData, or a function that takes an EmbedBuilder and returns an EmbedResolvable.
     * @returns The resolved APIEmbed object.
     */
    private resolveTemplate;
}

/**
 * Checks if a PaginatedMessageAction is a button or menu.
 * @param action The PaginatedMessageAction to check.
 * @returns `true` if the action is a button or menu, `false` otherwise.
 */
declare function actionIsButtonOrMenu(action: PaginatedMessageAction): action is Exclude<PaginatedMessageAction, PaginatedMessageActionLink>;
/**
 * Checks if a PaginatedMessageAction is a button with {@link ButtonStyle.Link style `link`}.
 * @param action The PaginatedMessageAction to check.
 * @returns `true` if the action is a button with {@link ButtonStyle.Link style `link`}, `false` otherwise.
 */
declare function actionIsLinkButton(action: PaginatedMessageAction): action is PaginatedMessageActionLink;
/**
 * Checks if the given interaction is a button interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a button interaction, false otherwise.
 */
declare function isMessageButtonInteractionData(interaction: ActionRowComponentOptions): interaction is ButtonComponentData;
/**
 * Checks if the given interaction is a string select interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a string select interaction, false otherwise.
 */
declare function isMessageStringSelectInteractionData(interaction: ActionRowComponentOptions): interaction is StringSelectMenuComponentData;
/**
 * Checks if the given interaction is a user select interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a user select interaction, false otherwise.
 */
declare function isMessageUserSelectInteractionData(interaction: ActionRowComponentOptions): interaction is UserSelectMenuComponentData;
/**
 * Checks if the given interaction is a role select interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a role select interaction, false otherwise.
 */
declare function isMessageRoleSelectInteractionData(interaction: ActionRowComponentOptions): interaction is RoleSelectMenuComponentData;
/**
 * Checks if the given interaction is a mentionable select interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a mentionable select interaction, false otherwise.
 */
declare function isMessageMentionableSelectInteractionData(interaction: ActionRowComponentOptions): interaction is MentionableSelectMenuComponentData;
/**
 * Checks if the given interaction is a channel select interaction.
 * @param interaction - The interaction to check.
 * @returns True if the interaction is a channel select interaction, false otherwise.
 */
declare function isMessageChannelSelectInteractionData(interaction: ActionRowComponentOptions): interaction is ChannelSelectMenuComponentData;
/**
 * Checks if the given component is a button builder.
 * @param component - The component to check.
 * @returns True if the component is a button builder, false otherwise.
 */
declare function isButtonComponentBuilder(component: MessageActionRowComponentBuilder): component is ButtonBuilder;
/**
 * Checks if the given action is a paginated message action button.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action button, false otherwise.
 */
declare function isActionButton(action: PaginatedMessageAction): action is PaginatedMessageActionButton;
/**
 * Checks if the given action is a paginated message action link.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action link, false otherwise.
 */
declare function isActionLink(action: PaginatedMessageAction): action is PaginatedMessageActionLink;
/**
 * Checks if the given action is a paginated message action string menu.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action string menu, false otherwise.
 */
declare function isActionStringMenu(action: PaginatedMessageAction): action is PaginatedMessageActionStringMenu;
/**
 * Checks if the given action is a paginated message action user menu.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action user menu, false otherwise.
 */
declare function isActionUserMenu(action: PaginatedMessageAction): action is PaginatedMessageActionUserMenu;
/**
 * Checks if the given action is a paginated message action role menu.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action role menu, false otherwise.
 */
declare function isActionRoleMenu(action: PaginatedMessageAction): action is PaginatedMessageActionRoleMenu;
/**
 * Checks if the given action is a paginated message action mentionable menu.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action mentionable menu, false otherwise.
 */
declare function isActionMentionableMenu(action: PaginatedMessageAction): action is PaginatedMessageActionMentionableMenu;
/**
 * Checks if the given action is a paginated message action channel menu.
 * @param action - The action to check.
 * @returns True if the action is a paginated message action channel menu, false otherwise.
 */
declare function isActionChannelMenu(action: PaginatedMessageAction): action is PaginatedMessageActionChannelMenu;
/**
 * Creates partitioned message rows based on the provided components.
 * @param components The array of MessageActionRowComponentBuilder objects.
 * @returns An array of `APIActionRowComponent<APIMessageActionRowComponent>` objects.
 */
declare function createPartitionedMessageRow(components: MessageActionRowComponentBuilder[]): PaginatedMessageComponentUnion[];
/**
 * Safely replies to a message or interaction. This is primarily to save duplicated code in the main `PaginatedMessage` class
 * @param parameters The parameters to create a safe reply to interaction parameters
 */
declare function safelyReplyToInteraction<T extends 'edit' | 'reply'>(parameters: SafeReplyToInteractionParameters<T>): Promise<void>;

/**
 * Checks whether a given channel is a {@link CategoryChannel}
 * This checks for {@link ChannelType.GuildCategory}.
 * @param channel The channel to check
 */
declare function isCategoryChannel(channel: ChannelTypes | Nullish): channel is CategoryChannel;
/**
 * Checks whether a given channel is a {@link DMChannel}
 * This checks for {@link ChannelType.DM}.
 * @param channel The channel to check
 */
declare function isDMChannel(channel: ChannelTypes | Nullish): channel is DMChannel | PartialDMChannel;
/**
 * Checks whether a given channel is a {@link PartialGroupDMChannel}
 * This checks for {@link ChannelType.GroupDM}.
 * @param channel The channel to check
 */
declare function isGroupChannel(channel: Channel | PartialDMChannel | Nullish): channel is PartialGroupDMChannel;
/**
 * Checks if a channel comes from a guild.
 * This checks that the channel is **not** {@link ChannelType.DM}.
 * @param channel The channel to check
 * @returns Whether or not the channel is guild-based.
 */
declare function isGuildBasedChannel(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes;
/**
 * Checks whether or not a channel comes from a guild.
 * @remark As opposed to {@link isGuildBasedChannel} this checks if there is `guild` property on the channel.
 * @param channel The channel to check.
 * @returns Whether or not the channel is guild-based.
 */
declare function isGuildBasedChannelByGuildKey(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes;
/**
 * Checks whether a given channel is a {@link NewsChannel}.
 * This checks for {@link ChannelType.GuildAnnouncement}.
 * @param channel The channel to check.
 */
declare function isNewsChannel(channel: ChannelTypes | Nullish): channel is NewsChannel;
/**
 * Checks whether a given channel is a {@link TextChannel}.
 * This checks for {@link ChannelType.GuildText}.
 * @param channel The channel to check.
 */
declare function isTextChannel(channel: ChannelTypes | Nullish): channel is TextChannel;
/**
 * Checks whether a given channel is a {@link VoiceChannel}
 * This checks for {@link ChannelType.GuildVoice}.
 * @param channel The channel to check
 */
declare function isVoiceChannel(channel: ChannelTypes | Nullish): channel is VoiceChannel;
/**
 * Checks whether a given channel is a {@link StageChannel}
 * This checks for {@link ChannelType.GuildStageVoice}.
 * @param channel The channel to check
 */
declare function isStageChannel(channel: ChannelTypes | Nullish): channel is StageChannel;
/**
 * Checks whether a given channel is a {@link ThreadChannel}
 * This checks for {@link ChannelTypes.isThread()}.
 * @param channel The channel to check.
 */
declare function isThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel;
/**
 * Checks whether a given channel is an Announcement {@link PublicThreadChannel}
 * This checks for {@link ChannelType.AnnouncementThread}.
 * @param channel The channel to check.
 */
declare function isNewsThreadChannel(channel: ChannelTypes | Nullish): channel is PublicThreadChannel;
/**
 * Checks whether a given channel is a {@link PublicThreadChannel}
 * This checks for {@link ChannelType.PublicThread}.
 * @param channel The channel to check.
 */
declare function isPublicThreadChannel(channel: ChannelTypes | Nullish): channel is PublicThreadChannel;
/**
 * Checks whether a given channel is a {@link PrivateThreadChannel}
 * This checks for {@link ChannelType.PrivateThread}.
 * @param channel The channel to check.
 */
declare function isPrivateThreadChannel(channel: ChannelTypes | Nullish): channel is PrivateThreadChannel;
/**
 * Checks whether a given channel is a {@link TextBasedChannelTypes}. This means it has a `send` method.
 * @param channel The channel to check.
 */
declare function isTextBasedChannel(channel: ChannelTypes | Nullish): channel is TextBasedChannelTypes;
/**
 * Checks whether a given channel is a {@link VoiceBasedChannel}.
 * This checks for {@link Channel.isVoiceBased()}.
 * @param channel: The channel to check.
 */
declare function isVoiceBasedChannel(channel: Channel | Nullish): channel is VoiceBasedChannel;
/**
 * Checks whether a given channel allows NSFW content or not
 *
 * For the following channel types this is always false:
 * - {@link ChannelType.DM}
 * - {@link ChannelType.GroupDM}
 * - {@link ChannelType.GuildCategory}
 * - {@link ChannelType.GuildStageVoice}
 * - {@link ChannelType.GuildVoice}
 * - {@link ChannelType.GuildDirectory}
 *
 * For the following channel types the actual channel is checked:
 * - {@link ChannelType.GuildAnnouncement}
 * - {@link ChannelType.GuildText}
 * - {@link ChannelType.GuildForum}
 *
 * For the following channel types the parent of the channel is checked:
 * - {@link ChannelType.AnnouncementThread}
 * - {@link ChannelType.PrivateThread}
 * - {@link ChannelType.PublicThread}
 * - {@link ChannelType.MediaChannel}
 * @param channel The channel to check.
 */
declare function isNsfwChannel(channel: ChannelTypes | Nullish): boolean;
/**
 * Checks whether a given message is an instance of {@link Message}, and not {@link APIMessage}
 * @param message The message to check
 * @returns `true` if the message is an instance of `Message`, false otherwise.
 */
declare function isMessageInstance(message: APIMessage | Message): message is Message;
/**
 * Checks whether the input `messageOrInteraction` is one of {@link Message} or any class that
 * extends {@link BaseInteraction}. This generally boils down to being one of:
 * - {@link Interaction}
 * - {@link AutocompleteInteraction}
 * - {@link ButtonInteraction}
 * - {@link ChannelSelectMenuInteraction}
 * - {@link ChatInputCommandInteraction}
 * - {@link CommandInteraction}
 * - {@link ContextMenuInteraction}
 * - {@link MentionableSelectMenuInteraction}
 * - {@link MessageComponentInteraction}
 * - {@link MessageContextMenuCommandInteraction}
 * - {@link ModalSubmitInteraction}
 * - {@link RoleSelectMenuInteraction}
 * - {@link SelectMenuInteraction}
 * - {@link StringSelectMenuInteraction}
 * - {@link UserContextMenuCommandInteraction}
 * - {@link UserSelectMenuInteraction}
 *
 * @param messageOrInteraction The message or interaction that should be checked.
 * @returns `true` if the `messageOrInteraction` is an instanceof {@link BaseInteraction}, `false` if it is not.
 */
declare function isAnyInteraction(messageOrInteraction: APIMessage | Message | BaseInteraction): messageOrInteraction is BaseInteraction;
/**
 * Checks whether the input `messageOrInteraction` is one of {@link Message} or any class that extends {@link BaseInteraction}
 * As opposed to {@link isAnyInteraction} this also checks that the interaction can actually be interacted with by the user
 * which means that this **cannot** be an {@link AutocompleteInteraction}.
 * That said, this type guard filters the `messageOrInteraction` down to one of:
 * - {@link Interaction}
 * - {@link ButtonInteraction}
 * - {@link ChannelSelectMenuInteraction}
 * - {@link ChatInputCommandInteraction}
 * - {@link CommandInteraction}
 * - {@link ContextMenuInteraction}
 * - {@link MentionableSelectMenuInteraction}
 * - {@link MessageComponentInteraction}
 * - {@link MessageContextMenuCommandInteraction}
 * - {@link ModalSubmitInteraction}
 * - {@link RoleSelectMenuInteraction}
 * - {@link SelectMenuInteraction}
 * - {@link StringSelectMenuInteraction}
 * - {@link UserContextMenuCommandInteraction}
 * - {@link UserSelectMenuInteraction}
 *
 * @param messageOrInteraction The message or interaction that should be checked.
 * @returns `true` if the `messageOrInteraction` is an instanceof {@link BaseInteraction} and does **NOT** pass
 * {@link Interaction.isAutocomplete()}, `false` otherwise.
 */
declare function isAnyInteractableInteraction(messageOrInteraction: APIMessage | Message | BaseInteraction): messageOrInteraction is AnyInteractableInteraction;
/**
 * Checks whether a given member is an instance of {@link GuildMember}, and not {@link APIInteractionGuildMember}, {@link APIGuildMember}, or {@link Nullish}
 * @param member The member to check
 * @returns `true` if the member is an instance of `GuildMember`, false otherwise.
 */
declare function isGuildMember(member: GuildMember | APIGuildMember | APIInteractionGuildMember | APIInteractionDataResolvedGuildMember | Nullish): member is GuildMember;

/**
 * Determines whether or not we can read messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can read messages in the specified channel.
 */
declare function canReadMessages(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send messages in the specified channel.
 */
declare function canSendMessages(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send embeds in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send embeds in the specified channel.
 */
declare function canSendEmbeds(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send attachments in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send attachments in the specified channel.
 */
declare function canSendAttachments(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send react to messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can react to messages in the specified channel.
 */
declare function canReact(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can remove reactions from messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can remove reactions from messages in the specified channel.
 */
declare function canRemoveAllReactions(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether the client can join the given voice based channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not the client can join the specified channel.
 */
declare function canJoinVoiceChannel(channel: VoiceBasedChannel | Nullish): boolean;

export { type AnyInteractableInteraction, type AnyInteraction, type ChannelTypeString, type ChannelTypes, type ChatInputOrContextMenuCommandInteraction, type EmbedResolvable, type GuildBasedChannelTypes, type GuildTextBasedChannelTypes, type IMessagePrompterConfirmStrategyOptions, type IMessagePrompterExplicitConfirmReturn, type IMessagePrompterExplicitMessageReturn, type IMessagePrompterExplicitNumberReturn, type IMessagePrompterExplicitReturnBase, type IMessagePrompterNumberStrategyOptions, type IMessagePrompterReactionStrategyOptions, type IMessagePrompterStrategyOptions, LazyPaginatedMessage, MessageBuilder, type MessageBuilderFileResolvable, type MessageBuilderResolvable, MessagePrompter, MessagePrompterBaseStrategy, type MessagePrompterChannelTypes, MessagePrompterConfirmStrategy, type MessagePrompterMessage, MessagePrompterMessageStrategy, MessagePrompterNumberStrategy, MessagePrompterReactionStrategy, type NonModalInteraction, type NonThreadGuildBasedChannelTypes, type NonThreadGuildTextBasedChannelTypes, PaginatedFieldMessageEmbed, PaginatedMessage, type PaginatedMessageAction, type PaginatedMessageActionButton, type PaginatedMessageActionChannelMenu, type PaginatedMessageActionContext, type PaginatedMessageActionLink, type PaginatedMessageActionMentionableMenu, type PaginatedMessageActionRoleMenu, type PaginatedMessageActionRun, type PaginatedMessageActionStringMenu, type PaginatedMessageActionUserMenu, type PaginatedMessageComponentUnion, PaginatedMessageEmbedFields, type PaginatedMessageEmbedResolvable, type PaginatedMessageInteractionUnion, type PaginatedMessageInternationalizationContext, type PaginatedMessageMessageOptionsUnion, type PaginatedMessageOptions, type PaginatedMessagePage, type PaginatedMessageResolvedPage, type PaginatedMessageSelectMenuOptionsFunction, type PaginatedMessageStopReasons, type PaginatedMessageWrongUserInteractionReplyFunction, type SafeReplyToInteractionParameters, type StrategyFilters, type StrategyOptions, type StrategyReturns, type TextBasedChannelTypes, type VoiceBasedChannelTypes, actionIsButtonOrMenu, actionIsLinkButton, canJoinVoiceChannel, canReact, canReadMessages, canRemoveAllReactions, canSendAttachments, canSendEmbeds, canSendMessages, createPartitionedMessageRow, isActionButton, isActionChannelMenu, isActionLink, isActionMentionableMenu, isActionRoleMenu, isActionStringMenu, isActionUserMenu, isAnyInteractableInteraction, isAnyInteraction, isButtonComponentBuilder, isCategoryChannel, isDMChannel, isGroupChannel, isGuildBasedChannel, isGuildBasedChannelByGuildKey, isGuildMember, isMessageButtonInteractionData, isMessageChannelSelectInteractionData, isMessageInstance, isMessageMentionableSelectInteractionData, isMessageRoleSelectInteractionData, isMessageStringSelectInteractionData, isMessageUserSelectInteractionData, isNewsChannel, isNewsThreadChannel, isNsfwChannel, isPrivateThreadChannel, isPublicThreadChannel, isStageChannel, isTextBasedChannel, isTextChannel, isThreadChannel, isVoiceBasedChannel, isVoiceChannel, safelyReplyToInteraction };
