import { EmbedLimits } from '@sapphire/discord-utilities';
export * from '@sapphire/discord-utilities';
import { isNullish, partition, chunk, isFunction, deepClone, isObject, isNullishOrEmpty } from '@sapphire/utilities';
import { ComponentType, ButtonStyle, PermissionsBitField, PermissionFlagsBits, ChannelType, Message, BaseInteraction, GuildMember, ActionRowBuilder, isJSONEncodable, EmbedBuilder, Partials, IntentsBitField, GatewayIntentBits, InteractionCollector, InteractionType, ButtonBuilder, UserSelectMenuBuilder, RoleSelectMenuBuilder, MentionableSelectMenuBuilder, ChannelSelectMenuBuilder, StringSelectMenuBuilder, userMention } from 'discord.js';
import { Time } from '@sapphire/duration';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
function isCategoryChannel(channel) {
  return channel?.type === ChannelType.GuildCategory;
}
__name(isCategoryChannel, "isCategoryChannel");
function isDMChannel(channel) {
  return channel?.type === ChannelType.DM;
}
__name(isDMChannel, "isDMChannel");
function isGroupChannel(channel) {
  return channel?.type === ChannelType.GroupDM;
}
__name(isGroupChannel, "isGroupChannel");
function isGuildBasedChannel(channel) {
  return channel?.type !== ChannelType.DM;
}
__name(isGuildBasedChannel, "isGuildBasedChannel");
function isGuildBasedChannelByGuildKey(channel) {
  return Reflect.has(channel ?? {}, "guild");
}
__name(isGuildBasedChannelByGuildKey, "isGuildBasedChannelByGuildKey");
function isNewsChannel(channel) {
  return channel?.type === ChannelType.GuildAnnouncement;
}
__name(isNewsChannel, "isNewsChannel");
function isTextChannel(channel) {
  return channel?.type === ChannelType.GuildText;
}
__name(isTextChannel, "isTextChannel");
function isVoiceChannel(channel) {
  return channel?.type === ChannelType.GuildVoice;
}
__name(isVoiceChannel, "isVoiceChannel");
function isStageChannel(channel) {
  return channel?.type === ChannelType.GuildStageVoice;
}
__name(isStageChannel, "isStageChannel");
function isThreadChannel(channel) {
  return channel?.isThread() ?? false;
}
__name(isThreadChannel, "isThreadChannel");
function isNewsThreadChannel(channel) {
  return channel?.type === ChannelType.AnnouncementThread;
}
__name(isNewsThreadChannel, "isNewsThreadChannel");
function isPublicThreadChannel(channel) {
  return channel?.type === ChannelType.PublicThread;
}
__name(isPublicThreadChannel, "isPublicThreadChannel");
function isPrivateThreadChannel(channel) {
  return channel?.type === ChannelType.PrivateThread;
}
__name(isPrivateThreadChannel, "isPrivateThreadChannel");
function isTextBasedChannel(channel) {
  if (isNullish(channel) || isStageChannel(channel))
    return false;
  return !isNullish(channel.send);
}
__name(isTextBasedChannel, "isTextBasedChannel");
function isVoiceBasedChannel(channel) {
  if (isNullish(channel))
    return false;
  return channel.isVoiceBased();
}
__name(isVoiceBasedChannel, "isVoiceBasedChannel");
function isNsfwChannel(channel) {
  if (isNullish(channel))
    return false;
  switch (channel.type) {
    case ChannelType.DM:
    case ChannelType.GroupDM:
    case ChannelType.GuildCategory:
    case ChannelType.GuildStageVoice:
    case ChannelType.GuildVoice:
    case ChannelType.GuildDirectory:
      return false;
    case ChannelType.GuildAnnouncement:
    case ChannelType.GuildText:
    case ChannelType.GuildForum:
    case ChannelType.GuildMedia:
      return channel.nsfw;
    case ChannelType.AnnouncementThread:
    case ChannelType.PrivateThread:
    case ChannelType.PublicThread:
      return Boolean(channel.parent?.nsfw);
  }
}
__name(isNsfwChannel, "isNsfwChannel");
function isMessageInstance(message) {
  return message instanceof Message;
}
__name(isMessageInstance, "isMessageInstance");
function isAnyInteraction(messageOrInteraction) {
  return messageOrInteraction instanceof BaseInteraction;
}
__name(isAnyInteraction, "isAnyInteraction");
function isAnyInteractableInteraction(messageOrInteraction) {
  if (isAnyInteraction(messageOrInteraction)) {
    return !messageOrInteraction.isAutocomplete();
  }
  return false;
}
__name(isAnyInteractableInteraction, "isAnyInteractableInteraction");
function isGuildMember(member) {
  return member instanceof GuildMember;
}
__name(isGuildMember, "isGuildMember");

// src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts
var _MessagePrompterBaseStrategy = class _MessagePrompterBaseStrategy {
  /**
   * Constructor for the {@link MessagePrompterBaseStrategy} class
   * @param messagePrompter The used instance of {@link MessagePrompter}
   * @param options Overrideable options if needed.
   */
  constructor(type, message, options) {
    /**
     * The type of strategy that was used
     */
    __publicField(this, "type");
    /**
     * The timeout that was used in the collector
     */
    __publicField(this, "timeout");
    /**
     * Whether to return an explicit object with data, or the strategies' default
     */
    __publicField(this, "explicitReturn");
    /**
     * The message that has been sent in {@link MessagePrompter.run}
     */
    __publicField(this, "appliedMessage", null);
    /**
     * The message that will be sent in {@link MessagePrompter.run}
     */
    __publicField(this, "message");
    /**
     * The message the bot will edit to send its prompt in {@link MessagePrompter.run}
     */
    __publicField(this, "editMessage");
    this.type = type;
    this.timeout = options?.timeout ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1e3;
    this.explicitReturn = options?.explicitReturn ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;
    this.editMessage = options?.editMessage ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? void 0;
    this.message = message;
  }
  async collectReactions(channel, authorOrFilter, reactions) {
    if (isTextBasedChannel(channel) && !isStageChannel(channel)) {
      if (!isNullish(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = this.appliedMessage.createReactionCollector({
        ...this.createReactionPromptFilter(reactions, authorOrFilter),
        max: 1,
        time: this.timeout
      });
      let resolved = false;
      const collected = new Promise((resolve, reject) => {
        collector.on("collect", (r) => {
          resolve(r);
          resolved = true;
          collector.stop();
        });
        collector.on("end", (collected2) => {
          resolved = true;
          if (!collected2.size)
            reject(new Error("Collector has ended"));
        });
      });
      for (const reaction2 of reactions) {
        if (resolved)
          break;
        await this.appliedMessage.react(reaction2);
      }
      const firstReaction = await collected;
      const emoji = firstReaction?.emoji;
      const reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);
      return {
        emoji,
        reaction,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      };
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  /**
   * Creates a filter for the collector to filter on
   * @return The filter for awaitReactions function
   */
  createReactionPromptFilter(reactions, authorOrFilter) {
    return {
      filter: async (reaction, user) => reactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? "") && (typeof authorOrFilter === "function" ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) && !user.bot
    };
  }
};
__name(_MessagePrompterBaseStrategy, "MessagePrompterBaseStrategy");
/**
 * The default strategy options
 */
__publicField(_MessagePrompterBaseStrategy, "defaultStrategyOptions", {
  timeout: 10 * 1e3,
  explicitReturn: false,
  editMessage: void 0
});
var MessagePrompterBaseStrategy = _MessagePrompterBaseStrategy;

// src/lib/MessagePrompter/strategies/MessagePrompterConfirmStrategy.ts
var _MessagePrompterConfirmStrategy = class _MessagePrompterConfirmStrategy extends MessagePrompterBaseStrategy {
  /**
   * Constructor for the {@link MessagePrompterBaseStrategy} class
   * @param message The message to be sent {@link MessagePrompter}
   * @param options Overrideable options if needed.
   */
  constructor(message, options) {
    super("confirm", message, options);
    /**
     * The confirm emoji used
     */
    __publicField(this, "confirmEmoji");
    /**
     * The cancel emoji used
     */
    __publicField(this, "cancelEmoji");
    this.confirmEmoji = options?.confirmEmoji ?? _MessagePrompterConfirmStrategy.confirmEmoji;
    this.cancelEmoji = options?.cancelEmoji ?? _MessagePrompterConfirmStrategy.cancelEmoji;
  }
  /**
   * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals confirm.
   * The handler will wait for one (1) reaction.
   * @param channel The channel to use.
   * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
   * @returns A promise that resolves to a boolean denoting the value of the input (`true` for yes, `false` for no).
   */
  async run(channel, authorOrFilter) {
    const response = await this.collectReactions(channel, authorOrFilter, [this.confirmEmoji, this.cancelEmoji]);
    const confirmed = (response?.emoji?.id ?? response?.emoji?.name) === this.confirmEmoji;
    return this.explicitReturn ? { ...response, confirmed } : confirmed;
  }
};
__name(_MessagePrompterConfirmStrategy, "MessagePrompterConfirmStrategy");
/**
 * The default confirm emoji used for {@link MessagePrompterConfirmStrategy}
 */
__publicField(_MessagePrompterConfirmStrategy, "confirmEmoji", "\u{1F1FE}");
/**
 * The default cancel emoji used for {@link MessagePrompterConfirmStrategy}
 */
__publicField(_MessagePrompterConfirmStrategy, "cancelEmoji", "\u{1F1F3}");
var MessagePrompterConfirmStrategy = _MessagePrompterConfirmStrategy;
var _MessagePrompterMessageStrategy = class _MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy {
  /**
   * Constructor for the {@link MessagePrompterBaseStrategy} class
   * @param messagePrompter The used instance of {@link MessagePrompter}
   * @param options Overrideable options if needed.
   */
  constructor(message, options) {
    super("message", message, options);
  }
  /**
   * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.
   * The handler will wait for one (1) message.
   * @param channel The channel to use.
   * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
   * @returns A promise that resolves to the message object received.
   */
  async run(channel, authorOrFilter) {
    if (isTextBasedChannel(channel) && !isStageChannel(channel)) {
      if (!isNullish(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = await channel.awaitMessages({
        ...this.createMessagePromptFilter(authorOrFilter),
        max: 1,
        time: this.timeout,
        errors: ["time"]
      });
      const response = collector.first();
      if (!response) {
        throw new Error("No messages received");
      }
      return this.explicitReturn ? {
        response,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      } : response;
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  /**
   * Creates a filter for the collector to filter on
   * @return The filter for awaitMessages function
   */
  createMessagePromptFilter(authorOrFilter) {
    return {
      filter: async (message) => (typeof authorOrFilter === "function" ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) && !message.author.bot
    };
  }
};
__name(_MessagePrompterMessageStrategy, "MessagePrompterMessageStrategy");
var MessagePrompterMessageStrategy = _MessagePrompterMessageStrategy;

// src/lib/MessagePrompter/strategies/MessagePrompterNumberStrategy.ts
var _MessagePrompterNumberStrategy = class _MessagePrompterNumberStrategy extends MessagePrompterBaseStrategy {
  /**
   * Constructor for the {@link MessagePrompterBaseStrategy} class
   * @param messagePrompter The used instance of {@link MessagePrompter}
   * @param options Overrideable options if needed.
   */
  constructor(message, options) {
    super("number", message, options);
    /**
     * The available number emojis
     */
    __publicField(this, "numberEmojis");
    /**
     * The available number emojis
     */
    __publicField(this, "start");
    /**
     * The available number emojis
     */
    __publicField(this, "end");
    this.numberEmojis = options?.numberEmojis ?? _MessagePrompterNumberStrategy.numberEmojis;
    this.start = options?.start ?? 0;
    this.end = options?.end ?? 10;
  }
  /**
   * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals number.
   * The handler will wait for one (1) reaction.
   * @param channel The channel to use.
   * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
   * @returns A promise that resolves to the selected number within the range.
   */
  async run(channel, authorOrFilter) {
    if (this.start < 0)
      throw new TypeError("Starting number cannot be less than 0.");
    if (this.end > 10)
      throw new TypeError("Ending number cannot be more than 10.");
    const numbers = Array.from({ length: this.end - this.start + 1 }, (_, n) => n + this.start);
    const emojis = this.numberEmojis.slice(this.start, this.end);
    const response = await this.collectReactions(channel, authorOrFilter, emojis);
    const emojiIndex = emojis.findIndex((emoji) => (response?.emoji?.id ?? response?.emoji?.name) === emoji);
    const number = numbers[emojiIndex];
    return this.explicitReturn ? { ...response, number } : number;
  }
};
__name(_MessagePrompterNumberStrategy, "MessagePrompterNumberStrategy");
/**
 * The default available number emojis
 */
__publicField(_MessagePrompterNumberStrategy, "numberEmojis", ["0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\u{1F51F}"]);
var MessagePrompterNumberStrategy = _MessagePrompterNumberStrategy;

// src/lib/MessagePrompter/strategies/MessagePrompterReactionStrategy.ts
var _MessagePrompterReactionStrategy = class _MessagePrompterReactionStrategy extends MessagePrompterBaseStrategy {
  /**
   * Constructor for the {@link MessagePrompterReactionStrategy} class
   * @param messagePrompter The used instance of {@link MessagePrompter}
   * @param options Overrideable options if needed.
   */
  constructor(message, options) {
    super("reactions", message, options);
    /**
     * The emojis used
     */
    __publicField(this, "reactions");
    this.reactions = options?.reactions;
  }
  /**
   * This executes the {@link MessagePrompterReactionStrategy} and sends the message.
   * The handler will wait for one (1) reaction.
   * @param channel The channel to use.
   * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
   * @returns A promise that resolves to the reaction object.
   */
  async run(channel, authorOrFilter) {
    if (!this.reactions?.length)
      throw new TypeError("There are no reactions provided.");
    const response = await this.collectReactions(channel, authorOrFilter, this.reactions);
    return this.explicitReturn ? response : response.reaction ?? response;
  }
};
__name(_MessagePrompterReactionStrategy, "MessagePrompterReactionStrategy");
var MessagePrompterReactionStrategy = _MessagePrompterReactionStrategy;

// src/lib/MessagePrompter/MessagePrompter.ts
var _MessagePrompter = class _MessagePrompter {
  /**
   * Constructor for the {@link MessagePrompter} class
   * @param message The message to send.
   * @param strategy The strategy name or Instance to use
   * @param strategyOptions The options that are passed to the strategy
   */
  constructor(message, strategy, strategyOptions) {
    /**
     * The strategy used in {@link MessagePrompter.run}
     */
    __publicField(this, "strategy");
    let strategyToRun;
    if (message instanceof MessagePrompterBaseStrategy) {
      strategyToRun = message;
    } else {
      const mapStrategy = _MessagePrompter.strategies.get(strategy ?? _MessagePrompter.defaultStrategy);
      if (!mapStrategy) {
        throw new Error("No strategy provided");
      }
      strategyToRun = new mapStrategy(message, strategyOptions);
    }
    this.strategy = strategyToRun;
  }
  /**
   * This executes the {@link MessagePrompter} and sends the message.
   * @param channel The channel to use.
   * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/docs/packages/discord.js/main/CollectorFilter:TypeAlias CollectorFilter} predicate callback.
   */
  run(channel, authorOrFilter) {
    return this.strategy.run(channel, authorOrFilter);
  }
};
__name(_MessagePrompter, "MessagePrompter");
/**
 * The available strategies
 */
__publicField(_MessagePrompter, "strategies", /* @__PURE__ */ new Map([
  ["confirm", MessagePrompterConfirmStrategy],
  ["number", MessagePrompterNumberStrategy],
  ["reaction", MessagePrompterReactionStrategy],
  ["message", MessagePrompterMessageStrategy]
]));
/**
 * The default strategy to use
 */
__publicField(_MessagePrompter, "defaultStrategy", "confirm");
var MessagePrompter = _MessagePrompter;

// src/lib/builders/MessageBuilder.ts
var _MessageBuilder = class _MessageBuilder {
  constructor(options) {
    /**
     * Whether or not the message should be spoken aloud.
     * @default false
     */
    __publicField(this, "tts");
    /**
     * The nonce for the message.
     * @default ''
     */
    __publicField(this, "nonce");
    /**
     * The content for the message. If set to undefined and the builder is used to edit, the content will not be
     * replaced.
     */
    __publicField(this, "content");
    /**
     * The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be replaced.
     * @remark There is a maximum of 10 embeds in 1 message
     */
    __publicField(this, "embeds");
    /**
     * Which mentions should be parsed from the message content.
     */
    __publicField(this, "allowedMentions");
    /**
     * Files to send with the message. This should not be set when editing a message, as Discord does not support
     * editing file attachments.
     */
    __publicField(this, "files");
    this.tts = options?.tts ?? _MessageBuilder.defaults.tts;
    this.nonce = options?.nonce ?? _MessageBuilder.defaults.nonce;
    this.content = options?.content ?? _MessageBuilder.defaults.content;
    this.embeds = options?.embeds ?? _MessageBuilder.defaults.embeds;
    this.allowedMentions = options?.allowedMentions ?? _MessageBuilder.defaults.allowedMentions;
    this.files = options?.files ?? _MessageBuilder.defaults.files;
  }
  /**
   * Sets the value for the {@link MessageBuilder.tts} field.
   * @param tts Whether or not the message should be spoken aloud.
   */
  setTTS(tts) {
    this.tts = tts;
    return this;
  }
  /**
   * Sets the value for the {@link MessageBuilder.nonce} field.
   * @param nonce The nonce for the message.
   */
  setNonce(nonce) {
    this.nonce = nonce;
    return this;
  }
  /**
   * Sets the value for the {@link MessageBuilder.content} field.
   * @param content The content for the message. If set to undefined and the builder is used to edit, the content will
   * not be replaced.
   */
  setContent(content) {
    this.content = content;
    return this;
  }
  /**
   * Sets the value for the {@link MessageBuilder.embed} field.
   * @param embeds The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be
   * replaced. There is a maximum of 10 embeds per message
   * @remark When providing more than 10 embeds, the array will automatically be sliced down to the first 10.
   */
  setEmbeds(embeds) {
    if (embeds && embeds.length > 10) {
      embeds = embeds.slice(0, 10);
    }
    this.embeds = embeds;
    return this;
  }
  /**
   * Sets the value for the {@link MessageBuilder.allowedMentions} field.
   * @param allowedMentions Which mentions should be parsed from the message content.
   */
  setAllowedMentions(allowedMentions) {
    this.allowedMentions = allowedMentions;
    return this;
  }
  /**
   * Adds a new value for the {@link MessageBuilder.files} field array.
   * @param file The file to add to the {@link MessageBuilder.files} field array.
   */
  addFile(file) {
    this.files = this.files?.concat(file) ?? [file];
    return this;
  }
  /**
   * Sets a single value for the {@link MessageBuilder.files} field array.
   * @param file The file to send with the message. This should not be set when editing a message, as Discord does not
   * support editing file attachments.
   */
  setFile(file) {
    this.files = [file];
    return this;
  }
  /**
   * Sets the value for the {@link MessageBuilder.files} field.
   * @param files The files to send with the message. This should not be set when editing a message, as Discord does
   * not support editing file attachments.
   */
  setFiles(files) {
    this.files = files;
    return this;
  }
};
__name(_MessageBuilder, "MessageBuilder");
/**
 * The default values for all MessageBuilder instances.
 */
__publicField(_MessageBuilder, "defaults", {});
var MessageBuilder = _MessageBuilder;
function actionIsButtonOrMenu(action) {
  return action.type === ComponentType.Button || action.type === ComponentType.StringSelect || action.type === ComponentType.UserSelect || action.type === ComponentType.RoleSelect || action.type === ComponentType.MentionableSelect || action.type === ComponentType.ChannelSelect;
}
__name(actionIsButtonOrMenu, "actionIsButtonOrMenu");
function actionIsLinkButton(action) {
  return action.type === ComponentType.Button && action.style === ButtonStyle.Link;
}
__name(actionIsLinkButton, "actionIsLinkButton");
function isMessageButtonInteractionData(interaction) {
  return interaction.type === ComponentType.Button;
}
__name(isMessageButtonInteractionData, "isMessageButtonInteractionData");
function isMessageStringSelectInteractionData(interaction) {
  return interaction.type === ComponentType.StringSelect;
}
__name(isMessageStringSelectInteractionData, "isMessageStringSelectInteractionData");
function isMessageUserSelectInteractionData(interaction) {
  return interaction.type === ComponentType.UserSelect;
}
__name(isMessageUserSelectInteractionData, "isMessageUserSelectInteractionData");
function isMessageRoleSelectInteractionData(interaction) {
  return interaction.type === ComponentType.RoleSelect;
}
__name(isMessageRoleSelectInteractionData, "isMessageRoleSelectInteractionData");
function isMessageMentionableSelectInteractionData(interaction) {
  return interaction.type === ComponentType.MentionableSelect;
}
__name(isMessageMentionableSelectInteractionData, "isMessageMentionableSelectInteractionData");
function isMessageChannelSelectInteractionData(interaction) {
  return interaction.type === ComponentType.ChannelSelect;
}
__name(isMessageChannelSelectInteractionData, "isMessageChannelSelectInteractionData");
function isButtonComponentBuilder(component) {
  return component.data.type === ComponentType.Button;
}
__name(isButtonComponentBuilder, "isButtonComponentBuilder");
function isActionButton(action) {
  return action.type === ComponentType.Button && action.style !== ButtonStyle.Link;
}
__name(isActionButton, "isActionButton");
function isActionLink(action) {
  return action.type === ComponentType.Button && action.style === ButtonStyle.Link;
}
__name(isActionLink, "isActionLink");
function isActionStringMenu(action) {
  return action.type === ComponentType.StringSelect;
}
__name(isActionStringMenu, "isActionStringMenu");
function isActionUserMenu(action) {
  return action.type === ComponentType.UserSelect;
}
__name(isActionUserMenu, "isActionUserMenu");
function isActionRoleMenu(action) {
  return action.type === ComponentType.RoleSelect;
}
__name(isActionRoleMenu, "isActionRoleMenu");
function isActionMentionableMenu(action) {
  return action.type === ComponentType.MentionableSelect;
}
__name(isActionMentionableMenu, "isActionMentionableMenu");
function isActionChannelMenu(action) {
  return action.type === ComponentType.ChannelSelect;
}
__name(isActionChannelMenu, "isActionChannelMenu");
function createPartitionedMessageRow(components) {
  const [messageButtons, selectMenus] = partition(components, isButtonComponentBuilder);
  const [actionButtons, linkButtons] = partition(messageButtons, (value) => value.data.style !== ButtonStyle.Link);
  const chunkedActionButtonComponents = chunk(actionButtons, 5);
  const messageActionButtonActionRows = chunkedActionButtonComponents.map(
    (componentsChunk) => new ActionRowBuilder().setComponents(componentsChunk)
  );
  const selectMenuActionRows = selectMenus.map(
    (component) => new ActionRowBuilder().setComponents(component)
  );
  const chunkedLinkButtonComponents = chunk(linkButtons, 5);
  const messageLinkButtonActionRows = chunkedLinkButtonComponents.map(
    (componentsChunk) => new ActionRowBuilder().setComponents(componentsChunk)
  );
  return [...messageActionButtonActionRows, ...selectMenuActionRows, ...messageLinkButtonActionRows].map(
    (actionRow) => actionRow.toJSON()
  );
}
__name(createPartitionedMessageRow, "createPartitionedMessageRow");
async function safelyReplyToInteraction(parameters) {
  if (isAnyInteractableInteraction(parameters.messageOrInteraction)) {
    if (parameters.messageOrInteraction.replied || parameters.messageOrInteraction.deferred) {
      await parameters.messageOrInteraction.editReply(parameters.interactionEditReplyContent);
    } else if (parameters.messageOrInteraction.isMessageComponent()) {
      await parameters.messageOrInteraction.update(parameters.componentUpdateContent);
    } else {
      await parameters.messageOrInteraction.reply(parameters.interactionReplyContent);
    }
  } else if (parameters.messageMethodContent && parameters.messageMethod && isMessageInstance(parameters.messageOrInteraction)) {
    await parameters.messageOrInteraction[parameters.messageMethod](parameters.messageMethodContent);
  }
}
__name(safelyReplyToInteraction, "safelyReplyToInteraction");

// src/lib/PaginatedMessages/PaginatedMessage.ts
var _thisMazeWasNotMeantForYouContent;
var _PaginatedMessage = class _PaginatedMessage {
  // #endregion
  /**
   * Constructor for the {@link PaginatedMessage} class
   * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
   */
  constructor({
    pages,
    actions,
    template,
    pageIndexPrefix,
    embedFooterSeparator,
    paginatedMessageData = null
  } = {}) {
    // #endregion
    // #region public class properties
    /**
     * The pages to be converted to {@link PaginatedMessage.messages}
     */
    __publicField(this, "pages", []);
    /**
     * The response message used to edit on page changes.
     */
    __publicField(this, "response", null);
    /**
     * The collector used for handling component interactions.
     */
    __publicField(this, "collector", null);
    /**
     * The pages which were converted from {@link PaginatedMessage.pages}
     */
    __publicField(this, "messages", []);
    /**
     * The actions which are to be used.
     */
    __publicField(this, "actions", /* @__PURE__ */ new Map());
    /**
     * The page-specific actions which are to be used.
     */
    __publicField(this, "pageActions", []);
    /**
     * The handler's current page/message index.
     */
    __publicField(this, "index", 0);
    /**
     * The amount of milliseconds to idle before the paginator is closed.
     * @default 14.5 minutes
     * @remark This is to ensure it is a bit before interactions expire.
     */
    __publicField(this, "idle", Time.Minute * 14.5);
    /**
     * The template for this {@link PaginatedMessage}.
     * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
     */
    __publicField(this, "template");
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
     */
    __publicField(this, "pageIndexPrefix", _PaginatedMessage.pageIndexPrefix);
    /**
     * Custom separator to show after the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.embedFooterSeparator``` (static property)
     */
    __publicField(this, "embedFooterSeparator", _PaginatedMessage.embedFooterSeparator);
    /**
     * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
     * @default ```PaginatedMessage.stopPaginatedMessageCustomIds``` (static property)
     */
    __publicField(this, "stopPaginatedMessageCustomIds", _PaginatedMessage.stopPaginatedMessageCustomIds);
    /**
     * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client having the `'CHANNEL'` partial.
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     *
     * @default ```PaginatedMessage.emitPartialDMChannelWarning``` (static property)
     */
    __publicField(this, "emitPartialDMChannelWarning", _PaginatedMessage.emitPartialDMChannelWarning);
    // #endregion
    // #region protected class properties
    /**
     * Data for the paginated message.
     */
    __publicField(this, "paginatedMessageData", null);
    /**
     * The placeholder for the select menu.
     */
    __publicField(this, "selectMenuPlaceholder");
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the maximum amount of pages in the {@link SelectMenu}.
     *
     * @default false
     */
    __publicField(this, "hasEmittedMaxPageWarning", false);
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the {@link PaginatedMessage} being called in a `DMChannel`
     * without the client having the `'Channel'` partial.
     *
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     * @default false
     */
    __publicField(this, "hasEmittedPartialDMChannelWarning", false);
    /**
     * Determines whether the default footer that shows the current page number should be added to the embeds.
     *
     * @note If this is set to false, i.e.e through {@link setShouldAddFooterToEmbeds}, then {@link embedFooterSeparator}
     * is never applied.
     *
     * @default true
     */
    __publicField(this, "shouldAddFooterToEmbeds", true);
    /**
     * Function that returns the select menu options for the paginated message.
     * @param message The paginated message.
     * @returns The select menu options.
     */
    __publicField(this, "selectMenuOptions", _PaginatedMessage.selectMenuOptions);
    /**
     * Function that handles the reply when a user interacts with the paginated message incorrectly.
     */
    __publicField(this, "wrongUserInteractionReply", _PaginatedMessage.wrongUserInteractionReply);
    // #endregion
    // #region private class fields
    /** The response we send when someone gets into an invalid flow */
    __privateAdd(this, _thisMazeWasNotMeantForYouContent, { content: "This maze wasn't meant for you...what did you do." });
    if (pages)
      this.addPages(pages);
    this.addActions(actions ?? this.constructor.defaultActions);
    this.template = _PaginatedMessage.resolveTemplate(template);
    this.pageIndexPrefix = pageIndexPrefix ?? _PaginatedMessage.pageIndexPrefix;
    this.embedFooterSeparator = embedFooterSeparator ?? _PaginatedMessage.embedFooterSeparator;
    this.paginatedMessageData = paginatedMessageData;
  }
  // #endregion
  // #region private static class properties
  /**
   * Resolves the template for the PaginatedMessage.
   *
   * @param template - The template to resolve.
   * @returns The resolved template as a BaseMessageOptions object.
   */
  static resolveTemplate(template) {
    if (template === void 0) {
      return {};
    }
    if (isJSONEncodable(template)) {
      return { embeds: [template.toJSON()] };
    }
    return template;
  }
  // #region property setters
  /**
   * Sets the {@link PaginatedMessage.selectMenuOptions} for this instance of {@link PaginatedMessage}.
   * This will only apply to this one instance and no others.
   * @param newOptions The new options generator to set
   * @returns The current instance of {@link PaginatedMessage}
   */
  setSelectMenuOptions(newOptions) {
    this.selectMenuOptions = newOptions;
    return this;
  }
  /**
   * Sets the {@link PaginatedMessage.selectMenuPlaceholder} for this instance of {@link PaginatedMessage}.
   *
   * This applies only to the string select menu from the {@link PaginatedMessage.defaultActions}
   * that offers "go to page" (we internally check the customId for this)
   *
   * This will only apply to this one instance and no others.
   * @param placeholder The new placeholder to set
   * @returns The current instance of {@link PaginatedMessage}
   */
  setSelectMenuPlaceholder(placeholder) {
    this.selectMenuPlaceholder = placeholder;
    return this;
  }
  /**
   * Sets the {@link PaginatedMessage.wrongUserInteractionReply} for this instance of {@link PaginatedMessage}.
   * This will only apply to this one instance and no others.
   * @param wrongUserInteractionReply The new `wrongUserInteractionReply` to set
   * @returns The current instance of {@link PaginatedMessage}
   */
  setWrongUserInteractionReply(wrongUserInteractionReply) {
    this.wrongUserInteractionReply = wrongUserInteractionReply;
    return this;
  }
  /**
   * Sets the {@link PaginatedMessage.stopPaginatedMessageCustomIds} for this instance of {@link PaginatedMessage}.
   * This will only apply to this one instance and no others.
   * @param stopPaginatedMessageCustomIds The new `stopPaginatedMessageCustomIds` to set
   * @returns The current instance of {@link PaginatedMessage}
   */
  setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds) {
    this.stopPaginatedMessageCustomIds = stopPaginatedMessageCustomIds;
    return this;
  }
  /**
   * Sets the {@link PaginatedMessage.emitPartialDMChannelWarning} for this instance of {@link PaginatedMessage}.
   * This will only apply to this one instance and no others.
   * @param emitPartialDMChannelWarning The new `emitPartialDMChannelWarning` to set
   * @returns The current instance of {@link PaginatedMessage}
   */
  setEmitPartialDMChannelWarning(emitPartialDMChannelWarning) {
    this.emitPartialDMChannelWarning = emitPartialDMChannelWarning;
    return this;
  }
  /**
   * Sets the handler's current page/message index.
   * @param index The number to set the index to.
   */
  setIndex(index) {
    this.index = index;
    return this;
  }
  /**
   * Sets the amount of time to idle before the paginator is closed.
   * @param idle The number to set the idle to.
   */
  setIdle(idle) {
    this.idle = idle;
    return this;
  }
  /**
   * Sets the value of {@link shouldAddFooterToEmbeds} property and returns the instance of the class.
   * @param newValue - The new value for {@link shouldAddFooterToEmbeds}.
   * @returns The instance of the class with the updated {@link shouldAddFooterToEmbeds} value.
   */
  setShouldAddFooterToEmbeds(newValue) {
    this.shouldAddFooterToEmbeds = newValue;
    return this;
  }
  // #endregion
  // #region actions related methods
  /**
   * Clears all current actions and sets them. The order given is the order they will be used.
   * @param actions The actions to set. This can be either a Button, Link Button, or Select Menu.
   * @param includeDefaultActions Whether to merge in the {@link PaginatedMessage.defaultActions} when setting the actions.
   * If you set this to true then you do not need to manually add `...PaginatedMessage.defaultActions` as seen in the first example.
   * The default value is `false` for backwards compatibility within the current major version.
   *
   * @remark You can retrieve the default actions for the regular pagination
   * @example
   * ```typescript
   * const display = new PaginatedMessage();
   *
   * display.setActions([
   *   ...PaginatedMessage.defaultActions,
   * ])
   * ```
   *
   * @remark You can add custom Message Buttons by providing `style`, `customId`, `type`, `run` and at least one of `label` or `emoji`.
   * @example
   * ```typescript
   * const display = new PaginatedMessage();
   *
   * display.setActions([
   *   {
   *     style: 'PRIMARY',
   *     label: 'My Button',
   *     customId: 'custom_button',
   *     type: ComponentType.Button,
   *     run: (context) => console.log(context)
   *   }
   * ], true);
   * ```
   *
   * @remark You can add custom Message **Link** Buttons by providing `style`, `url`, `type`, and at least one of `label` or `emoji`.
   * @example
   * ```typescript
   * const display = new PaginatedMessage();
   *
   * display.setActions([
   *   {
   *     style: 'LINK',
   *     label: 'Sapphire Website',
   *     emoji: '🔷',
   *     url: 'https://sapphirejs.dev',
   *     type: ComponentType.Button
   *   }
   * ], true);
   * ```
   *
   * @remark You can add custom Select Menus by providing `customId`, `type`, and `run`.
   * @example
   * ```typescript
   * const display = new PaginatedMessage();
   *
   * display.setActions([
   *   {
   *     customId: 'custom_menu',
   *     type: ComponentType.StringSelect,
   *     run: (context) => console.log(context) // Do something here
   *   }
   * ], true);
   * ```
   */
  setActions(actions, includeDefaultActions = false) {
    this.actions.clear();
    return this.addActions([...includeDefaultActions ? _PaginatedMessage.defaultActions : [], ...actions]);
  }
  /**
   * Adds actions to the existing ones. The order given is the order they will be used.
   * @param actions The actions to add.
   * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.
   */
  addActions(actions) {
    for (const action of actions)
      this.addAction(action);
    return this;
  }
  /**
   * Adds an action to the existing ones. This will be added as the last action.
   * @param action The action to add.
   * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.
   */
  addAction(action) {
    if (actionIsLinkButton(action)) {
      this.actions.set(action.url, action);
    } else if (actionIsButtonOrMenu(action)) {
      this.actions.set(action.customId, action);
    }
    return this;
  }
  // #endregion
  // #region page related methods
  /**
   * Checks whether or not the handler has a specific page.
   * @param index The index to check.
   */
  hasPage(index) {
    return index >= 0 && index < this.pages.length;
  }
  /**
   * Clears all current pages and messages and sets them. The order given is the order they will be used.
   * @param pages The pages to set.
   */
  setPages(pages) {
    this.pages = [];
    this.messages = [];
    this.addPages(pages);
    return this;
  }
  /**
   * Adds a page to the existing ones. This will be added as the last page.
   * @remark While you can use this method you should first check out
   * {@link PaginatedMessage.addPageBuilder},
   * {@link PaginatedMessage.addPageContent} and
   * {@link PaginatedMessage.addPageEmbed} as
   * these are easier functional methods of adding pages and will likely already suffice for your needs.
   *
   * @param page The page to add.
   */
  addPage(page) {
    if (this.pages.length === 25) {
      if (!this.hasEmittedMaxPageWarning) {
        process.emitWarning(
          "Maximum amount of pages exceeded for PaginatedMessage. Please check your instance of PaginatedMessage and ensure that you do not exceed 25 pages total.",
          {
            type: "PaginatedMessageExceededMessagePageAmount",
            code: "PAGINATED_MESSAGE_EXCEEDED_MAXIMUM_AMOUNT_OF_PAGES",
            detail: `If you do need more than 25 pages you can extend the class and overwrite the actions in the constructor.`
          }
        );
        this.hasEmittedMaxPageWarning = true;
      }
      return this;
    }
    this.pages.push(page);
    return this;
  }
  /**
   * Update the current page.
   * @param page The content to update the page with.
   *
   * @remark This method can only be used after {@link PaginatedMessage.run} has been used.
   */
  async updateCurrentPage(page) {
    const interaction = this.response;
    const currentIndex = this.index;
    if (interaction === null) {
      throw new Error("You cannot update a page before responding to the interaction.");
    }
    this.pages[currentIndex] = page;
    this.messages[currentIndex] = null;
    this.pageActions[currentIndex]?.clear();
    const target = isAnyInteraction(interaction) ? interaction.user : interaction.author;
    await this.resolvePage(interaction, target, currentIndex);
    return this;
  }
  /**
   * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
   * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   * const { EmbedBuilder } = require('discord.js');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageBuilder((builder) => {
   * 		const embed = new EmbedBuilder()
   * 			.setColor('#FF0000')
   * 			.setDescription('example description');
   *
   * 		return builder
   * 			.setContent('example content')
   * 			.setEmbeds([embed]);
   * });
   * ```
   * @example
   * ```typescript
   * const { EmbedBuilder } = require('discord.js');
   * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const embed = new EmbedBuilder()
   * 	.setColor('#FF0000')
   * 	.setDescription('example description');
   *
   * const builder = new MessageBuilder()
   * 	.setContent('example content')
   * 	.setEmbeds([embed]);
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageBuilder(builder);
   * ```
   */
  addPageBuilder(builder) {
    return this.addPage(isFunction(builder) ? builder(new MessageBuilder()) : builder);
  }
  /**
   * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
   * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   * const { EmbedBuilder } = require('discord.js');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addAsyncPageBuilder(async (builder) => {
   * 		const someRemoteData = await fetch('https://contoso.com/api/users');
   *
   * 		const embed = new EmbedBuilder()
   * 			.setColor('#FF0000')
   * 			.setDescription(someRemoteData.data);
   *
   * 		return builder
   * 			.setContent('example content')
   * 			.setEmbeds([embed]);
   * });
   * ```
   */
  addAsyncPageBuilder(builder) {
    return this.addPage(async () => isFunction(builder) ? builder(new MessageBuilder()) : builder);
  }
  /**
   * Adds a page to the existing ones using simple message content. This will be added as the last page.
   * @param content The content to set.
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageContent('example content');
   * ```
   */
  addPageContent(content) {
    return this.addPage({ content });
  }
  /**
   * Adds a page to the existing ones using a {@link EmbedBuilder}. This wil be added as the last page.
   * @param embed Either a callback whose first parameter is `new EmbedBuilder()`, or an already constructed {@link EmbedBuilder}
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageEmbed((embed) => {
   * 		embed
   * 			.setColor('#FF0000')
   * 			.setDescription('example description');
   *
   * 		return embed;
   * });
   * ```
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const embed = new EmbedBuilder()
   * 	.setColor('#FF0000')
   * 	.setDescription('example description');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageEmbed(embed);
   * ```
   */
  addPageEmbed(embed) {
    return this.addPage({ embeds: isFunction(embed) ? [embed(new EmbedBuilder())] : [embed] });
  }
  /**
   * Adds a page to the existing ones asynchronously using a {@link EmbedBuilder}. This wil be added as the last page.
   * @param embed Either a callback whose first parameter is `new EmbedBuilder()`, or an already constructed {@link EmbedBuilder}
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addAsyncPageEmbed(async (embed) => {
   *		const someRemoteData = await fetch('https://contoso.com/api/users');
   *
   * 		embed
   * 			.setColor('#FF0000')
   * 			.setDescription(someRemoteData.data);
   *
   * 		return embed;
   * });
   * ```
   */
  addAsyncPageEmbed(embed) {
    return this.addPage(async () => ({ embeds: isFunction(embed) ? [await embed(new EmbedBuilder())] : [embed] }));
  }
  /**
   * Adds a page to the existing ones asynchronously using multiple {@link EmbedBuilder}'s. This wil be added as the last page.
   * @remark When using this with a callback this will construct 10 {@link EmbedBuilder}'s in the callback parameters, regardless of how many are actually used.
   * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
   * as many embeds as you want, albeit manually
   * @param embeds Either a callback which receives 10 parameters of `new EmbedBuilder()`, or an array of already constructed {@link EmbedBuilder}'s
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
   * 		embed1
   * 			.setColor('#FF0000')
   * 			.setDescription('example description 1');
   *
   * 		embed2
   * 			.setColor('#00FF00')
   * 			.setDescription('example description 2');
   *
   * 		embed3
   * 			.setColor('#0000FF')
   * 			.setDescription('example description 3');
   *
   * 		return [embed1, embed2, embed3];
   * });
   * ```
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const embed1 = new EmbedBuilder()
   * 	.setColor('#FF0000')
   * 	.setDescription('example description 1');
   *
   * const embed2 = new EmbedBuilder()
   * 	.setColor('#00FF00')
   * 	.setDescription('example description 2');
   *
   * const embed3 = new EmbedBuilder()
   * 	.setColor('#0000FF')
   * 	.setDescription('example description 3');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
   * ```
   */
  addPageEmbeds(embeds) {
    let processedEmbeds = isFunction(embeds) ? embeds(
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder(),
      new EmbedBuilder()
    ) : embeds;
    if (processedEmbeds.length > 10) {
      processedEmbeds = processedEmbeds.slice(0, 10);
    }
    return this.addPage({ embeds: processedEmbeds });
  }
  /**
   * Adds a page to the existing ones using multiple {@link EmbedBuilder}'s. This wil be added as the last page.
   * @remark When using this with a callback this will construct 10 {@link EmbedBuilder}'s in the callback parameters, regardless of how many are actually used.
   * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
   * as many embeds as you want, albeit manually
   * @param embeds Either a callback which receives 10 parameters of `new EmbedBuilder()`, or an array of already constructed {@link EmbedBuilder}'s
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
   * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
   *
   * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
   * 		switch (index) {
   * 			case '0': {
   * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
   * 				break;
   * 			}
   * 			case '1': {
   * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
   * 				break;
   * 			}
   * 			case '2': {
   * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
   * 				break;
   * 			}
   * 		}
   * 	}
   *
   * 	return [embed0, embed1, embed2];
   * });
   * ```
   * @example
   * ```typescript
   * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
   *
   * const embed1 = new EmbedBuilder()
   * 	.setColor('#FF0000')
   * 	.setDescription('example description 1');
   *
   * const embed2 = new EmbedBuilder()
   * 	.setColor('#00FF00')
   * 	.setDescription('example description 2');
   *
   * const embed3 = new EmbedBuilder()
   * 	.setColor('#0000FF')
   * 	.setDescription('example description 3');
   *
   * const paginatedMessage = new PaginatedMessage()
   * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
   * ```
   */
  addAsyncPageEmbeds(embeds) {
    return this.addPage(async () => {
      let processedEmbeds = isFunction(embeds) ? await embeds(
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder()
      ) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
  /**
   * Add pages to the existing ones. The order given is the order they will be used.
   * @param pages The pages to add.
   */
  addPages(pages) {
    for (const page of pages)
      this.addPage(page);
    return this;
  }
  /**
   * Clear all actions for a page and set the new ones.
   * @param actions The actions to set.
   * @param index The index of the page to set the actions to. **This is 0-based**.
   *
   * @remark Internally we check if the provided index exists.
   * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
   * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
   * - {@link PaginatedMessage.addAsyncPageEmbed}
   * - {@link PaginatedMessage.addPageBuilder}
   * - {@link PaginatedMessage.addPageContent}
   * - {@link PaginatedMessage.addPageEmbed}
   * - {@link PaginatedMessage.addPageEmbeds}
   * - {@link PaginatedMessage.addPages}
   * - {@link PaginatedMessage.setPages}
   *
   * @remark Add a select menu to the first page, while preserving all default actions:
   * @example
   * ```typescript
   * const display = new PaginatedMessage();
   *
   * display.setPageActions([
   *   {
   *     customId: 'custom_menu',
   *     type: ComponentType.StringSelect,
   *     run: (context) => console.log(context) // Do something here
   *   }
   * ], 0);
   * ```
   * @see {@link PaginatedMessage.setActions} for more examples on how to structure the action.
   */
  setPageActions(actions, index) {
    if (index < 0 || index > this.pages.length - 1)
      throw new Error("Provided index is out of bounds");
    this.pageActions[index]?.clear();
    this.addPageActions(actions, index);
    return this;
  }
  /**
   * Add the provided actions to a page.
   * @param actions The actions to add.
   * @param index The index of the page to add the actions to.
   * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.
   *
   * @remark Internally we check if the provided index exists.
   * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
   * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
   * - {@link PaginatedMessage.addAsyncPageEmbed}
   * - {@link PaginatedMessage.addPageBuilder}
   * - {@link PaginatedMessage.addPageContent}
   * - {@link PaginatedMessage.addPageEmbed}
   * - {@link PaginatedMessage.addPageEmbeds}
   * - {@link PaginatedMessage.addPages}
   * - {@link PaginatedMessage.setPages}
   */
  addPageActions(actions, index) {
    if (index < 0 || index > this.pages.length - 1)
      throw new Error("Provided index is out of bounds");
    for (const action of actions) {
      this.addPageAction(action, index);
    }
    return this;
  }
  /**
   * Add the provided action to a page.
   * @param action The action to add.
   * @param index The index of the page to add the action to.
   * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.
   *
   * @remark Internally we check if the provided index exists.
   * This means that calling this function _before_ calling any of the methods below this will not work as the amount of pages will always be 0,
   * thus the index will always be out of bounds. That said, make sure you first define your pages and _then_ define your actions for those pages.
   * - {@link PaginatedMessage.addAsyncPageEmbed}
   * - {@link PaginatedMessage.addPageBuilder}
   * - {@link PaginatedMessage.addPageContent}
   * - {@link PaginatedMessage.addPageEmbed}
   * - {@link PaginatedMessage.addPageEmbeds}
   * - {@link PaginatedMessage.addPages}
   * - {@link PaginatedMessage.setPages}
   */
  addPageAction(action, index) {
    if (index < 0 || index > this.pages.length - 1)
      throw new Error("Provided index is out of bounds");
    if (!this.pageActions[index]) {
      this.pageActions[index] = /* @__PURE__ */ new Map();
    }
    if (actionIsLinkButton(action)) {
      this.pageActions[index].set(action.url, action);
    } else if (actionIsButtonOrMenu(action)) {
      this.pageActions[index].set(action.customId, action);
    }
    return this;
  }
  // #endregion
  /**
   * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
   * The handler will start collecting message component interactions.
   *
   * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.
   * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.
   *
   * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
   * Generally this will be the command message or an interaction
   * (either a {@link CommandInteraction}, {@link ContextMenuInteraction}, or an interaction from {@link PaginatedMessageInteractionUnion}),
   * but it can also be another message from your client, i.e. to indicate a loading state.
   *
   * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.
   * If `messageOrInteraction` is an instance of {@link Message} then this defaults to {@link Message.author messageOrInteraction.author},
   * and if it is an instance of {@link CommandInteraction} then it defaults to {@link CommandInteraction.user messageOrInteraction.user}.
   */
  async run(messageOrInteraction, target) {
    if (!messageOrInteraction.channel) {
      const isInteraction = isAnyInteraction(messageOrInteraction);
      let shouldEmitWarning = this.emitPartialDMChannelWarning;
      if (shouldEmitWarning && this.hasEmittedPartialDMChannelWarning) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && isInteraction && messageOrInteraction.client.options.partials?.includes(Partials.Channel)) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && !isInteraction && messageOrInteraction.client.options.partials?.includes(Partials.Channel) && new IntentsBitField(messageOrInteraction.client.options.intents).has(GatewayIntentBits.DirectMessages)) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning) {
        process.emitWarning(
          [
            "PaginatedMessage was initiated in a DM channel without the client having the required partial configured.",
            'If you want PaginatedMessage to work in DM channels then make sure you start your client with "CHANNEL" added to "client.options.partials".',
            'Furthermore if you are using message based commands (as opposed to application commands) then you will also need to add the "DIRECT_MESSAGE" intent to "client.options.intents"',
            'If you do not want to be alerted about this in the future then you can disable this warning by setting "PaginatedMessage.emitPartialDMChannelWarning" to "false", or use "setEmitPartialDMChannelWarning(false)" before calling "run".'
          ].join("\n"),
          {
            type: "PaginatedMessageRunsInNonpartialDMChannel",
            code: "PAGINATED_MESSAGE_RUNS_IN_NON_PARTIAL_DM_CHANNEL"
          }
        );
        this.hasEmittedPartialDMChannelWarning = true;
      }
      await safelyReplyToInteraction({
        messageOrInteraction,
        interactionEditReplyContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        messageMethod: "reply",
        messageMethodContent: __privateGet(this, _thisMazeWasNotMeantForYouContent)
      });
      return this;
    }
    target ??= isAnyInteraction(messageOrInteraction) ? messageOrInteraction.user : messageOrInteraction.author;
    const paginatedMessage = _PaginatedMessage.handlers.get(target.id);
    paginatedMessage?.collector?.stop();
    if (isAnyInteraction(messageOrInteraction)) {
      if (messageOrInteraction.user.bot && messageOrInteraction.user.id === messageOrInteraction.client.user?.id) {
        this.response = messageOrInteraction;
      }
    } else if (messageOrInteraction.author.bot && messageOrInteraction.author.id === messageOrInteraction.client.user?.id) {
      this.response = messageOrInteraction;
    }
    await this.resolvePagesOnRun(messageOrInteraction, target);
    if (!this.messages.length)
      throw new Error("There are no messages.");
    if (!this.actions.size && !this.pageActions.length)
      throw new Error("There are no actions nor page actions.");
    await this.setUpMessage(messageOrInteraction);
    this.setUpCollector(messageOrInteraction, target);
    const messageId = this.response.id;
    if (this.collector) {
      this.collector.once("end", () => {
        _PaginatedMessage.messages.delete(messageId);
        _PaginatedMessage.handlers.delete(target.id);
      });
      _PaginatedMessage.messages.set(messageId, this);
      _PaginatedMessage.handlers.set(target.id, this);
    }
    return this;
  }
  /**
   * Executed whenever {@link PaginatedMessage.run} is called.
   */
  async resolvePagesOnRun(messageOrInteraction, target) {
    for (let i = 0; i < this.pages.length; i++) {
      await this.resolvePage(messageOrInteraction, target, i);
    }
  }
  /**
   * Executed whenever an action is triggered and resolved.
   * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
   * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.
   * @param index The index to resolve.
   */
  async resolvePage(messageOrInteraction, target, index) {
    const message = this.messages[index];
    if (!isNullish(message)) {
      return message;
    }
    const resolvedPage = await this.handlePageLoad(this.pages[index], index);
    if (resolvedPage.actions) {
      this.addPageActions(resolvedPage.actions, index);
    }
    const pageSpecificActions = this.pageActions.at(index);
    const resolvedComponents = [];
    if (this.pages.length > 1) {
      const sharedActions = await this.handleActionLoad([...this.actions.values()], messageOrInteraction, target);
      const sharedComponents = createPartitionedMessageRow(sharedActions);
      resolvedComponents.push(...sharedComponents);
    }
    if (pageSpecificActions) {
      const pageActions = await this.handleActionLoad([...pageSpecificActions.values()], messageOrInteraction, target);
      const pageComponents = createPartitionedMessageRow(pageActions);
      resolvedComponents.push(...pageComponents);
    }
    const resolved = { ...resolvedPage, components: resolvedComponents };
    this.messages[index] = resolved;
    return resolved;
  }
  /**
   * Clones the current handler into a new instance.
   */
  clone() {
    const clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);
    clone.actions = this.actions;
    clone.pageActions = this.pageActions;
    clone.response = this.response;
    clone.template = this.template;
    return clone;
  }
  /**
   * Get the options of a page.
   * @param index The index of the page.
   */
  async getPageOptions(index) {
    const page = this.pages.at(index);
    return isFunction(page) ? page(index, this.pages, this) : page;
  }
  /**
   * Sets up the message.
   *
   * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
   * Generally this will be the command message or an interaction
   * (either a {@link CommandInteraction}, {@link ContextMenuInteraction}, or an interaction from {@link PaginatedMessageInteractionUnion}),
   * but it can also be another message from your client, i.e. to indicate a loading state.
   */
  async setUpMessage(messageOrInteraction) {
    let page = this.messages[this.index];
    page = { ...page, ...this.paginatedMessageData ?? {} };
    if (this.response) {
      if (isAnyInteraction(this.response)) {
        if (this.response.replied || this.response.deferred) {
          await this.response.editReply(page);
        } else {
          await this.response.reply({ ...page, content: page.content ?? void 0 });
        }
      } else if (isMessageInstance(this.response)) {
        await this.response.edit(page);
      }
    } else if (isAnyInteraction(messageOrInteraction)) {
      if (messageOrInteraction.replied || messageOrInteraction.deferred) {
        const editReplyResponse = await messageOrInteraction.editReply(page);
        this.response = messageOrInteraction.ephemeral ? messageOrInteraction : editReplyResponse;
      } else {
        this.response = await messageOrInteraction.reply({
          ...page,
          content: page.content ?? void 0,
          fetchReply: true,
          ephemeral: false
        });
      }
    } else if (!isStageChannel(messageOrInteraction.channel)) {
      this.response = await messageOrInteraction.channel.send({ ...page, content: page.content ?? void 0 });
    }
  }
  /**
   * Sets up the message's collector.
   * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
   * @param targetUser The user the handler is for.
   */
  setUpCollector(messageOrInteraction, targetUser) {
    if (this.pages.length > 1) {
      this.collector = new InteractionCollector(targetUser.client, {
        filter: (interaction) => {
          if (!isNullish(this.response) && interaction.isMessageComponent()) {
            const customIdValidation = this.actions.has(interaction.customId) || this.pageActions.some((actions) => actions && actions.has(interaction.customId));
            if (isAnyInteraction(messageOrInteraction) && messageOrInteraction.ephemeral) {
              return interaction.user.id === targetUser.id && customIdValidation;
            }
            return customIdValidation;
          }
          return false;
        },
        time: this.idle,
        guild: isGuildBasedChannel(messageOrInteraction.channel) ? messageOrInteraction.channel.guild : void 0,
        channel: messageOrInteraction.channel,
        interactionType: InteractionType.MessageComponent,
        ...!isNullish(this.response) && !isAnyInteraction(this.response) ? {
          message: this.response
        } : {}
      }).on("collect", this.handleCollect.bind(this, targetUser, messageOrInteraction.channel)).on("end", this.handleEnd.bind(this));
    }
  }
  /**
   * Handles the load of a page.
   * @param page The page to be loaded.
   * @param index The index of the current page.
   */
  async handlePageLoad(page, index) {
    const options = isFunction(page) ? await page(index, this.pages, this) : page;
    const clonedTemplate = deepClone(this.template);
    const optionsWithTemplate = this.applyTemplate(clonedTemplate, options);
    return this.applyFooter(optionsWithTemplate, index);
  }
  /**
   * Handles the loading of actions.
   * @param actions The actions to be loaded.
   * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
   * @param targetUser The user the handler is for.
   */
  async handleActionLoad(actions, messageOrInteraction, targetUser) {
    return Promise.all(
      actions.map(async (interaction) => {
        if (isMessageButtonInteractionData(interaction)) {
          return new ButtonBuilder(interaction);
        }
        if (isMessageUserSelectInteractionData(interaction)) {
          return new UserSelectMenuBuilder(interaction);
        }
        if (isMessageRoleSelectInteractionData(interaction)) {
          return new RoleSelectMenuBuilder(interaction);
        }
        if (isMessageMentionableSelectInteractionData(interaction)) {
          return new MentionableSelectMenuBuilder(interaction);
        }
        if (isMessageChannelSelectInteractionData(interaction)) {
          return new ChannelSelectMenuBuilder(interaction);
        }
        if (isMessageStringSelectInteractionData(interaction)) {
          return new StringSelectMenuBuilder({
            ...interaction,
            ...interaction.customId === "@sapphire/paginated-messages.goToPage" && {
              options: await Promise.all(
                this.pages.map(async (_, index) => {
                  return {
                    ...await this.selectMenuOptions(
                      index + 1,
                      this.resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser)
                    ),
                    value: index.toString()
                  };
                })
              ),
              placeholder: this.selectMenuPlaceholder
            }
          });
        }
        throw new Error(
          "Unsupported message component type detected. Validate your code and if you're sure this is a bug in Sapphire make a report in the server"
        );
      })
    );
  }
  /**
   * Handles the `collect` event from the collector.
   * @param targetUser The user the handler is for.
   * @param channel The channel the handler is running at.
   * @param interaction The button interaction that was received.
   */
  async handleCollect(targetUser, channel, interaction) {
    if (interaction.user.id === targetUser.id) {
      this.response = interaction;
      const action = this.getAction(interaction.customId, this.index);
      if (isNullish(action)) {
        throw new Error("There was no action for the provided custom ID");
      }
      if (actionIsButtonOrMenu(action) && action.run) {
        const previousIndex = this.index;
        await action.run({
          interaction,
          handler: this,
          author: targetUser,
          channel,
          response: this.response,
          collector: this.collector
        });
        if (!this.stopPaginatedMessageCustomIds.includes(action.customId)) {
          const newIndex = previousIndex === this.index ? previousIndex : this.index;
          const updateOptions = await this.resolvePage(this.response, targetUser, newIndex);
          await safelyReplyToInteraction({
            messageOrInteraction: interaction,
            interactionEditReplyContent: updateOptions,
            interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
            componentUpdateContent: updateOptions
          });
        }
      }
    } else {
      const interactionReplyOptions = await this.wrongUserInteractionReply(
        targetUser,
        interaction.user,
        this.resolvePaginatedMessageInternationalizationContext(interaction, targetUser)
      );
      await interaction.reply(
        isObject(interactionReplyOptions) ? interactionReplyOptions : { content: interactionReplyOptions, ephemeral: true, allowedMentions: { users: [], roles: [] } }
      );
    }
  }
  /**
   * Handles the `end` event from the collector.
   * @param reason The reason for which the collector was ended.
   */
  async handleEnd(_, reason) {
    if ((reason === "time" || reason === "idle") && this.response !== null && isAnyInteraction(this.response) && this.response.isMessageComponent()) {
      this.response.message = await this.response.fetchReply();
    }
    this.collector?.removeAllListeners();
    if (this.response && !_PaginatedMessage.deletionStopReasons.includes(reason)) {
      void safelyReplyToInteraction({
        messageOrInteraction: this.response,
        interactionEditReplyContent: { components: [] },
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: { components: [] },
        messageMethod: "edit",
        messageMethodContent: { components: [] }
      });
    }
  }
  /**
   * Applies footer to the last embed of the page
   * @param message The message options
   * @param index The current index
   * @returns The message options with the footer applied
   */
  applyFooter(message, index) {
    if (!message.embeds?.length) {
      return message;
    }
    const embedsWithFooterApplied = deepClone(message.embeds);
    const idx = embedsWithFooterApplied.length - 1;
    if (embedsWithFooterApplied.length > 0) {
      let lastEmbed = embedsWithFooterApplied[idx];
      const templateEmbed = this.template.embeds?.[idx] ?? this.template.embeds?.[0];
      const jsonTemplateEmbed = isJSONEncodable(templateEmbed) ? templateEmbed.toJSON() : templateEmbed;
      if (isJSONEncodable(lastEmbed)) {
        lastEmbed = lastEmbed.toJSON();
        embedsWithFooterApplied[idx] = lastEmbed;
      }
      lastEmbed.footer ??= { text: jsonTemplateEmbed?.footer?.text ?? "" };
      if (this.shouldAddFooterToEmbeds) {
        lastEmbed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ""}${index + 1} / ${this.pages.length}${lastEmbed.footer.text ? ` ${this.embedFooterSeparator} ${lastEmbed.footer.text}` : ""}`;
      }
    }
    return { ...message, embeds: embedsWithFooterApplied };
  }
  /**
   * Constructs a {@link PaginatedMessageInternationalizationContext}
   * @param messageOrInteraction The message or interaction for which the {@link PaginatedMessageInternationalizationContext} should be resolved.
   * @param targetUser The target user for whom this interaction is
   * @returns A constructed {@link PaginatedMessageInternationalizationContext}
   */
  resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser) {
    const context = {
      user: targetUser,
      channel: messageOrInteraction.channel,
      guild: isGuildBasedChannel(messageOrInteraction.channel) ? messageOrInteraction.channel.guild : null,
      interactionGuildLocale: isAnyInteraction(messageOrInteraction) ? messageOrInteraction.guildLocale : void 0,
      interactionLocale: isAnyInteraction(messageOrInteraction) ? messageOrInteraction.locale : void 0
    };
    return context;
  }
  /**
   * Applies a template to the provided options, merging them together and applying the template's embeds.
   *
   * @param template - The template to apply.
   * @param options - The options to merge with the template.
   * @returns The merged options with the template's embeds applied.
   */
  applyTemplate(template, options) {
    const embedData = this.applyTemplateEmbed(template.embeds, options.embeds);
    return { ...template, ...options, embeds: embedData };
  }
  /**
   * Applies a template embed to the page embeds.
   * If the page embeds are nullish, it returns the template embed as an array.
   * If the template embed is nullish, it returns the page embeds.
   * Otherwise, it merges the template embed with the first page embed.
   *
   * @param templateEmbed - The template embed to apply.
   * @param pageEmbeds - The page embeds to apply the template to.
   * @returns The resulting embeds after applying the template.
   */
  applyTemplateEmbed(templateEmbed, pageEmbeds) {
    if (isNullish(pageEmbeds)) {
      return templateEmbed ? [templateEmbed?.[0]] : void 0;
    }
    if (isNullish(templateEmbed)) {
      return pageEmbeds;
    }
    return this.mergeEmbeds(templateEmbed[0], pageEmbeds);
  }
  /**
   * Merges the template embed with an array of page embeds.
   *
   * @param templateEmbed - The template embed to merge.
   * @param pageEmbeds - The array of page embeds to merge.
   * @returns The merged embeds.
   */
  mergeEmbeds(templateEmbed, pageEmbeds) {
    const mergedEmbeds = [];
    const jsonTemplate = isJSONEncodable(templateEmbed) ? templateEmbed.toJSON() : templateEmbed;
    for (const pageEmbed of pageEmbeds) {
      const pageJson = isJSONEncodable(pageEmbed) ? pageEmbed.toJSON() : pageEmbed;
      mergedEmbeds.push({
        title: pageJson.title ?? jsonTemplate.title ?? void 0,
        description: pageJson.description ?? jsonTemplate.description ?? void 0,
        url: pageJson.url ?? jsonTemplate.url ?? void 0,
        timestamp: (typeof pageJson.timestamp === "string" ? new Date(pageJson.timestamp).toISOString() : pageJson.timestamp) ?? (typeof jsonTemplate.timestamp === "string" ? new Date(jsonTemplate.timestamp).toISOString() : jsonTemplate.timestamp) ?? void 0,
        color: pageJson.color ?? jsonTemplate.color ?? void 0,
        fields: this.mergeArrays(jsonTemplate.fields, pageJson.fields),
        author: pageJson.author ?? jsonTemplate.author ?? void 0,
        thumbnail: pageJson.thumbnail ?? jsonTemplate.thumbnail ?? void 0,
        image: pageJson.image ?? jsonTemplate.image ?? void 0,
        video: pageJson.video ?? jsonTemplate.video ?? void 0,
        footer: pageJson.footer ?? jsonTemplate.footer ?? void 0
      });
    }
    return mergedEmbeds;
  }
  /**
   * Merges two arrays together.
   * @template T - The type of elements in the arrays.
   * @param {T[]} template - The first array to merge.
   * @param {T[]} array - The second array to merge.
   * @returns {undefined | T[]} - The merged array or undefined if both arrays are nullish.
   */
  mergeArrays(template, array) {
    if (isNullish(array)) {
      return template;
    }
    if (isNullish(template)) {
      return array;
    }
    return [...template, ...array];
  }
  /**
   * Retrieves the PaginatedMessageAction associated with the provided customId and index.
   *
   * @param customId - The customId of the action.
   * @param index - The index of the action in the pageActions array.
   * @returns The PaginatedMessageAction associated with the customId and index, or undefined if not found.
   */
  getAction(customId, index) {
    const action = this.actions.get(customId);
    if (action)
      return action;
    return this.pageActions.at(index)?.get(customId);
  }
};
_thisMazeWasNotMeantForYouContent = new WeakMap();
__name(_PaginatedMessage, "PaginatedMessage");
// #region public static class properties
/**
 * The default actions of this handler.
 */
__publicField(_PaginatedMessage, "defaultActions", [
  {
    customId: "@sapphire/paginated-messages.goToPage",
    type: ComponentType.StringSelect,
    options: [],
    run: ({ handler, interaction }) => interaction.isStringSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
  },
  {
    customId: "@sapphire/paginated-messages.firstPage",
    style: ButtonStyle.Primary,
    emoji: "\u23EA",
    type: ComponentType.Button,
    run: ({ handler }) => handler.index = 0
  },
  {
    customId: "@sapphire/paginated-messages.previousPage",
    style: ButtonStyle.Primary,
    emoji: "\u25C0\uFE0F",
    type: ComponentType.Button,
    run: ({ handler }) => {
      if (handler.index === 0) {
        handler.index = handler.pages.length - 1;
      } else {
        --handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.nextPage",
    style: ButtonStyle.Primary,
    emoji: "\u25B6\uFE0F",
    type: ComponentType.Button,
    run: ({ handler }) => {
      if (handler.index === handler.pages.length - 1) {
        handler.index = 0;
      } else {
        ++handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.goToLastPage",
    style: ButtonStyle.Primary,
    emoji: "\u23E9",
    type: ComponentType.Button,
    run: ({ handler }) => handler.index = handler.pages.length - 1
  },
  {
    customId: "@sapphire/paginated-messages.stop",
    style: ButtonStyle.Danger,
    emoji: "\u23F9\uFE0F",
    type: ComponentType.Button,
    run: ({ collector }) => {
      collector.stop();
    }
  }
]);
/**
 * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client the `'CHANNEL'` partial.
 * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
 *
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
 * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setEmitPartialDMChannelWarning(newBoolean)`
 * @default true
 */
__publicField(_PaginatedMessage, "emitPartialDMChannelWarning", true);
/**
 * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
 * @default ['@sapphire/paginated-messages.stop']
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
 * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setStopPaginatedMessageCustomIds(customIds)`
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.stopPaginatedMessageCustomIds = ['my-custom-stop-custom-id'];
 * ```
 */
__publicField(_PaginatedMessage, "stopPaginatedMessageCustomIds", ["@sapphire/paginated-messages.stop"]);
/**
 * The reasons sent by {@linkplain https://discord.js.org/docs/packages/discord.js/main/InteractionCollector:Class#end InteractionCollector#end}
 * event when the message (or its owner) has been deleted.
 */
__publicField(_PaginatedMessage, "deletionStopReasons", ["messageDelete", "channelDelete", "guildDelete"]);
/**
 * Custom text to show in front of the page index in the embed footer.
 * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
 * @default ""
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.pageIndexPrefix = 'Page';
 * // This will make the footer of the embed something like "Page 1/2"
 * ```
 */
__publicField(_PaginatedMessage, "pageIndexPrefix", "");
/**
 * Custom separator for the page index in the embed footer.
 * @default "•"
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
 * Alternatively, you can also customize it on a per-PaginatedMessage basis by passing `embedFooterSeparator` in the options of the constructor.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.embedFooterSeparator = '|';
 * // This will make the separator of the embed footer something like "Page 1/2 | Today at 4:20"
 * ```
 */
__publicField(_PaginatedMessage, "embedFooterSeparator", "\u2022");
/**
 * The messages that are currently being handled by a {@link PaginatedMessage}
 * The key is the ID of the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
 * This is important when having an editable commands solution.
 */
__publicField(_PaginatedMessage, "messages", /* @__PURE__ */ new Map());
/**
 * The current {@link InteractionCollector} handlers that are active.
 * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
 * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
 */
__publicField(_PaginatedMessage, "handlers", /* @__PURE__ */ new Map());
/**
 * A generator for {@link MessageSelectOption} that will be used to generate the options for the {@link StringSelectMenuBuilder}.
 * We do not allow overwriting the {@link MessageSelectOption#value} property with this, as it is vital to how we handle
 * select menu interactions.
 *
 * @param pageIndex The index of the page to add to the {@link StringSelectMenuBuilder}. We will add 1 to this number because our pages are 0 based,
 * so this will represent the pages as seen by the user.
 * @default
 * ```ts
 * {
 * 	label: `Page ${pageIndex}`
 * }
 * ```
 * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.selectMenuOptions = (pageIndex) => ({
 * 	 label: `Go to page: ${pageIndex}`,
 * 	 description: 'This is a description'
 * });
 * ```
 */
__publicField(_PaginatedMessage, "selectMenuOptions", /* @__PURE__ */ __name((pageIndex) => ({ label: `Page ${pageIndex}` }), "selectMenuOptions"));
/**
 * A generator for {@link MessageComponentInteraction#reply} that will be called and sent whenever an untargeted user interacts with one of the buttons.
 * When modifying this it is recommended that the message is set to be ephemeral so only the user that is pressing the buttons can see them.
 * Furthermore, we also recommend setting `allowedMentions: { users: [], roles: [] }`, so you don't have to worry about accidentally pinging anyone.
 *
 * When setting just a string, we will add `{ ephemeral: true, allowedMentions: { users: [], roles: [] } }` for you.
 *
 * @param targetUser The {@link User} this {@link PaginatedMessage} was intended for.
 * @param interactionUser The {@link User} that actually clicked the button.
 * @default
 * ```ts
 * import { userMention } from 'discord.js';
 *
 * {
 * 	content: `Please stop interacting with the components on this message. They are only for ${userMention(targetUser.id)}.`,
 * 	ephemeral: true,
 * 	allowedMentions: { users: [], roles: [] }
 * }
 * ```
 * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 * import { userMention } from 'discord.js';
 *
 * // We  will add ephemeral and no allowed mention for string only overwrites
 * PaginatedMessage.wrongUserInteractionReply = (targetUser) =>
 *     `These buttons are only for ${userMention(targetUser.id)}. Press them as much as you want, but I won't do anything with your clicks.`;
 * ```
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 * import { userMention } from 'discord.js';
 *
 * PaginatedMessage.wrongUserInteractionReply = (targetUser) => ({
 * 	content: `These buttons are only for ${userMention(
 * 		targetUser.id
 * 	)}. Press them as much as you want, but I won't do anything with your clicks.`,
 * 	ephemeral: true,
 * 	allowedMentions: { users: [], roles: [] }
 * });
 * ```
 */
__publicField(_PaginatedMessage, "wrongUserInteractionReply", /* @__PURE__ */ __name((targetUser) => ({
  content: `Please stop interacting with the components on this message. They are only for ${userMention(targetUser.id)}.`,
  ephemeral: true,
  allowedMentions: { users: [], roles: [] }
}), "wrongUserInteractionReply"));
var PaginatedMessage = _PaginatedMessage;

// src/lib/PaginatedMessages/LazyPaginatedMessage.ts
var _LazyPaginatedMessage = class _LazyPaginatedMessage extends PaginatedMessage {
  /**
   * Only resolves the page corresponding with the handler's current index.
   */
  async resolvePagesOnRun(messageOrInteraction, target) {
    await this.resolvePage(messageOrInteraction, target, this.index);
  }
  /**
   * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.
   * @param messageOrInteraction The message or interaction that triggered this {@link LazyPaginatedMessage}.
   * @param target The user who will be able to interact with the buttons of this {@link LazyPaginatedMessage}.
   * @param index The index to resolve. Defaults to handler's current index.
   */
  async resolvePage(messageOrInteraction, target, index) {
    const promises = [super.resolvePage(messageOrInteraction, target, index)];
    if (this.hasPage(index - 1))
      promises.push(super.resolvePage(messageOrInteraction, target, index - 1));
    if (this.hasPage(index + 1))
      promises.push(super.resolvePage(messageOrInteraction, target, index + 1));
    const [result] = await Promise.all(promises);
    return result;
  }
  addPageBuilder(builder) {
    return this.addPage(() => isFunction(builder) ? builder(new MessageBuilder()) : builder);
  }
  addPageContent(content) {
    return this.addPage(() => ({ content }));
  }
  addPageEmbed(embed) {
    return this.addPage(() => ({ embeds: typeof embed === "function" ? [embed(new EmbedBuilder())] : [embed] }));
  }
  addPageEmbeds(embeds) {
    return this.addPage(() => {
      let processedEmbeds = isFunction(embeds) ? embeds(
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder(),
        new EmbedBuilder()
      ) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
};
__name(_LazyPaginatedMessage, "LazyPaginatedMessage");
var LazyPaginatedMessage = _LazyPaginatedMessage;
var _PaginatedFieldMessageEmbed = class _PaginatedFieldMessageEmbed extends PaginatedMessage {
  constructor() {
    super(...arguments);
    /**
     * The `embedTemplate` field represents the template for the embed message. It is of type `APIEmbed`.
     * It is initialized with a new `EmbedBuilder` instance converted to JSON.
     */
    __publicField(this, "embedTemplate", new EmbedBuilder().toJSON());
    /**
     * The `totalPages` field represents the total number of pages in the paginated message. It is of type `number`.
     * It is initialized to 0.
     */
    __publicField(this, "totalPages", 0);
    /**
     * The `items` field represents the items to be displayed in the paginated message. It is an array of type `T`.
     * It is initialized to an empty array.
     */
    __publicField(this, "items", []);
    /**
     * The `itemsPerPage` field represents the number of items to be displayed per page. It is of type `number`.
     * It is initialized to 10.
     */
    __publicField(this, "itemsPerPage", 10);
    /**
     * The `fieldTitle` field represents the title of the field in the embed message. It is of type `string`.
     * It is initialized to an empty string.
     */
    __publicField(this, "fieldTitle", "");
  }
  /**
   * Set the items to paginate.
   * @param items The pages to set
   */
  setItems(items) {
    this.items = items;
    return this;
  }
  /**
   * Set the title of the embed field that will be used to paginate the items.
   * @param title The field title
   */
  setTitleField(title) {
    this.fieldTitle = title;
    return this;
  }
  /**
   * Sets the amount of items that should be shown per page.
   * @param itemsPerPage The number of items
   */
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  /**
   * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link EmbedBuilder} instance or an object with embed options.
   *
   * @param template EmbedBuilder
   *
   * @example
   * ```typescript
   * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
   * import { EmbedBuilder } from 'discord.js';
   *
   * new PaginatedFieldMessageEmbed().setTemplate(new EmbedBuilder().setTitle('Test pager embed')).make().run(message);
   * ```
   *
   * @example
   * ```typescript
   * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
   *
   * new PaginatedFieldMessageEmbed().setTemplate({ title: 'Test pager embed' }).make().run(message);
   * ```
   */
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  /**
   * Sets a format callback that will be mapped to each embed field in the array of items when the embed is paginated. This should convert each item to a format that is either text itself or can be serialized as text.
   *
   * @example
   * ```typescript
   * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
   *
   * new PaginatedFieldMessageEmbed()
   *    .setTitleField('Test field')
   *    .setTemplate({ embed })
   *    .setItems([
   *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
   *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
   *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
   *     ])
   *    .formatItems((item) => `${item.title}\n${item.value}`)
   *    .make()
   *    .run(message);
   * ```
   * @param formatter The formatter callback to be applied to each embed item
   */
  formatItems(formatter) {
    this.items = this.items.map(formatter);
    return this;
  }
  /**
   * Build the pages of the given array.
   *
   * You must call the {@link PaginatedFieldMessageEmbed.make} and {@link PaginatedFieldMessageEmbed.run} methods last, in that order, for the pagination to work.
   *
   * @example
   * ```typescript
   * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
   *
   * new PaginatedFieldMessageEmbed()
   *    .setTitleField('Test field')
   *    .setTemplate({ embed })
   *    .setItems([
   *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
   *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
   *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
   *     ])
   *    .formatItems((item) => `${item.title}\n${item.value}`)
   *    .make()
   *    .run(message);
   * ```
   */
  make() {
    if (!this.fieldTitle.length)
      throw new Error("The title of the field to format must have a value.");
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.items.some((x) => !x))
      throw new Error("The format of the array items is incorrect.");
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  /**
   * Generates the pages for the paginated field message embed.
   * Each page contains a cloned template with modified fields and data.
   */
  generatePages() {
    const template = this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new EmbedBuilder(template);
      const fieldsClone = isNullishOrEmpty(template.fields) ? [] : [...template.fields];
      if (fieldsClone.length > 0)
        clonedTemplate.setFields();
      if (isNullish(template.color))
        clonedTemplate.setColor("Random");
      const data = this.paginateArray(this.items, i, this.itemsPerPage);
      this.addPage({
        embeds: [clonedTemplate.addFields({ name: this.fieldTitle, value: data.join("\n"), inline: false }, ...fieldsClone)]
      });
    }
  }
  /**
   * Paginates an array of items.
   *
   * @template T The type of items in the array.
   * @param items The array of items to paginate.
   * @param currentPage The current page number.
   * @param perPageItems The number of items per page.
   * @returns The paginated array of items.
   */
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  /**
   * Resolves the template for the embed.
   *
   * @param template - The template for the embed. It can be an EmbedResolvable, EmbedData, or a function that takes an EmbedBuilder and returns an EmbedResolvable.
   * @returns The resolved APIEmbed object.
   */
  resolveTemplate(template) {
    if (isFunction(template))
      template = template(new EmbedBuilder());
    return (isJSONEncodable(template) ? template : new EmbedBuilder(template)).toJSON();
  }
};
__name(_PaginatedFieldMessageEmbed, "PaginatedFieldMessageEmbed");
var PaginatedFieldMessageEmbed = _PaginatedFieldMessageEmbed;
var _PaginatedMessageEmbedFields = class _PaginatedMessageEmbedFields extends PaginatedMessage {
  constructor() {
    super(...arguments);
    /**
     * The `embedTemplate` field represents the template for the embed message. It is of type `APIEmbed`.
     * It is initialized with a new `EmbedBuilder` instance converted to JSON.
     */
    __publicField(this, "embedTemplate", new EmbedBuilder().toJSON());
    /**
     * The `totalPages` field represents the total number of pages in the paginated message. It is of type `number`.
     * It is initialized to 0.
     */
    __publicField(this, "totalPages", 0);
    /**
     * The array of embed fields in the PaginatedMessageEmbedFields class.
     */
    __publicField(this, "items", []);
    /**
     * The `itemsPerPage` field represents the number of items to be displayed per page. It is of type `number`.
     * It is initialized to 10.
     */
    __publicField(this, "itemsPerPage", 10);
  }
  /**
   * Set the items to paginate.
   * @param items The pages to set
   */
  setItems(items) {
    this.items = items;
    return this;
  }
  /**
   * Sets the amount of items that should be shown per page.
   * @param itemsPerPage The number of items
   */
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  /**
   * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.
   * All fields in the given template will be overwritten when calling {@link PaginatedMessageEmbedFields.make}.
   *
   * @param template MessageEmbed
   *
   * @example
   * ```typescript
   * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
   * import { EmbedBuilder } from 'discord.js';
   *
   * new PaginatedMessageEmbedFields()
   * 	.setTemplate(new EmbedBuilder().setColor('#006080').setTitle('Test pager embed'))
   * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
   * 	.make()
   * 	.run(message);
   * ```
   *
   * @example
   * ```typescript
   * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
   *
   * new PaginatedMessageEmbedFields()
   * 	.setTemplate({ title: 'Test pager embed', color: '#006080' })
   * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
   * 	.make()
   * 	.run(message);
   * ```
   */
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  /**
   * Build the pages of the given array.
   *
   * You must call the [[PaginatedMessageEmbedFields.make]] and [[PaginatedMessageEmbedFields.run]] methods last, in that order, for the pagination to work.
   *
   * @example
   * ```typescript
   * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
   *
   * new PaginatedMessageEmbedFields()
   * 	.setItems([
   * 		{ name: 'Sapphire Framework', value: 'discord.js Framework' },
   * 		{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
   * 		{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
   * 	])
   * 	.setItemsPerPage(3)
   * 	.make()
   * 	.run(message);
   * ```
   */
  make() {
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.itemsPerPage > EmbedLimits.MaximumFields)
      throw new Error(`Pages cannot contain more than ${EmbedLimits.MaximumFields} fields.`);
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  /**
   * Generates the pages for the paginated message.
   * It clones the embed template, sets the fields, color, and adds the data to each page.
   */
  generatePages() {
    const template = this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new EmbedBuilder(template);
      const fieldsClone = isNullishOrEmpty(template.fields) ? [] : [...template.fields];
      if (fieldsClone.length > 0)
        clonedTemplate.setFields();
      if (!clonedTemplate.data.color)
        clonedTemplate.setColor("Random");
      const data = this.paginateArray(this.items, i, this.itemsPerPage - fieldsClone.length);
      this.addPage({
        embeds: [clonedTemplate.addFields(...data, ...fieldsClone)]
      });
    }
  }
  /**
   * Paginates an array of EmbedFields.
   *
   * @param items - The array of EmbedFields to paginate.
   * @param currentPage - The current page number.
   * @param perPageItems - The number of items per page.
   * @returns The paginated array of EmbedFields.
   */
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  /**
   * Resolves the template for the PaginatedMessageEmbedFields.
   *
   * @param template - The template to resolve. It can be an EmbedResolvable, EmbedData, or a function that takes an EmbedBuilder and returns an EmbedResolvable.
   * @returns The resolved APIEmbed object.
   */
  resolveTemplate(template) {
    if (isFunction(template))
      template = template(new EmbedBuilder());
    return (isJSONEncodable(template) ? template : new EmbedBuilder(template)).toJSON();
  }
};
__name(_PaginatedMessageEmbedFields, "PaginatedMessageEmbedFields");
var PaginatedMessageEmbedFields = _PaginatedMessageEmbedFields;
var canReadMessagesPermissions = new PermissionsBitField([PermissionFlagsBits.ViewChannel]);
function canReadMessages(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  return canDoUtility(channel, canReadMessagesPermissions);
}
__name(canReadMessages, "canReadMessages");
var canSendMessagesPermissions = new PermissionsBitField([canReadMessagesPermissions, PermissionFlagsBits.SendMessages]);
function canSendMessages(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendMessagesPermissions);
}
__name(canSendMessages, "canSendMessages");
var canSendEmbedsPermissions = new PermissionsBitField([canSendMessagesPermissions, PermissionFlagsBits.EmbedLinks]);
function canSendEmbeds(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendEmbedsPermissions);
}
__name(canSendEmbeds, "canSendEmbeds");
var canSendAttachmentsPermissions = new PermissionsBitField([canSendMessagesPermissions, PermissionFlagsBits.AttachFiles]);
function canSendAttachments(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendAttachmentsPermissions);
}
__name(canSendAttachments, "canSendAttachments");
var canReactPermissions = new PermissionsBitField([
  canSendMessagesPermissions,
  PermissionFlagsBits.ReadMessageHistory,
  PermissionFlagsBits.AddReactions
]);
function canReact(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && channel.archived)
    return false;
  return canDoUtility(channel, canReactPermissions);
}
__name(canReact, "canReact");
var canRemoveAllReactionsPermissions = new PermissionsBitField([
  canReadMessagesPermissions,
  PermissionFlagsBits.ReadMessageHistory,
  PermissionFlagsBits.ManageMessages
]);
function canRemoveAllReactions(channel) {
  if (isNullish(channel))
    return false;
  if (isDMChannel(channel))
    return false;
  return canDoUtility(channel, canRemoveAllReactionsPermissions);
}
__name(canRemoveAllReactions, "canRemoveAllReactions");
var canJoinVoiceChannelPermissions = new PermissionsBitField([PermissionFlagsBits.Connect]);
function canJoinVoiceChannel(channel) {
  if (isNullish(channel))
    return false;
  if (!isVoiceBasedChannel(channel))
    return false;
  if (channel.userLimit >= channel.members.size)
    return false;
  return canDoUtility(channel, canJoinVoiceChannelPermissions);
}
__name(canJoinVoiceChannel, "canJoinVoiceChannel");
function canDoUtility(channel, permissionsToPass) {
  if (!isGuildBasedChannel(channel)) {
    return true;
  }
  const { me } = channel.guild.members;
  if (!me)
    return false;
  const permissionsFor = channel.permissionsFor(me);
  if (!permissionsFor)
    return false;
  return permissionsFor.has(permissionsToPass);
}
__name(canDoUtility, "canDoUtility");

export { LazyPaginatedMessage, MessageBuilder, MessagePrompter, MessagePrompterBaseStrategy, MessagePrompterConfirmStrategy, MessagePrompterMessageStrategy, MessagePrompterNumberStrategy, MessagePrompterReactionStrategy, PaginatedFieldMessageEmbed, PaginatedMessage, PaginatedMessageEmbedFields, actionIsButtonOrMenu, actionIsLinkButton, canJoinVoiceChannel, canReact, canReadMessages, canRemoveAllReactions, canSendAttachments, canSendEmbeds, canSendMessages, createPartitionedMessageRow, isActionButton, isActionChannelMenu, isActionLink, isActionMentionableMenu, isActionRoleMenu, isActionStringMenu, isActionUserMenu, isAnyInteractableInteraction, isAnyInteraction, isButtonComponentBuilder, isCategoryChannel, isDMChannel, isGroupChannel, isGuildBasedChannel, isGuildBasedChannelByGuildKey, isGuildMember, isMessageButtonInteractionData, isMessageChannelSelectInteractionData, isMessageInstance, isMessageMentionableSelectInteractionData, isMessageRoleSelectInteractionData, isMessageStringSelectInteractionData, isMessageUserSelectInteractionData, isNewsChannel, isNewsThreadChannel, isNsfwChannel, isPrivateThreadChannel, isPublicThreadChannel, isStageChannel, isTextBasedChannel, isTextChannel, isThreadChannel, isVoiceBasedChannel, isVoiceChannel, safelyReplyToInteraction };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map