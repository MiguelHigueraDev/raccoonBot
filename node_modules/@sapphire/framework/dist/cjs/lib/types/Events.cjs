'use strict';

var discord_js = require('discord.js');

// src/lib/types/Events.ts
var Events = {
  // #region Discord.js base events
  ApplicationCommandPermissionsUpdate: discord_js.Events.ApplicationCommandPermissionsUpdate,
  AutoModerationActionExecution: discord_js.Events.AutoModerationActionExecution,
  AutoModerationRuleCreate: discord_js.Events.AutoModerationRuleCreate,
  AutoModerationRuleDelete: discord_js.Events.AutoModerationRuleDelete,
  AutoModerationRuleUpdate: discord_js.Events.AutoModerationRuleUpdate,
  CacheSweep: discord_js.Events.CacheSweep,
  ChannelCreate: discord_js.Events.ChannelCreate,
  ChannelDelete: discord_js.Events.ChannelDelete,
  ChannelPinsUpdate: discord_js.Events.ChannelPinsUpdate,
  ChannelUpdate: discord_js.Events.ChannelUpdate,
  ClientReady: discord_js.Events.ClientReady,
  Debug: discord_js.Events.Debug,
  Error: discord_js.Events.Error,
  GuildAuditLogEntryCreate: discord_js.Events.GuildAuditLogEntryCreate,
  GuildAvailable: discord_js.Events.GuildAvailable,
  GuildBanAdd: discord_js.Events.GuildBanAdd,
  GuildBanRemove: discord_js.Events.GuildBanRemove,
  GuildCreate: discord_js.Events.GuildCreate,
  GuildDelete: discord_js.Events.GuildDelete,
  GuildEmojiCreate: discord_js.Events.GuildEmojiCreate,
  GuildEmojiDelete: discord_js.Events.GuildEmojiDelete,
  GuildEmojiUpdate: discord_js.Events.GuildEmojiUpdate,
  GuildIntegrationsUpdate: discord_js.Events.GuildIntegrationsUpdate,
  GuildMemberAdd: discord_js.Events.GuildMemberAdd,
  GuildMemberAvailable: discord_js.Events.GuildMemberAvailable,
  GuildMemberRemove: discord_js.Events.GuildMemberRemove,
  GuildMembersChunk: discord_js.Events.GuildMembersChunk,
  GuildMemberUpdate: discord_js.Events.GuildMemberUpdate,
  GuildRoleCreate: discord_js.Events.GuildRoleCreate,
  GuildRoleDelete: discord_js.Events.GuildRoleDelete,
  GuildRoleUpdate: discord_js.Events.GuildRoleUpdate,
  GuildScheduledEventCreate: discord_js.Events.GuildScheduledEventCreate,
  GuildScheduledEventDelete: discord_js.Events.GuildScheduledEventDelete,
  GuildScheduledEventUpdate: discord_js.Events.GuildScheduledEventUpdate,
  GuildScheduledEventUserAdd: discord_js.Events.GuildScheduledEventUserAdd,
  GuildScheduledEventUserRemove: discord_js.Events.GuildScheduledEventUserRemove,
  GuildStickerCreate: discord_js.Events.GuildStickerCreate,
  GuildStickerDelete: discord_js.Events.GuildStickerDelete,
  GuildStickerUpdate: discord_js.Events.GuildStickerUpdate,
  GuildUnavailable: discord_js.Events.GuildUnavailable,
  GuildUpdate: discord_js.Events.GuildUpdate,
  InteractionCreate: discord_js.Events.InteractionCreate,
  Invalidated: discord_js.Events.Invalidated,
  InviteCreate: discord_js.Events.InviteCreate,
  InviteDelete: discord_js.Events.InviteDelete,
  MessageBulkDelete: discord_js.Events.MessageBulkDelete,
  MessageCreate: discord_js.Events.MessageCreate,
  MessageDelete: discord_js.Events.MessageDelete,
  MessageReactionAdd: discord_js.Events.MessageReactionAdd,
  MessageReactionRemove: discord_js.Events.MessageReactionRemove,
  MessageReactionRemoveAll: discord_js.Events.MessageReactionRemoveAll,
  MessageReactionRemoveEmoji: discord_js.Events.MessageReactionRemoveEmoji,
  MessageUpdate: discord_js.Events.MessageUpdate,
  PresenceUpdate: discord_js.Events.PresenceUpdate,
  Raw: discord_js.Events.Raw,
  ShardDisconnect: discord_js.Events.ShardDisconnect,
  ShardError: discord_js.Events.ShardError,
  ShardReady: discord_js.Events.ShardReady,
  ShardReconnecting: discord_js.Events.ShardReconnecting,
  ShardResume: discord_js.Events.ShardResume,
  StageInstanceCreate: discord_js.Events.StageInstanceCreate,
  StageInstanceDelete: discord_js.Events.StageInstanceDelete,
  StageInstanceUpdate: discord_js.Events.StageInstanceUpdate,
  ThreadCreate: discord_js.Events.ThreadCreate,
  ThreadDelete: discord_js.Events.ThreadDelete,
  ThreadListSync: discord_js.Events.ThreadListSync,
  ThreadMembersUpdate: discord_js.Events.ThreadMembersUpdate,
  ThreadMemberUpdate: discord_js.Events.ThreadMemberUpdate,
  ThreadUpdate: discord_js.Events.ThreadUpdate,
  TypingStart: discord_js.Events.TypingStart,
  UserUpdate: discord_js.Events.UserUpdate,
  VoiceServerUpdate: discord_js.Events.VoiceServerUpdate,
  VoiceStateUpdate: discord_js.Events.VoiceStateUpdate,
  Warn: discord_js.Events.Warn,
  WebhooksUpdate: discord_js.Events.WebhooksUpdate,
  // #endregion Discord.js base events
  // #region Sapphire events
  // Message commands chain
  /**
   * Emitted when a message is created that was not sent by bots or webhooks.
   * @param {Message} message The created message
   */
  PreMessageParsed: "preMessageParsed",
  /**
   * Emitted when a message is created consisting of only the bot's mention.
   * @param {Message} message The created message
   */
  MentionPrefixOnly: "mentionPrefixOnly",
  /**
   * Emitted when a message is created that does not start with a valid prefix.
   * @param {Message} message The created message
   */
  NonPrefixedMessage: "nonPrefixedMessage",
  /**
   * Emitted when a message is created that does starts with a valid prefix.
   * @param {Message} message The created message
   */
  PrefixedMessage: "prefixedMessage",
  /**
   * Emitted when a message starts with a valid prefix but does not include a command name.
   * @param {UnknownMessageCommandNamePayload} payload
   */
  UnknownMessageCommandName: "unknownMessageCommandName",
  /**
   * Emitted when the name of a sent message command does not match any loaded commands.
   * @param {UnknownMessageCommandPayload} payload The contextual payload
   */
  UnknownMessageCommand: "unknownMessageCommand",
  /**
   * Emitted when a message command is executed but a `messageRun` method is not found.
   * @param {CommandDoesNotHaveMessageCommandHandler} payload The contextual payload
   */
  CommandDoesNotHaveMessageCommandHandler: "commandDoesNotHaveMessageCommandHandler",
  /**
   * Emitted before the `messageRun` method of a command is run.
   * @param {PreMessageCommandRunPayload} payload The contextual payload
   */
  PreMessageCommandRun: "preMessageCommandRun",
  /**
   * Emitted when a precondition denies a message command from being run.
   * @param {UserError} error The error reported by the precondition
   * @param {MessageCommandDeniedPayload} payload The contextual payload
   */
  MessageCommandDenied: "messageCommandDenied",
  /**
   * Emitted when a message command passes all precondition checks, if any.
   * @param {MessageCommandAcceptedPayload} payload The contextual payload
   */
  MessageCommandAccepted: "messageCommandAccepted",
  /**
   * Emitted directly before a message command is run.
   * @param {Message} message The message that executed the command
   * @param {Command} command The command that is being run
   * @param {MessageCommandRunPayload} payload The contextual payload
   */
  MessageCommandRun: "messageCommandRun",
  /**
   * Emitted after a message command runs successfully.
   * @param {MessageCommandSuccessPayload} payload The contextual payload
   */
  MessageCommandSuccess: "messageCommandSuccess",
  /**
   * Emitted after a message command runs unsuccesfully.
   * @param {*} error The error that was thrown
   * @param {MessageCommandErrorPayload} payload The contextual payload
   */
  MessageCommandError: "messageCommandError",
  /**
   * Emitted directly after a message command finished running, regardless of the outcome.
   * @param {Message} message The message that executed the command
   * @param {Command} command The command that finished running
   * @param {MessageCommandFinishPayload} payload The contextual payload
   */
  MessageCommandFinish: "messageCommandFinish",
  /**
   * Emitted after the bot unsuccessfully tried to start typing when a command is executed.
   * @param error The error that was thrown
   * @param payload The contextual payload
   */
  MessageCommandTypingError: "messageCommandTypingError",
  // Listener errors
  /**
   * Emitted when an error is encountered when executing a listener.
   * @param {*} error The error that was thrown
   * @param {ListenerErrorPayload} payload The contextual payload
   */
  ListenerError: "listenerError",
  // Registry errors
  /**
   * Emitted when an error is encountered when handling the command application command registry.
   * @param {*} error The error that was thrown
   * @param {Command} command The command whose registry caused the error
   */
  CommandApplicationCommandRegistryError: "commandApplicationCommandRegistryError",
  /**
   * Emitted when the application command registries are being initialized.
   */
  ApplicationCommandRegistriesInitialising: "applicationCommandRegistriesInitialising",
  /**
   * Emitted once the application command registries have been initialized.
   * @param {Map<string, ApplicationCommandRegistry>} registries The initialised registries
   */
  ApplicationCommandRegistriesRegistered: "applicationCommandRegistriesRegistered",
  /**
   * Emitted when an error is encountered when handling the command registries in bulk overwrite mode.
   * @param {*} error The error that was thrown
   * @param {string|null} guildId The guild id where the error was thrown
   */
  ApplicationCommandRegistriesBulkOverwriteError: "applicationCommandRegistriesBulkOverwriteError",
  // Piece store?
  /**
   * Emitted after a piece is loaded.
   * @param {Store<Piece>} store The store in which the piece belongs to
   * @param {Piece} piece The piece that was loaded
   */
  PiecePostLoad: "piecePostLoad",
  /**
   * Emitted when a piece is unloaded.
   * @param {Store<Piece>} store The store in which the piece belongs to
   * @param {Piece} piece The piece that was unloaded
   */
  PieceUnload: "pieceUnload",
  // Plugin
  /**
   * Emitted when a plugin is loaded.
   * @param {PluginHook} hook The plugin hook that was loaded
   * @param {string | undefined} name The name of the plugin, if any
   */
  PluginLoaded: "pluginLoaded",
  // Interaction handlers
  /**
   * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered)
   * Use the {@link option} parameter to determine if `some` or `none` was passed.
   * @param {Option.None | Option.Some<unknown>} option The {@link Option} from the `parse` method.
   * @param {InteractionHandlerParseSuccess} payload The contextual payload
   */
  InteractionHandlerParseSuccess: "interactionHandlerParseSuccess",
  /**
   * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered) and `some` is returned.
   * @param {Option.Some<unknown>} option The {@link Option.Some} from the `parse` method.
   * @param {InteractionHandlerParseSome} payload The contextual payload
   */
  InteractionHandlerParseSome: "interactionHandlerParseSome",
  /**
   * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered) and `none` is returned.
   * @param {Option.None} option The {@link Option.None} from the `parse` method.
   * @param {InteractionHandlerParseNone} payload The contextual payload
   */
  InteractionHandlerParseNone: "interactionHandlerParseNone",
  /**
   * Emitted when the `parse` method of an interaction handler encounters an error.
   * @param {*} error The error that was encountered
   * @param {InteractionHandlerParseError} payload The contextual payload
   */
  InteractionHandlerParseError: "interactionHandlerParseError",
  /**
   * Emitted when an error is encountered when executing an interaction handler.
   * @param {*} error The error that was encountered
   * @param {InteractionHandlerError} payload The contextual payload
   */
  InteractionHandlerError: "interactionHandlerError",
  // Autocomplete interaction
  /**
   * Emitted when an autocomplete interaction is recieved.
   * @param {AutocompleteInteraction} interaction The interaction that was recieved
   */
  PossibleAutocompleteInteraction: "possibleAutocompleteInteraction",
  /**
   * Emitted after an autocomplete interaction handler runs successfully.
   * @param {AutocompleteInteractionPayload} payload The contextual payload
   */
  CommandAutocompleteInteractionSuccess: "commandAutocompleteInteractionSuccess",
  /**
   * Emitted when an error is encountered when executing an autocomplete interaction handler.
   * @param {*} error The error that was encountered
   * @param {AutocompleteInteractionPayload} payload The contextual payload
   */
  CommandAutocompleteInteractionError: "commandAutocompleteInteractionError",
  // Chat input command chain
  /**
   * Emitted when a chat input command interaction is recieved.
   * @param {ChatInputCommandInteraction} interaction The interaction that was recieved.
   */
  PossibleChatInputCommand: "possibleChatInputCommand",
  /**
   * Emitted when the name of a sent chat input command does not match any loaded commands.
   * @param {UnknownChatInputCommandPayload} payload The contextual payload
   */
  UnknownChatInputCommand: "unknownChatInputCommand",
  /**
   * Emitted when a chat input command is executed but a `chatInputRun` method is not found.
   * @param {CommandDoesNotHaveChatInputCommandHandlerPayload} payload The contextual payload
   */
  CommandDoesNotHaveChatInputCommandHandler: "commandDoesNotHaveChatInputCommandHandler",
  /**
   * Emitted before the `chatInputRun` method of a command is run.
   * @param {PreChatInputCommandRunPayload} payload The contextual payload
   */
  PreChatInputCommandRun: "preChatInputCommandRun",
  /**
   * Emitted when a precondition denies a chat input command from being run.
   * @param {UserError} error The error reported by the precondition
   * @param {ChatInputCommandDeniedPayload} payload The contextual payload
   */
  ChatInputCommandDenied: "chatInputCommandDenied",
  /**
   * Emitted when a chat input command passes all precondition checks, if any.
   * @param {ChatInputCommandAcceptedPayload} payload The contextual payload
   */
  ChatInputCommandAccepted: "chatInputCommandAccepted",
  /**
   * Emitted directly before a chat input command is run.
   * @param {ChatInputCommandInteraction} interaction The interaction that executed the command
   * @param {ChatInputCommand} command The command that is being run
   * @param {ChatInputCommandRunPayload} payload The contextual payload
   */
  ChatInputCommandRun: "chatInputCommandRun",
  /**
   * Emitted after a chat input command runs successfully.
   * @param {ChatInputCommandSuccessPayload} payload The contextual payload
   */
  ChatInputCommandSuccess: "chatInputCommandSuccess",
  /**
   * Emitted after a chat input command runs unsuccesfully.
   * @param {*} error The error that was thrown
   * @param {ChatInputCommandErrorPayload} payload The contextual payload
   */
  ChatInputCommandError: "chatInputCommandError",
  /**
   * Emitted directly after a chat input command finished running, regardless of the outcome.
   * @param {Interaction} interaction The interaction that executed the command
   * @param {ChatInputCommand} command The command that finished running
   * @param {ChatInputCommandFinishPayload} payload The contextual payload
   */
  ChatInputCommandFinish: "chatInputCommandFinish",
  // Context menu chain
  /**
   * Emitted when a context menu interaction is recieved.
   * @param {ContextMenuCommandInteraction} interaction The interaction that was recieved.
   */
  PossibleContextMenuCommand: "possibleContextMenuCommand",
  /**
   * Emitted when the name of a sent context menu command does not match any loaded commands.
   * @param {UnknownContextMenuCommandPayload} payload The contextual payload
   */
  UnknownContextMenuCommand: "unknownContextMenuCommand",
  /**
   * Emitted when a chat input command is executed but a `contextMenuRun` method is not found.
   * @param {CommandDoesNotHaveContextMenuCommandHandlerPayload} payload The contextual payload
   */
  CommandDoesNotHaveContextMenuCommandHandler: "commandDoesNotHaveContextMenuCommandHandler",
  /**
   * Emitted before the `contextMenuRun` method of a command is run.
   * @param {PreContextMenuCommandRunPayload} payload The contextual payload
   */
  PreContextMenuCommandRun: "preContextMenuCommandRun",
  /**
   * Emitted when a precondition denies a context menu command from being run.
   * @param {UserError} error The error reported by the precondition
   * @param {ContextMenuCommandDeniedPayload} payload The contextual payload
   */
  ContextMenuCommandDenied: "contextMenuCommandDenied",
  /**
   * Emitted when a context menu command passes all precondition checks, if any.
   * @param {ContextMenuCommandAcceptedPayload} payload The contextual payload
   */
  ContextMenuCommandAccepted: "contextMenuCommandAccepted",
  /**
   * Emitted directly before a context menu command is run.
   * @param {ContextMenuCommandInteraction} interaction The interaction that executed the command
   * @param {ContextMenuCommand} command The command that is being run
   * @param {ContextMenuCommandRunPayload} payload The contextual payload
   */
  ContextMenuCommandRun: "contextMenuCommandRun",
  /**
   * Emitted after a context menu command runs successfully.
   * @param {ContextMenuCommandSuccessPayload} payload The contextual payload
   */
  ContextMenuCommandSuccess: "contextMenuCommandSuccess",
  /**
   * Emitted after a context menu command runs unsuccesfully.
   * @param {*} error The error that was thrown
   * @param {ContextMenuCommandErrorPayload} payload The contextual payload
   */
  ContextMenuCommandError: "contextMenuCommandError",
  /**
   * Emitted directly after a context menu command finished running, regardless of the outcome.
   * @param {Interaction} interaction The interaction that executed the command
   * @param {ContextMenuCommand} command The command that finished running
   * @param {ContextMenuCommandFinishPayload} payload The contextual payload
   */
  ContextMenuCommandFinish: "contextMenuCommandFinish"
  // #endregion Sapphire events
};

exports.Events = Events;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Events.cjs.map