{"version":3,"sources":["../../../../src/lib/structures/Listener.ts"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa;AACtB,SAAS,cAAc;AAGvB,SAAS,cAAc;AAyChB,IAAe,YAAf,MAAe,kBAAkH,MAGtI;AAAA,EAqBM,YAAY,SAAiC,UAAmB,CAAC,GAAc;AACrF,UAAM,SAAS,OAAO;AAEtB,SAAK,UACJ,OAAO,QAAQ,YAAY,cACxB,KAAK,UAAU,UACd,OAAO,QAAQ,YAAY,WACzB,QAAQ,IAAI,KAAK,UAAU,QAAQ,QAAQ,OAAO,IAClD,QAAQ,YAA6B;AAC5C,SAAK,QAAQ,QAAQ,SAAS,KAAK;AACnC,SAAK,OAAO,QAAQ,QAAQ;AAE5B,SAAK,YAAY,KAAK,WAAW,KAAK,QAAS,KAAK,OAAO,KAAK,SAAS,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,IAAK;AAG9G,QAAI,KAAK,YAAY,QAAQ,KAAK,cAAc;AAAM,WAAK,UAAU;AAAA,EACtE;AAAA,EAIgB,SAAuB;AACtC,WAAO;AAAA,MACN,GAAG,MAAM,OAAO;AAAA,MAChB,MAAM,KAAK;AAAA,MACX,OAAO,KAAK;AAAA,IACb;AAAA,EACD;AAAA,EAEA,MAAc,QAAQ,MAAiB;AACtC,UAAM,SAAS,MAAM,OAAO,UAAU,MAAM,KAAK,IAAI,GAAI,IAAmE,CAAC;AAC7H,WAAO,WAAW,CAAC,UAAU,KAAK,UAAU,OAAO,KAAK,OAAO,eAAe,OAAO,EAAE,OAAO,KAAK,CAAC,CAAC;AAAA,EACtG;AAAA,EAEA,MAAc,YAAY,MAAiB;AAC1C,UAAM,KAAK,KAAK,GAAG,IAAI;AACvB,UAAM,KAAK,OAAO;AAAA,EACnB;AACD;AA1DE;AAHK,IAAe,WAAf","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Client, ClientEvents } from 'discord.js';\nimport type { EventEmitter } from 'node:events';\nimport { Events } from '../types/Events';\n\n/**\n * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In\n * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.\n *\n * @example\n * ```typescript\n * // TypeScript:\n * import { Events, Listener } from '@sapphire/framework';\n *\n * // Define a class extending `Listener`, then export it.\n * // NOTE: You can use `export default` or `export =` too.\n * export class CoreListener extends Listener<typeof Events.ClientReady> {\n *   public constructor(context: Listener.LoaderContext) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   public run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n *\n * @example\n * ```javascript\n * // JavaScript:\n * const { Events, Listener } = require('@sapphire/framework');\n *\n * // Define a class extending `Listener`, then export it.\n * module.exports = class CoreListener extends Listener {\n *   constructor(context) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n */\nexport abstract class Listener<E extends keyof ClientEvents | symbol = '', Options extends Listener.Options = Listener.Options> extends Piece<\n\tOptions,\n\t'listeners'\n> {\n\t/**\n\t * The emitter, if any.\n\t * @since 2.0.0\n\t */\n\tpublic readonly emitter: EventEmitter | null;\n\n\t/**\n\t * The name of the event the listener listens to.\n\t * @since 2.0.0\n\t */\n\tpublic readonly event: string | symbol;\n\n\t/**\n\t * Whether the listener will be unloaded after the first run.\n\t * @since 2.0.0\n\t */\n\tpublic readonly once: boolean;\n\n\tprivate _listener: ((...args: any[]) => void) | null;\n\n\tpublic constructor(context: Listener.LoaderContext, options: Options = {} as Options) {\n\t\tsuper(context, options);\n\n\t\tthis.emitter =\n\t\t\ttypeof options.emitter === 'undefined'\n\t\t\t\t? this.container.client\n\t\t\t\t: (typeof options.emitter === 'string'\n\t\t\t\t\t\t? (Reflect.get(this.container.client, options.emitter) as EventEmitter)\n\t\t\t\t\t\t: (options.emitter as EventEmitter)) ?? null;\n\t\tthis.event = options.event ?? this.name;\n\t\tthis.once = options.once ?? false;\n\n\t\tthis._listener = this.emitter && this.event ? (this.once ? this._runOnce.bind(this) : this._run.bind(this)) : null;\n\n\t\t// If there's no emitter or no listener, disable:\n\t\tif (this.emitter === null || this._listener === null) this.enabled = false;\n\t}\n\n\tpublic abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;\n\n\tpublic override toJSON(): ListenerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tonce: this.once,\n\t\t\tevent: this.event\n\t\t};\n\t}\n\n\tprivate async _run(...args: unknown[]) {\n\t\tconst result = await Result.fromAsync(() => this.run(...(args as E extends keyof ClientEvents ? ClientEvents[E] : unknown[])));\n\t\tresult.inspectErr((error) => this.container.client.emit(Events.ListenerError, error, { piece: this }));\n\t}\n\n\tprivate async _runOnce(...args: unknown[]) {\n\t\tawait this._run(...args);\n\t\tawait this.unload();\n\t}\n}\n\nexport interface ListenerOptions extends Piece.Options {\n\treadonly emitter?: keyof Client | EventEmitter;\n\treadonly event?: string | symbol;\n\treadonly once?: boolean;\n}\n\nexport interface ListenerJSON extends Piece.JSON {\n\tevent: string | symbol;\n\tonce: boolean;\n}\n\nexport namespace Listener {\n\texport type Options = ListenerOptions;\n\texport type JSON = ListenerJSON;\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'listeners'>;\n}\n"]}