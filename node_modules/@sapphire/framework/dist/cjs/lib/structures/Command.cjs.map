{"version":3,"sources":["../../../../src/lib/structures/Command.ts"],"names":[],"mappings":"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","sourcesContent":["import { ArgumentStream, Lexer, Parser, type IUnorderedStrategy } from '@sapphire/lexure';\nimport { AliasPiece } from '@sapphire/pieces';\nimport { isFunction, isNullish, isObject, type Awaitable } from '@sapphire/utilities';\nimport { ChannelType, ChatInputCommandInteraction, ContextMenuCommandInteraction, type AutocompleteInteraction, type Message } from 'discord.js';\nimport { Args } from '../parsers/Args';\nimport {\n\tparseConstructorPreConditionsCooldown,\n\tparseConstructorPreConditionsNsfw,\n\tparseConstructorPreConditionsRequiredClientPermissions,\n\tparseConstructorPreConditionsRequiredUserPermissions,\n\tparseConstructorPreConditionsRunIn\n} from '../precondition-resolvers/index';\nimport type {\n\tAutocompleteCommand,\n\tChatInputCommand,\n\tCommandJSON,\n\tCommandOptions,\n\tCommandOptionsRunType,\n\tCommandRunInUnion,\n\tCommandSpecificRunIn,\n\tContextMenuCommand,\n\tDetailedDescriptionCommand,\n\tMessageCommand\n} from '../types/CommandTypes';\nimport { RegisterBehavior } from '../types/Enums';\nimport { acquire, getDefaultBehaviorWhenNotIdentical, handleBulkOverwrite } from '../utils/application-commands/ApplicationCommandRegistries';\nimport type { ApplicationCommandRegistry } from '../utils/application-commands/ApplicationCommandRegistry';\nimport { getNeededRegistryParameters } from '../utils/application-commands/getNeededParameters';\nimport { emitPerRegistryError } from '../utils/application-commands/registriesErrors';\nimport { PreconditionContainerArray } from '../utils/preconditions/PreconditionContainerArray';\nimport { FlagUnorderedStrategy } from '../utils/strategies/FlagUnorderedStrategy';\n\nconst ChannelTypes = Object.values(ChannelType).filter((type) => typeof type === 'number') as readonly ChannelType[];\nconst GuildChannelTypes = ChannelTypes.filter((type) => type !== ChannelType.DM && type !== ChannelType.GroupDM) as readonly ChannelType[];\n\nexport class Command<PreParseReturn = Args, Options extends Command.Options = Command.Options> extends AliasPiece<Options, 'commands'> {\n\t/**\n\t * A basic summary about the command\n\t * @since 1.0.0\n\t */\n\tpublic description: string;\n\n\t/**\n\t * The preconditions to be run.\n\t * @since 1.0.0\n\t */\n\tpublic preconditions: PreconditionContainerArray;\n\n\t/**\n\t * Longer version of command's summary and how to use it\n\t * @since 1.0.0\n\t */\n\tpublic detailedDescription: DetailedDescriptionCommand;\n\n\t/**\n\t * The full category for the command, can be overridden by setting the {@link Command.Options.fullCategory} option.\n\t *\n\t * If {@link Command.Options.fullCategory} is not set, then:\n\t * - If the command is loaded from the file system, then this is the command's location in file system relative to\n\t *   the commands folder. For example, if you have a command located at `commands/General/Information/info.ts` then\n\t *   this property will be `['General', 'Info']`.\n\t * - If the command is virtual, then this will be `[]`.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic readonly fullCategory: readonly string[];\n\n\t/**\n\t * The strategy to use for the lexer.\n\t * @since 1.0.0\n\t */\n\tpublic strategy: IUnorderedStrategy;\n\n\t/**\n\t * If {@link SapphireClient.typing} is true, it can be overridden for a specific command using this property, set via its options.\n\t * Otherwise, this property will be ignored.\n\t * @default true\n\t */\n\tpublic typing: boolean;\n\n\t/**\n\t * The application command registry associated with this command.\n\t * @since 3.0.0\n\t */\n\tpublic readonly applicationCommandRegistry = acquire(this.name);\n\n\t/**\n\t * The lexer to be used for command parsing\n\t * @since 1.0.0\n\t * @private\n\t */\n\tprotected lexer: Lexer;\n\n\t/**\n\t * @since 1.0.0\n\t * @param context The context.\n\t * @param options Optional Command settings.\n\t */\n\tpublic constructor(context: Command.LoaderContext, options: Options = {} as Options) {\n\t\tsuper(context, { ...options, name: (options.name ?? context.name).toLowerCase() });\n\t\tthis.description = options.description ?? '';\n\t\tthis.detailedDescription = options.detailedDescription ?? '';\n\t\tthis.strategy = new FlagUnorderedStrategy(options);\n\t\tthis.fullCategory = options.fullCategory ?? this.location.directories;\n\t\tthis.typing = options.typing ?? true;\n\n\t\tthis.lexer = new Lexer({\n\t\t\tquotes: options.quotes ?? [\n\t\t\t\t['\"', '\"'], // Double quotes\n\t\t\t\t['“', '”'], // Fancy quotes (on iOS)\n\t\t\t\t['「', '」'], // Corner brackets (CJK)\n\t\t\t\t['«', '»'] // French quotes (guillemets)\n\t\t\t]\n\t\t});\n\n\t\tif (options.generateDashLessAliases) {\n\t\t\tconst dashLessAliases: string[] = [];\n\t\t\tif (this.name.includes('-')) dashLessAliases.push(this.name.replace(/-/g, ''));\n\t\t\tfor (const alias of this.aliases) if (alias.includes('-')) dashLessAliases.push(alias.replace(/-/g, ''));\n\n\t\t\tthis.aliases = [...this.aliases, ...dashLessAliases];\n\t\t}\n\n\t\tif (options.generateUnderscoreLessAliases) {\n\t\t\tconst underscoreLessAliases: string[] = [];\n\t\t\tif (this.name.includes('_')) underscoreLessAliases.push(this.name.replace(/_/g, ''));\n\t\t\tfor (const alias of this.aliases) if (alias.includes('_')) underscoreLessAliases.push(alias.replace(/_/g, ''));\n\n\t\t\tthis.aliases = [...this.aliases, ...underscoreLessAliases];\n\t\t}\n\n\t\tthis.preconditions = new PreconditionContainerArray(options.preconditions);\n\t\tthis.parseConstructorPreConditions(options);\n\t}\n\n\t/**\n\t * The message pre-parse method. This method can be overridden by plugins to define their own argument parser.\n\t * @param message The message that triggered the command.\n\t * @param parameters The raw parameters as a single string.\n\t * @param context The command-context used in this execution.\n\t */\n\tpublic messagePreParse(message: Message, parameters: string, context: MessageCommand.RunContext): Awaitable<PreParseReturn> {\n\t\tconst parser = new Parser(this.strategy);\n\t\tconst args = new ArgumentStream(parser.run(this.lexer.run(parameters)));\n\t\treturn new Args(message, this as MessageCommand, args, context) as PreParseReturn;\n\t}\n\n\t/**\n\t * The main category for the command, if any.\n\t *\n\t * This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it\n\t * returns `null`.\n\t *\n\t * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.\n\t */\n\tpublic get category(): string | null {\n\t\treturn this.fullCategory.at(0) ?? null;\n\t}\n\n\t/**\n\t * The sub-category for the command, if any.\n\t *\n\t * This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise\n\t * it returns `null`.\n\t *\n\t * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.\n\t */\n\tpublic get subCategory(): string | null {\n\t\treturn this.fullCategory.at(1) ?? null;\n\t}\n\n\t/**\n\t * The parent category for the command.\n\t *\n\t * This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it\n\t * returns `null`.\n\t *\n\t * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.\n\t */\n\tpublic get parentCategory(): string | null {\n\t\treturn this.fullCategory.at(-1) ?? null;\n\t}\n\n\t/**\n\t * Executes the message command's logic.\n\t * @param message The message that triggered the command.\n\t * @param args The value returned by {@link Command.messagePreParse}, by default an instance of {@link Args}.\n\t * @param context The context in which the command was executed.\n\t */\n\tpublic messageRun?(message: Message, args: PreParseReturn, context: MessageCommand.RunContext): Awaitable<unknown>;\n\n\t/**\n\t * Executes the application command's logic.\n\t * @param interaction The interaction that triggered the command.\n\t * @param context The chat input command run context.\n\t */\n\tpublic chatInputRun?(interaction: ChatInputCommandInteraction, context: ChatInputCommand.RunContext): Awaitable<unknown>;\n\n\t/**\n\t * Executes the context menu's logic.\n\t * @param interaction The interaction that triggered the command.\n\t * @param context The context menu command run context.\n\t */\n\tpublic contextMenuRun?(interaction: ContextMenuCommandInteraction, context: ContextMenuCommand.RunContext): Awaitable<unknown>;\n\n\t/**\n\t * Executes the autocomplete logic.\n\t *\n\t * :::tip\n\t *\n\t * You may use this, or alternatively create an {@link InteractionHandler interaction handler} to handle autocomplete interactions.\n\t * Keep in mind that commands take precedence over interaction handlers.\n\t *\n\t * :::\n\t *\n\t * @param interaction The interaction that triggered the autocomplete.\n\t */\n\tpublic autocompleteRun?(interaction: AutocompleteInteraction): Awaitable<unknown>;\n\n\t/**\n\t * Defines the JSON.stringify behavior of the command.\n\t */\n\tpublic override toJSON(): CommandJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tdescription: this.description,\n\t\t\tdetailedDescription: this.detailedDescription,\n\t\t\tcategory: this.category\n\t\t};\n\t}\n\n\t/**\n\t * Registers the application commands that should be handled by this command.\n\t * @param registry This command's registry\n\t */\n\tpublic registerApplicationCommands?(registry: ApplicationCommandRegistry): Awaitable<void>;\n\n\t/**\n\t * Type-guard that ensures the command supports message commands by checking if the handler for it is present\n\t */\n\tpublic supportsMessageCommands(): this is MessageCommand {\n\t\treturn isFunction(Reflect.get(this, 'messageRun'));\n\t}\n\n\t/**\n\t * Type-guard that ensures the command supports chat input commands by checking if the handler for it is present\n\t */\n\tpublic supportsChatInputCommands(): this is ChatInputCommand {\n\t\treturn isFunction(Reflect.get(this, 'chatInputRun'));\n\t}\n\n\t/**\n\t * Type-guard that ensures the command supports context menu commands by checking if the handler for it is present\n\t */\n\tpublic supportsContextMenuCommands(): this is ContextMenuCommand {\n\t\treturn isFunction(Reflect.get(this, 'contextMenuRun'));\n\t}\n\n\t/**\n\t * Type-guard that ensures the command supports handling autocomplete interactions by checking if the handler for it is present\n\t */\n\tpublic supportsAutocompleteInteractions(): this is AutocompleteCommand {\n\t\treturn isFunction(Reflect.get(this, 'autocompleteRun'));\n\t}\n\n\tpublic override async reload() {\n\t\t// Remove the aliases from the command store\n\t\tconst { store } = this;\n\t\tconst registry = this.applicationCommandRegistry;\n\n\t\tfor (const nameOrId of registry.chatInputCommands) {\n\t\t\tconst aliasedPiece = store.aliases.get(nameOrId);\n\t\t\tif (aliasedPiece === this) {\n\t\t\t\tstore.aliases.delete(nameOrId);\n\t\t\t}\n\t\t}\n\n\t\tfor (const nameOrId of registry.contextMenuCommands) {\n\t\t\tconst aliasedPiece = store.aliases.get(nameOrId);\n\t\t\tif (aliasedPiece === this) {\n\t\t\t\tstore.aliases.delete(nameOrId);\n\t\t\t}\n\t\t}\n\n\t\t// Reset the registry's contents\n\t\tregistry.chatInputCommands.clear();\n\t\tregistry.contextMenuCommands.clear();\n\t\tregistry.guildIdsToFetch.clear();\n\t\tregistry['apiCalls'].length = 0;\n\n\t\t// Reload the command\n\t\tawait super.reload();\n\n\t\t// Get the command from the store to get any changes from the reload\n\t\tconst updatedPiece = store.get(this.name);\n\n\t\t// This likely shouldn't happen but not worth continuing if the piece is somehow no longer available\n\t\tif (!updatedPiece) return;\n\n\t\tconst updatedRegistry = updatedPiece.applicationCommandRegistry;\n\n\t\tif (updatedPiece.registerApplicationCommands) {\n\t\t\t// Rerun the registry\n\t\t\ttry {\n\t\t\t\tawait updatedPiece.registerApplicationCommands(updatedRegistry);\n\t\t\t} catch (err) {\n\t\t\t\temitPerRegistryError(err, updatedPiece);\n\t\t\t\t// No point on continuing\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If there are no API calls to execute then exit out early\n\t\tif (!updatedRegistry['apiCalls'].length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the default behavior is set to bulk overwrite, handle it as such and return.\n\t\tif (getDefaultBehaviorWhenNotIdentical() === RegisterBehavior.BulkOverwrite) {\n\t\t\tawait handleBulkOverwrite(store, this.container.client.application!.commands);\n\t\t\treturn;\n\t\t}\n\n\t\t// Re-initialize the store and the API data (insert in the store handles the register method)\n\t\tconst { applicationCommands, globalCommands, guildCommands } = await getNeededRegistryParameters(updatedRegistry.guildIdsToFetch);\n\n\t\t// Handle the API calls\n\t\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\t\tawait updatedRegistry['runAPICalls'](applicationCommands, globalCommands, guildCommands);\n\n\t\t// Re-set the aliases\n\t\tfor (const nameOrId of updatedRegistry.chatInputCommands) {\n\t\t\tstore.aliases.set(nameOrId, updatedPiece);\n\t\t}\n\n\t\tfor (const nameOrId of updatedRegistry.contextMenuCommands) {\n\t\t\tstore.aliases.set(nameOrId, updatedPiece);\n\t\t}\n\t}\n\n\t/**\n\t * Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},\n\t * {@link Command#parseConstructorPreConditionsNsfw},\n\t * {@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and\n\t * {@link Command#parseConstructorPreConditionsCooldown}.\n\t * @since 2.0.0\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditions(options: Command.Options): void {\n\t\tthis.parseConstructorPreConditionsRunIn(options);\n\t\tthis.parseConstructorPreConditionsNsfw(options);\n\t\tthis.parseConstructorPreConditionsRequiredClientPermissions(options);\n\t\tthis.parseConstructorPreConditionsRequiredUserPermissions(options);\n\t\tthis.parseConstructorPreConditionsCooldown(options);\n\t}\n\n\t/**\n\t * Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditionsNsfw(options: Command.Options) {\n\t\tparseConstructorPreConditionsNsfw(options.nsfw, this.preconditions);\n\t}\n\n\t/**\n\t * Appends the `RunIn` precondition based on the values passed, defaulting to `null`, which doesn't add a\n\t * precondition.\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditionsRunIn(options: Command.Options) {\n\t\tparseConstructorPreConditionsRunIn(options.runIn, this.resolveConstructorPreConditionsRunType.bind(this), this.preconditions);\n\t}\n\n\t/**\n\t * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a\n\t * non-zero bitfield.\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditionsRequiredClientPermissions(options: Command.Options) {\n\t\tparseConstructorPreConditionsRequiredClientPermissions(options.requiredClientPermissions, this.preconditions);\n\t}\n\n\t/**\n\t * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a\n\t * non-zero bitfield.\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditionsRequiredUserPermissions(options: Command.Options) {\n\t\tparseConstructorPreConditionsRequiredUserPermissions(options.requiredUserPermissions, this.preconditions);\n\t}\n\n\t/**\n\t * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and\n\t * {@link Command.Options.cooldownDelay} are both non-zero.\n\t * @param options The command options given from the constructor.\n\t */\n\tprotected parseConstructorPreConditionsCooldown(options: Command.Options) {\n\t\tparseConstructorPreConditionsCooldown(\n\t\t\tthis,\n\t\t\toptions.cooldownLimit,\n\t\t\toptions.cooldownDelay,\n\t\t\toptions.cooldownScope,\n\t\t\toptions.cooldownFilteredUsers,\n\t\t\tthis.preconditions\n\t\t);\n\t}\n\n\t/**\n\t * Resolves the {@link Command.Options.runIn} option into a {@link Command.RunInTypes} array.\n\t * @param types The types to resolve.\n\t * @returns The resolved types, or `null` if no types were resolved.\n\t */\n\tprotected resolveConstructorPreConditionsRunType(types: CommandRunInUnion): readonly ChannelType[] | null {\n\t\tif (isNullish(types)) return null;\n\t\tif (typeof types === 'number') return [types];\n\t\tif (typeof types === 'string') {\n\t\t\tswitch (types) {\n\t\t\t\tcase 'DM':\n\t\t\t\t\treturn [ChannelType.DM];\n\t\t\t\tcase 'GUILD_TEXT':\n\t\t\t\t\treturn [ChannelType.GuildText];\n\t\t\t\tcase 'GUILD_VOICE':\n\t\t\t\t\treturn [ChannelType.GuildVoice];\n\t\t\t\tcase 'GUILD_NEWS':\n\t\t\t\t\treturn [ChannelType.GuildAnnouncement];\n\t\t\t\tcase 'GUILD_NEWS_THREAD':\n\t\t\t\t\treturn [ChannelType.AnnouncementThread];\n\t\t\t\tcase 'GUILD_PUBLIC_THREAD':\n\t\t\t\t\treturn [ChannelType.PublicThread];\n\t\t\t\tcase 'GUILD_PRIVATE_THREAD':\n\t\t\t\t\treturn [ChannelType.PrivateThread];\n\t\t\t\tcase 'GUILD_ANY':\n\t\t\t\t\treturn GuildChannelTypes;\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If there's no channel it can run on, throw an error:\n\t\tif (types.length === 0) {\n\t\t\tthrow new Error(`${this.constructor.name}[${this.name}]: \"runIn\" was specified as an empty array.`);\n\t\t}\n\n\t\tif (types.length === 1) {\n\t\t\treturn this.resolveConstructorPreConditionsRunType(types[0]);\n\t\t}\n\n\t\tconst resolved = new Set<ChannelType>();\n\t\tfor (const typeResolvable of types) {\n\t\t\tfor (const type of this.resolveConstructorPreConditionsRunType(typeResolvable) ?? []) resolved.add(type);\n\t\t}\n\n\t\t// If all types were resolved, optimize to null:\n\t\tif (resolved.size === ChannelTypes.length) return null;\n\n\t\t// Return the resolved types in ascending order:\n\t\treturn [...resolved].sort((a, b) => a - b);\n\t}\n\n\tpublic static runInTypeIsSpecificsObject(types: Command.Options['runIn']): types is CommandSpecificRunIn {\n\t\tif (!isObject(types)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst specificTypes = types as CommandSpecificRunIn;\n\t\treturn Boolean(specificTypes.chatInputRun || specificTypes.messageRun || specificTypes.contextMenuRun);\n\t}\n}\n\nexport namespace Command {\n\texport type Options = CommandOptions;\n\texport type JSON = CommandJSON;\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = AliasPiece.LoaderContext<'commands'>;\n\texport type RunInTypes = CommandOptionsRunType;\n\texport type RunInUnion = CommandRunInUnion;\n\texport type SpecificRunIn = CommandSpecificRunIn;\n\texport type ChatInputCommandInteraction<Cached extends import('discord.js').CacheType = import('discord.js').CacheType> =\n\t\timport('discord.js').ChatInputCommandInteraction<Cached>;\n\texport type ContextMenuCommandInteraction<Cached extends import('discord.js').CacheType = import('discord.js').CacheType> =\n\t\timport('discord.js').ContextMenuCommandInteraction<Cached>;\n\texport type AutocompleteInteraction<Cached extends import('discord.js').CacheType = import('discord.js').CacheType> =\n\t\timport('discord.js').AutocompleteInteraction<Cached>;\n\texport type Registry = ApplicationCommandRegistry;\n}\n"]}