{"version":3,"sources":["../../../../src/lib/resolvers/message.ts"],"names":[],"mappings":";;;;AAAA,SAAS,qBAAqB,kBAAkB,sBAAsB;AACtE;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OAIM;AACP,SAAS,iBAAiB;AAC1B,SAAS,cAAc;AAEvB,SAAS,2BAAoE;AAC7E,SAAS,mBAAmB;AAuB5B,eAAsB,eAAe,WAAmB,SAA6F;AACpJ,QAAM,UACJ,MAAM,YAAY,WAAW,OAAO,KACpC,MAAM,cAAc,WAAW,OAAO,KACtC,MAAM,2BAA2B,WAAW,OAAO;AAErD,MAAI,SAAS;AACZ,WAAO,OAAO,GAAG,OAAO;AAAA,EACzB;AAEA,SAAO,OAAO,IAAI,YAAY,oBAAoB;AACnD;AAXsB;AAatB,SAAS,YAAY,WAAmB,SAA4D;AACnG,MAAI,CAAC,eAAe,KAAK,SAAS,KAAK,eAAe,QAAQ,qBAAqB,OAAO,GAAG;AAC5F,WAAO;AAAA,EACR;AAEA,MAAI,QAAQ,WAAW,CAAC,eAAe,QAAQ,OAAO,GAAG;AACxD,WAAO,QAAQ,QAAQ,SAAS,MAAM,SAAsB;AAAA,EAC7D;AAEA,MAAI,QAAQ,QAAQ,oBAAoB,QAAQ,qBAAqB,OAAO,GAAG;AAC9E,eAAW,WAAW,QAAQ,qBAAqB,QAAQ,MAAM,SAAS,MAAM,OAAO,GAAG;AACzF,UAAI,CAAC,mBAAmB,OAAO,KAAK,eAAe,OAAO,GAAG;AAC5D;AAAA,MACD;AAEA,YAAM,UAAU,QAAQ,SAAS,MAAM,IAAI,SAAS;AACpD,UAAI,SAAS;AACZ,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AAEA,SAAO,QAAQ,qBAAqB,SAAS,SAAS,MAAM,SAAsB,KAAK;AACxF;AAvBS;AAyBT,eAAe,cAAc,WAAmB,SAA0D;AACzG,MAAI,CAAC,QAAQ,qBAAqB,OAAO;AACxC,WAAO;AAAA,EACR;AAEA,QAAM,UAAU,iBAAiB,KAAK,SAAS;AAC/C,MAAI,CAAC,SAAS;AACb,WAAO;AAAA,EACR;AAEA,QAAM,CAAC,EAAE,SAAS,WAAW,SAAS,IAAI;AAE1C,QAAM,QAAQ,UAAU,OAAO,OAAO,MAAM,IAAI,OAAoB;AACpE,MAAI,UAAU,QAAQ,qBAAqB,OAAO;AACjD,WAAO;AAAA,EACR;AAEA,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA,iBAAiB,QAAQ,oBAAoB,IAAI,QAAQ,qBAAqB,OAAO,QAAQ,qBAAqB;AAAA,EACnH;AACD;AAtBe;AAwBf,eAAe,2BAA2B,WAAmB,SAA0D;AACtH,QAAM,SAAS,oBAAoB,KAAK,SAAS,GAAG;AAEpD,MAAI,CAAC,QAAQ;AACZ,WAAO;AAAA,EACR;AAEA,SAAO;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,iBAAiB,QAAQ,oBAAoB,IAAI,QAAQ,qBAAqB,OAAO,QAAQ,qBAAqB;AAAA,EACnH;AACD;AAZe;AAcf,eAAe,sBAAsB,WAAsB,WAAsB,gBAA+C;AAC/H,QAAM,UAAU,UAAU,OAAO,SAAS,MAAM,IAAI,SAAS;AAC7D,MAAI,CAAC,SAAS;AACb,WAAO;AAAA,EACR;AAEA,MAAI,EAAE,cAAc,OAAO,KAAK,cAAc,OAAO,IAAI;AACxD,WAAO;AAAA,EACR;AAEA,MAAI,CAAC,QAAQ,UAAU;AACtB,WAAO;AAAA,EACR;AAEA,MAAI,CAAC,QAAQ,eAAe,cAAc,GAAG,IAAI,oBAAoB,WAAW,GAAG;AAClF,WAAO;AAAA,EACR;AAEA,SAAO,QAAQ,SAAS,MAAM,SAAS;AACxC;AAnBe","sourcesContent":["import { ChannelMessageRegex, MessageLinkRegex, SnowflakeRegex } from '@sapphire/discord-utilities';\nimport {\n\tisAnyInteraction,\n\tisGuildBasedChannel,\n\tisNewsChannel,\n\tisStageChannel,\n\tisTextBasedChannel,\n\tisTextChannel,\n\ttype AnyInteraction,\n\ttype GuildBasedChannelTypes,\n\ttype TextBasedChannelTypes\n} from '@sapphire/discord.js-utilities';\nimport { container } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport { PermissionFlagsBits, type Message, type Snowflake, type User } from 'discord.js';\nimport { Identifiers } from '../errors/Identifiers';\n\n/**\n * Options to resolve a message from a string, given a certain context.\n */\nexport interface MessageResolverOptions {\n\t/**\n\t * Channel to resolve the message in.\n\t * @default message.channel\n\t */\n\tchannel?: TextBasedChannelTypes;\n\t/**\n\t * Base {@link Message} or {@link AnyInteraction} to resolve the message from (e.g. pick the channel if not given).\n\t */\n\tmessageOrInteraction: Message | AnyInteraction;\n\t/**\n\t * Whether to scan the entire guild cache for the message.\n\t * If channel is given with this option, this option is ignored.\n\t * @default false\n\t */\n\tscan?: boolean;\n}\n\nexport async function resolveMessage(parameter: string, options: MessageResolverOptions): Promise<Result<Message, Identifiers.ArgumentMessageError>> {\n\tconst message =\n\t\t(await resolveById(parameter, options)) ??\n\t\t(await resolveByLink(parameter, options)) ??\n\t\t(await resolveByChannelAndMessage(parameter, options));\n\n\tif (message) {\n\t\treturn Result.ok(message);\n\t}\n\n\treturn Result.err(Identifiers.ArgumentMessageError);\n}\n\nfunction resolveById(parameter: string, options: MessageResolverOptions): Awaitable<Message | null> {\n\tif (!SnowflakeRegex.test(parameter) || isStageChannel(options.messageOrInteraction.channel)) {\n\t\treturn null;\n\t}\n\n\tif (options.channel && !isStageChannel(options.channel)) {\n\t\treturn options.channel.messages.fetch(parameter as Snowflake);\n\t}\n\n\tif (options.scan && isGuildBasedChannel(options.messageOrInteraction.channel)) {\n\t\tfor (const channel of options.messageOrInteraction.channel.guild.channels.cache.values()) {\n\t\t\tif (!isTextBasedChannel(channel) || isStageChannel(channel)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst message = channel.messages.cache.get(parameter);\n\t\t\tif (message) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn options.messageOrInteraction.channel?.messages.fetch(parameter as Snowflake) ?? null;\n}\n\nasync function resolveByLink(parameter: string, options: MessageResolverOptions): Promise<Message | null> {\n\tif (!options.messageOrInteraction.guild) {\n\t\treturn null;\n\t}\n\n\tconst matches = MessageLinkRegex.exec(parameter);\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\tconst [, guildId, channelId, messageId] = matches;\n\n\tconst guild = container.client.guilds.cache.get(guildId as Snowflake);\n\tif (guild !== options.messageOrInteraction.guild) {\n\t\treturn null;\n\t}\n\n\treturn getMessageFromChannel(\n\t\tchannelId,\n\t\tmessageId,\n\t\tisAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author\n\t);\n}\n\nasync function resolveByChannelAndMessage(parameter: string, options: MessageResolverOptions): Promise<Message | null> {\n\tconst result = ChannelMessageRegex.exec(parameter)?.groups;\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\treturn getMessageFromChannel(\n\t\tresult.channelId,\n\t\tresult.messageId,\n\t\tisAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author\n\t);\n}\n\nasync function getMessageFromChannel(channelId: Snowflake, messageId: Snowflake, originalAuthor: User): Promise<Message | null> {\n\tconst channel = container.client.channels.cache.get(channelId) as GuildBasedChannelTypes;\n\tif (!channel) {\n\t\treturn null;\n\t}\n\n\tif (!(isNewsChannel(channel) || isTextChannel(channel))) {\n\t\treturn null;\n\t}\n\n\tif (!channel.viewable) {\n\t\treturn null;\n\t}\n\n\tif (!channel.permissionsFor(originalAuthor)?.has(PermissionFlagsBits.ViewChannel)) {\n\t\treturn null;\n\t}\n\n\treturn channel.messages.fetch(messageId);\n}\n"]}