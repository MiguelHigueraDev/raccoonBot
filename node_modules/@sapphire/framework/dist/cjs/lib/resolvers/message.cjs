'use strict';

var discordUtilities = require('@sapphire/discord-utilities');
var discord_jsUtilities = require('@sapphire/discord.js-utilities');
var pieces = require('@sapphire/pieces');
var result = require('@sapphire/result');
var discord_js = require('discord.js');
var Identifiers_cjs = require('../errors/Identifiers.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function resolveMessage(parameter, options) {
  const message = await resolveById(parameter, options) ?? await resolveByLink(parameter, options) ?? await resolveByChannelAndMessage(parameter, options);
  if (message) {
    return result.Result.ok(message);
  }
  return result.Result.err(Identifiers_cjs.Identifiers.ArgumentMessageError);
}
__name(resolveMessage, "resolveMessage");
function resolveById(parameter, options) {
  if (!discordUtilities.SnowflakeRegex.test(parameter) || discord_jsUtilities.isStageChannel(options.messageOrInteraction.channel)) {
    return null;
  }
  if (options.channel && !discord_jsUtilities.isStageChannel(options.channel)) {
    return options.channel.messages.fetch(parameter);
  }
  if (options.scan && discord_jsUtilities.isGuildBasedChannel(options.messageOrInteraction.channel)) {
    for (const channel of options.messageOrInteraction.channel.guild.channels.cache.values()) {
      if (!discord_jsUtilities.isTextBasedChannel(channel) || discord_jsUtilities.isStageChannel(channel)) {
        continue;
      }
      const message = channel.messages.cache.get(parameter);
      if (message) {
        return message;
      }
    }
  }
  return options.messageOrInteraction.channel?.messages.fetch(parameter) ?? null;
}
__name(resolveById, "resolveById");
async function resolveByLink(parameter, options) {
  if (!options.messageOrInteraction.guild) {
    return null;
  }
  const matches = discordUtilities.MessageLinkRegex.exec(parameter);
  if (!matches) {
    return null;
  }
  const [, guildId, channelId, messageId] = matches;
  const guild = pieces.container.client.guilds.cache.get(guildId);
  if (guild !== options.messageOrInteraction.guild) {
    return null;
  }
  return getMessageFromChannel(
    channelId,
    messageId,
    discord_jsUtilities.isAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author
  );
}
__name(resolveByLink, "resolveByLink");
async function resolveByChannelAndMessage(parameter, options) {
  const result = discordUtilities.ChannelMessageRegex.exec(parameter)?.groups;
  if (!result) {
    return null;
  }
  return getMessageFromChannel(
    result.channelId,
    result.messageId,
    discord_jsUtilities.isAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author
  );
}
__name(resolveByChannelAndMessage, "resolveByChannelAndMessage");
async function getMessageFromChannel(channelId, messageId, originalAuthor) {
  const channel = pieces.container.client.channels.cache.get(channelId);
  if (!channel) {
    return null;
  }
  if (!(discord_jsUtilities.isNewsChannel(channel) || discord_jsUtilities.isTextChannel(channel))) {
    return null;
  }
  if (!channel.viewable) {
    return null;
  }
  if (!channel.permissionsFor(originalAuthor)?.has(discord_js.PermissionFlagsBits.ViewChannel)) {
    return null;
  }
  return channel.messages.fetch(messageId);
}
__name(getMessageFromChannel, "getMessageFromChannel");

exports.resolveMessage = resolveMessage;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=message.cjs.map