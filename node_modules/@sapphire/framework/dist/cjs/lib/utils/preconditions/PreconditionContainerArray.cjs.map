{"version":3,"sources":["../../../../../src/lib/utils/preconditions/PreconditionContainerArray.ts"],"names":["PreconditionRunMode","PreconditionRunCondition"],"mappings":";;;;AAAA,SAAS,kBAAsG;AAI/G;AAAA,EACC;AAAA,OAIM;AAEP,SAAS,gCAAgC;AACzC,SAAS,+BAA+B;AAMjC,IAAK,sBAAL,kBAAKA,yBAAL;AAMN,EAAAA,0CAAA;AAOA,EAAAA,0CAAA;AAbW,SAAAA;AAAA,GAAA;AAmBL,IAAK,2BAAL,kBAAKC,8BAAL;AAKN,EAAAA,oDAAA;AAMA,EAAAA,oDAAA;AAXW,SAAAA;AAAA,GAAA;AA+CZ,SAAS,SAAS,OAA2E;AAC5F,SAAO,OAAO,UAAU,YAAY,QAAQ,IAAI,OAAO,MAAM;AAC9D;AAFS;AAuBF,IAAM,8BAAN,MAAM,4BAA6D;AAAA,EAmBlE,YAAY,OAAoC,CAAC,GAAG,SAA4C,MAAM;AAC5G,SAAK,UAAU,CAAC;AAChB,SAAK,eAAe,QAAQ,iBAAiB,cAA+B,aAA8B;AAE1G,QAAI,MAAM,QAAQ,IAAI,GAAG;AACxB,YAAM,SAAS;AAEf,WAAK,OAAO,QAAQ,QAAQ;AAC5B,WAAK,MAAM,MAAM;AAAA,IAClB,OAAO;AACN,YAAM,SAAS;AAEf,WAAK,OAAO,OAAO;AACnB,WAAK,MAAM,OAAO,OAAO;AAAA,IAC1B;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,OAAqC;AAC/C,SAAK,QAAQ,KAAK,KAAK;AACvB,WAAO;AAAA,EACR;AAAA,EAIO,OAAO,OAAwE;AACrF,SAAK,QAAQ,KAAK,iBAAiB,8BAA6B,QAAQ,IAAI,4BAA4B,KAAK,CAAC;AAC9G,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,WAAW,SAAkB,SAAyB,UAA+B,CAAC,GAAgC;AAC5H,WAAO,KAAK,SAAS,qBAClB,KAAK,UAAU,kBAAkB,SAAS,SAAS,KAAK,SAAS,OAAO,IACxE,KAAK,UAAU,gBAAgB,SAAS,SAAS,KAAK,SAAS,OAAO;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,aACN,aACA,SACA,UAA+B,CAAC,GACF;AAC9B,WAAO,KAAK,SAAS,qBAClB,KAAK,UAAU,oBAAoB,aAAa,SAAS,KAAK,SAAS,OAAO,IAC9E,KAAK,UAAU,kBAAkB,aAAa,SAAS,KAAK,SAAS,OAAO;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,eACN,aACA,SACA,UAA+B,CAAC,GACF;AAC9B,WAAO,KAAK,SAAS,qBAClB,KAAK,UAAU,sBAAsB,aAAa,SAAS,KAAK,SAAS,OAAO,IAChF,KAAK,UAAU,oBAAoB,aAAa,SAAS,KAAK,SAAS,OAAO;AAAA,EAClF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,MAAM,SAAsD;AACrE,eAAW,SAAS,SAAS;AAC5B,WAAK;AAAA,QACJ,SAAS,KAAK,IACX,IAAI,4BAA4B,KAAK,IACrC,IAAI,4BAA2B,OAAO,IAAI;AAAA,MAC9C;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAc,YAAoC;AACjD,WAAO,4BAA2B,WAAW,IAAI,KAAK,YAAY;AAAA,EACnE;AA2BD;AAtJ0E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA7D,4BAkJW,aAAa,IAAI,WAA6D;AAAA,EACpG,CAAC,aAA8B,wBAAwB;AAAA,EACvD,CAAC,YAA6B,uBAAuB;AACtD,CAAC;AArJK,IAAM,6BAAN","sourcesContent":["import { Collection, type ChatInputCommandInteraction, type ContextMenuCommandInteraction, type Message } from 'discord.js';\nimport type { PreconditionContext, PreconditionKeys, SimplePreconditionKeys } from '../../structures/Precondition';\nimport type { ChatInputCommand, ContextMenuCommand, MessageCommand } from '../../types/CommandTypes';\nimport type { IPreconditionContainer, PreconditionContainerReturn } from './IPreconditionContainer';\nimport {\n\tPreconditionContainerSingle,\n\ttype PreconditionSingleResolvable,\n\ttype PreconditionSingleResolvableDetails,\n\ttype SimplePreconditionSingleResolvableDetails\n} from './PreconditionContainerSingle';\nimport type { IPreconditionCondition } from './conditions/IPreconditionCondition';\nimport { PreconditionConditionAnd } from './conditions/PreconditionConditionAnd';\nimport { PreconditionConditionOr } from './conditions/PreconditionConditionOr';\n\n/**\n * The run mode for a {@link PreconditionContainerArray}.\n * @since 1.0.0\n */\nexport enum PreconditionRunMode {\n\t/**\n\t * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous\n\t * tasks, but is performance savvy.\n\t * @since 1.0.0\n\t */\n\tSequential,\n\n\t/**\n\t * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have\n\t * completed.\n\t * @since 1.0.0\n\t */\n\tParallel\n}\n\n/**\n * The condition for a {@link PreconditionContainerArray}.\n */\nexport enum PreconditionRunCondition {\n\t/**\n\t * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.\n\t * @since 1.0.0\n\t */\n\tAnd,\n\n\t/**\n\t * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.\n\t * @since 1.0.0\n\t */\n\tOr\n}\n\n/**\n * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the\n * entries can be defined.\n * @since 1.0.0\n */\nexport interface PreconditionArrayResolvableDetails {\n\t/**\n\t * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.\n\t * @since 1.0.0\n\t */\n\tentries: readonly PreconditionEntryResolvable[];\n\n\t/**\n\t * The mode the {@link PreconditionContainerArray} will run.\n\t * @since 1.0.0\n\t */\n\tmode: PreconditionRunMode;\n}\n\n/**\n * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.\n * @since 1.0.0\n */\nexport type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;\n\n/**\n * Defines the data accepted for each entry of the array.\n * @since 1.0.0\n * @seealso {@link PreconditionArrayResolvable}\n * @seealso {@link PreconditionArrayResolvableDetails.entries}\n */\nexport type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;\n\nfunction isSingle(entry: PreconditionEntryResolvable): entry is PreconditionSingleResolvable {\n\treturn typeof entry === 'string' || Reflect.has(entry, 'name');\n}\n\n/**\n * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.\n *\n * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level\n * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).\n *\n * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:\n * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.\n * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.\n * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.\n *\n * In other words, it is identical to doing:\n * ```typescript\n * Connect && (Moderator || (DJ && SongAuthor));\n * ```\n * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),\n * see {@link PreconditionContainerArray.conditions} for more information.\n * @since 1.0.0\n */\nexport class PreconditionContainerArray implements IPreconditionContainer {\n\t/**\n\t * The mode at which this precondition will run.\n\t * @since 1.0.0\n\t */\n\tpublic readonly mode: PreconditionRunMode;\n\n\t/**\n\t * The {@link IPreconditionContainer}s the array holds.\n\t * @since 1.0.0\n\t */\n\tpublic readonly entries: IPreconditionContainer[];\n\n\t/**\n\t * The {@link PreconditionRunCondition} that defines how entries must be handled.\n\t * @since 1.0.0\n\t */\n\tpublic readonly runCondition: PreconditionRunCondition;\n\n\tpublic constructor(data: PreconditionArrayResolvable = [], parent: PreconditionContainerArray | null = null) {\n\t\tthis.entries = [];\n\t\tthis.runCondition = parent?.runCondition === PreconditionRunCondition.And ? PreconditionRunCondition.Or : PreconditionRunCondition.And;\n\n\t\tif (Array.isArray(data)) {\n\t\t\tconst casted = data as readonly PreconditionEntryResolvable[];\n\n\t\t\tthis.mode = parent?.mode ?? PreconditionRunMode.Sequential;\n\t\t\tthis.parse(casted);\n\t\t} else {\n\t\t\tconst casted = data as PreconditionArrayResolvableDetails;\n\n\t\t\tthis.mode = casted.mode;\n\t\t\tthis.parse(casted.entries);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new entry to the array.\n\t * @since 1.0.0\n\t * @param entry The value to add to the entries.\n\t */\n\tpublic add(entry: IPreconditionContainer): this {\n\t\tthis.entries.push(entry);\n\t\treturn this;\n\t}\n\n\tpublic append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;\n\tpublic append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;\n\tpublic append(entry: PreconditionContainerArray | PreconditionSingleResolvable): this {\n\t\tthis.entries.push(entry instanceof PreconditionContainerArray ? entry : new PreconditionContainerSingle(entry));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 1.0.0\n\t * @param message The message that ran this precondition.\n\t * @param command The command the message invoked.\n\t * @param context The context for the message command precondition.\n\t */\n\tpublic messageRun(message: Message, command: MessageCommand, context: PreconditionContext = {}): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.messageSequential(message, command, this.entries, context)\n\t\t\t: this.condition.messageParallel(message, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context The context for the chat input precondition.\n\t */\n\tpublic chatInputRun(\n\t\tinteraction: ChatInputCommandInteraction,\n\t\tcommand: ChatInputCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.chatInputSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.chatInputParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context  The context for the context menu precondition.\n\t */\n\tpublic contextMenuRun(\n\t\tinteraction: ContextMenuCommandInteraction,\n\t\tcommand: ContextMenuCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.contextMenuSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.contextMenuParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Parses the precondition entry resolvables, and adds them to the entries.\n\t * @since 1.0.0\n\t * @param entries The entries to parse.\n\t */\n\tprotected parse(entries: Iterable<PreconditionEntryResolvable>): this {\n\t\tfor (const entry of entries) {\n\t\t\tthis.add(\n\t\t\t\tisSingle(entry) //\n\t\t\t\t\t? new PreconditionContainerSingle(entry)\n\t\t\t\t\t: new PreconditionContainerArray(entry, this)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.\n\t * @since 1.0.0\n\t */\n\tprotected get condition(): IPreconditionCondition {\n\t\treturn PreconditionContainerArray.conditions.get(this.runCondition)!;\n\t}\n\n\t/**\n\t * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then\n\t * inserting {@link IPreconditionCondition}s.\n\t * @since 1.0.0\n\t * @example\n\t * ```typescript\n\t * // Adding more kinds of conditions\n\t *\n\t * // Set the new condition:\n\t * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);\n\t *\n\t * // Augment Sapphire to add the new condition, in case of a JavaScript\n\t * // project, this can be moved to an `Augments.d.ts` (or any other name)\n\t * // file somewhere:\n\t * declare module '@sapphire/framework' {\n\t *   export enum PreconditionRunCondition {\n\t *     Random = 2\n\t *   }\n\t * }\n\t * ```\n\t */\n\tpublic static readonly conditions = new Collection<PreconditionRunCondition, IPreconditionCondition>([\n\t\t[PreconditionRunCondition.And, PreconditionConditionAnd],\n\t\t[PreconditionRunCondition.Or, PreconditionConditionOr]\n\t]);\n}\n"]}