'use strict';

var result = require('@sapphire/result');

// src/lib/utils/preconditions/conditions/PreconditionConditionAnd.ts
var PreconditionConditionAnd = {
  async messageSequential(message, command, entries, context) {
    for (const child of entries) {
      const result = await child.messageRun(message, command, context);
      if (result.isErr())
        return result;
    }
    return result.Result.ok();
  },
  async messageParallel(message, command, entries, context) {
    const results = await Promise.all(entries.map((entry) => entry.messageRun(message, command, context)));
    return results.find((res) => res.isErr()) ?? result.Result.ok();
  },
  async chatInputSequential(interaction, command, entries, context) {
    for (const child of entries) {
      const result = await child.chatInputRun(interaction, command, context);
      if (result.isErr())
        return result;
    }
    return result.Result.ok();
  },
  async chatInputParallel(interaction, command, entries, context) {
    const results = await Promise.all(entries.map((entry) => entry.chatInputRun(interaction, command, context)));
    return results.find((res) => res.isErr()) ?? result.Result.ok();
  },
  async contextMenuSequential(interaction, command, entries, context) {
    for (const child of entries) {
      const result = await child.contextMenuRun(interaction, command, context);
      if (result.isErr())
        return result;
    }
    return result.Result.ok();
  },
  async contextMenuParallel(interaction, command, entries, context) {
    const results = await Promise.all(entries.map((entry) => entry.contextMenuRun(interaction, command, context)));
    return results.find((res) => res.isErr()) ?? result.Result.ok();
  }
};

exports.PreconditionConditionAnd = PreconditionConditionAnd;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=PreconditionConditionAnd.cjs.map