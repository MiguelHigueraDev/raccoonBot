'use strict';

var v10 = require('discord-api-types/v10');
var _shared_cjs = require('./_shared.cjs');
var description_cjs = require('./description.cjs');
var localizations_cjs = require('./localizations.cjs');
var name_cjs = require('./name.cjs');
var autocomplete_cjs = require('./option/autocomplete.cjs');
var minMaxLength_cjs = require('./option/minMaxLength.cjs');
var minMaxValue_cjs = require('./option/minMaxValue.cjs');
var required_cjs = require('./option/required.cjs');
var type_cjs = require('./option/type.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function* reportOptionDifferences({
  option,
  existingOption,
  currentIndex,
  keyPath = /* @__PURE__ */ __name((index) => `options[${index}]`, "keyPath")
}) {
  if (!existingOption) {
    const expectedType = _shared_cjs.optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
    yield {
      key: keyPath(currentIndex),
      expected: `${expectedType} with name ${option.name}`,
      original: "no option present"
    };
    return;
  }
  yield* type_cjs.checkOptionType({
    key: `${keyPath(currentIndex)}.type`,
    originalType: existingOption.type,
    expectedType: option.type
  });
  yield* name_cjs.checkName({
    key: `${keyPath(currentIndex)}.name`,
    oldName: existingOption.name,
    newName: option.name
  });
  const originalLocalizedNames = existingOption.name_localizations;
  const expectedLocalizedNames = option.name_localizations;
  yield* localizations_cjs.checkLocalizations({
    localeMapName: `${keyPath(currentIndex)}.nameLocalizations`,
    localePresentMessage: "localized names",
    localeMissingMessage: "no localized names",
    originalLocalizedDescriptions: originalLocalizedNames,
    expectedLocalizedDescriptions: expectedLocalizedNames
  });
  yield* description_cjs.checkDescription({
    key: `${keyPath(currentIndex)}.description`,
    oldDescription: existingOption.description,
    newDescription: option.description
  });
  const originalLocalizedDescriptions = existingOption.description_localizations;
  const expectedLocalizedDescriptions = option.description_localizations;
  yield* localizations_cjs.checkLocalizations({
    localeMapName: `${keyPath(currentIndex)}.descriptionLocalizations`,
    localePresentMessage: "localized descriptions",
    localeMissingMessage: "no localized descriptions",
    originalLocalizedDescriptions,
    expectedLocalizedDescriptions
  });
  yield* required_cjs.checkOptionRequired({
    key: `${keyPath(currentIndex)}.required`,
    oldRequired: existingOption.required,
    newRequired: option.required
  });
  if (_shared_cjs.subcommandTypes.includes(existingOption.type) && _shared_cjs.subcommandTypes.includes(option.type)) {
    const castedExisting = existingOption;
    const castedExpected = option;
    if (castedExisting.type === v10.ApplicationCommandOptionType.SubcommandGroup && castedExpected.type === v10.ApplicationCommandOptionType.SubcommandGroup) {
      for (const [subcommandIndex, subcommandOption] of castedExpected.options.entries()) {
        yield* reportOptionDifferences({
          currentIndex: subcommandIndex,
          option: subcommandOption,
          existingOption: castedExisting.options?.[subcommandIndex],
          keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
        });
      }
    } else if (castedExisting.type === v10.ApplicationCommandOptionType.Subcommand && castedExpected.type === v10.ApplicationCommandOptionType.Subcommand) {
      yield* handleSubcommandOptions({
        expectedOptions: castedExpected.options,
        existingOptions: castedExisting.options,
        currentIndex,
        keyPath
      });
    }
  }
  if (_shared_cjs.hasMinMaxValueSupport(option)) {
    const existingCasted = existingOption;
    yield* minMaxValue_cjs.handleMinMaxValueOptions({
      currentIndex,
      existingOption: existingCasted,
      expectedOption: option,
      keyPath
    });
  }
  if (_shared_cjs.hasChoicesAndAutocompleteSupport(option)) {
    const existingCasted = existingOption;
    yield* autocomplete_cjs.handleAutocomplete({
      expectedOption: option,
      existingOption: existingCasted,
      currentIndex,
      keyPath
    });
  }
  if (_shared_cjs.hasMinMaxLengthSupport(option)) {
    const existingCasted = existingOption;
    yield* minMaxLength_cjs.handleMinMaxLengthOptions({
      currentIndex,
      existingOption: existingCasted,
      expectedOption: option,
      keyPath
    });
  }
}
__name(reportOptionDifferences, "reportOptionDifferences");
function* handleSubcommandOptions({
  expectedOptions,
  existingOptions,
  currentIndex,
  keyPath
}) {
  if (!existingOptions?.length && expectedOptions?.length) {
    yield {
      key: `${keyPath(currentIndex)}.options`,
      expected: "options present",
      original: "no options present"
    };
  } else if (existingOptions?.length && !expectedOptions?.length) {
    yield {
      key: `${keyPath(currentIndex)}.options`,
      expected: "no options present",
      original: "options present"
    };
  } else if (expectedOptions?.length) {
    let processedIndex = 0;
    for (const subcommandOption of expectedOptions) {
      const currentSubCommandOptionIndex = processedIndex++;
      const existingSubcommandOption = existingOptions[currentSubCommandOptionIndex];
      yield* reportOptionDifferences({
        currentIndex: currentSubCommandOptionIndex,
        option: subcommandOption,
        existingOption: existingSubcommandOption,
        keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
      });
    }
    if (processedIndex < existingOptions.length) {
      let option;
      while ((option = existingOptions[processedIndex]) !== void 0) {
        const expectedType = _shared_cjs.optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
        yield {
          key: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,
          expected: "no option present",
          original: `${expectedType} with name ${option.name}`
        };
        processedIndex++;
      }
    }
  }
}
__name(handleSubcommandOptions, "handleSubcommandOptions");

exports.reportOptionDifferences = reportOptionDifferences;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=option.cjs.map