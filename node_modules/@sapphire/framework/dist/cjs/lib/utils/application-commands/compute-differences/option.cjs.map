{"version":3,"sources":["../../../../../../src/lib/utils/application-commands/compute-differences/option.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tApplicationCommandOptionType,\n\ttype APIApplicationCommandBasicOption,\n\ttype APIApplicationCommandChannelOption,\n\ttype APIApplicationCommandOption\n} from 'discord-api-types/v10';\nimport {\n\thasChannelTypesSupport,\n\thasChoicesAndAutocompleteSupport,\n\thasMinMaxLengthSupport,\n\thasMinMaxValueSupport,\n\toptionTypeToPrettyName,\n\tsubcommandTypes,\n\ttype APIApplicationCommandChoosableAndAutocompletableTypes,\n\ttype APIApplicationCommandMinAndMaxValueTypes,\n\ttype APIApplicationCommandMinMaxLengthTypes,\n\ttype APIApplicationCommandSubcommandTypes,\n\ttype CommandDifference\n} from './_shared';\nimport { checkDescription } from './description';\nimport { checkLocalizations } from './localizations';\nimport { checkName } from './name';\nimport { handleAutocomplete } from './option/autocomplete';\nimport { checkChannelTypes } from './option/channelTypes';\nimport { handleMinMaxLengthOptions } from './option/minMaxLength';\nimport { handleMinMaxValueOptions } from './option/minMaxValue';\nimport { checkOptionRequired } from './option/required';\nimport { checkOptionType } from './option/type';\n\nexport function* reportOptionDifferences({\n\toption,\n\texistingOption,\n\tcurrentIndex,\n\tkeyPath = (index: number) => `options[${index}]`\n}: {\n\toption: APIApplicationCommandOption;\n\tcurrentIndex: number;\n\texistingOption?: APIApplicationCommandOption;\n\tkeyPath?: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// If current option doesn't exist, report and return\n\tif (!existingOption) {\n\t\tconst expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\tyield {\n\t\t\tkey: keyPath(currentIndex),\n\t\t\texpected: `${expectedType} with name ${option.name}`,\n\t\t\toriginal: 'no option present'\n\t\t};\n\n\t\treturn;\n\t}\n\n\t// Check type\n\tyield* checkOptionType({\n\t\tkey: `${keyPath(currentIndex)}.type`,\n\t\toriginalType: existingOption.type,\n\t\texpectedType: option.type\n\t});\n\n\t// Check name\n\tyield* checkName({\n\t\tkey: `${keyPath(currentIndex)}.name`,\n\t\toldName: existingOption.name,\n\t\tnewName: option.name\n\t});\n\n\t// Check localized names\n\tconst originalLocalizedNames = existingOption.name_localizations;\n\tconst expectedLocalizedNames = option.name_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.nameLocalizations`,\n\t\tlocalePresentMessage: 'localized names',\n\t\tlocaleMissingMessage: 'no localized names',\n\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t});\n\n\t// Check description\n\tyield* checkDescription({\n\t\tkey: `${keyPath(currentIndex)}.description`,\n\t\toldDescription: existingOption.description,\n\t\tnewDescription: option.description\n\t});\n\n\t// Check localized descriptions\n\tconst originalLocalizedDescriptions = existingOption.description_localizations;\n\tconst expectedLocalizedDescriptions = option.description_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.descriptionLocalizations`,\n\t\tlocalePresentMessage: 'localized descriptions',\n\t\tlocaleMissingMessage: 'no localized descriptions',\n\t\toriginalLocalizedDescriptions,\n\t\texpectedLocalizedDescriptions\n\t});\n\n\t// Check required\n\tyield* checkOptionRequired({\n\t\tkey: `${keyPath(currentIndex)}.required`,\n\t\toldRequired: existingOption.required,\n\t\tnewRequired: option.required\n\t});\n\n\t// Check for subcommands\n\tif (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {\n\t\tconst castedExisting = existingOption as APIApplicationCommandSubcommandTypes;\n\t\tconst castedExpected = option as APIApplicationCommandSubcommandTypes;\n\n\t\tif (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.SubcommandGroup &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.SubcommandGroup\n\t\t) {\n\t\t\t// We know we have options in this case, because they are both groups\n\t\t\tfor (const [subcommandIndex, subcommandOption] of castedExpected.options!.entries()) {\n\t\t\t\tyield* reportOptionDifferences({\n\t\t\t\t\tcurrentIndex: subcommandIndex,\n\t\t\t\t\toption: subcommandOption,\n\t\t\t\t\texistingOption: castedExisting.options?.[subcommandIndex],\n\t\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.Subcommand &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.Subcommand\n\t\t) {\n\t\t\tyield* handleSubcommandOptions({\n\t\t\t\texpectedOptions: castedExpected.options,\n\t\t\t\texistingOptions: castedExisting.options,\n\t\t\t\tcurrentIndex,\n\t\t\t\tkeyPath\n\t\t\t});\n\t\t}\n\t}\n\n\tif (hasMinMaxValueSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinAndMaxValueTypes;\n\n\t\tyield* handleMinMaxValueOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChoicesAndAutocompleteSupport(option)) {\n\t\tconst existingCasted = existingOption as APIApplicationCommandChoosableAndAutocompletableTypes;\n\n\t\tyield* handleAutocomplete({\n\t\t\texpectedOption: option,\n\t\t\texistingOption: existingCasted,\n\t\t\tcurrentIndex,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasMinMaxLengthSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinMaxLengthTypes;\n\n\t\tyield* handleMinMaxLengthOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChannelTypesSupport(option)) {\n\t\t// Check channel_types\n\t\tconst existingCasted = existingOption as APIApplicationCommandChannelOption;\n\n\t\tyield* checkChannelTypes({\n\t\t\tcurrentIndex,\n\t\t\texistingChannelTypes: existingCasted.channel_types,\n\t\t\tkeyPath,\n\t\t\tnewChannelTypes: option.channel_types\n\t\t});\n\t}\n}\n\nfunction* handleSubcommandOptions({\n\texpectedOptions,\n\texistingOptions,\n\tcurrentIndex,\n\tkeyPath\n}: {\n\texpectedOptions?: APIApplicationCommandBasicOption[];\n\texistingOptions?: APIApplicationCommandBasicOption[];\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// 0. No existing options and now we have options\n\tif (!existingOptions?.length && expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'options present',\n\t\t\toriginal: 'no options present'\n\t\t};\n\t}\n\n\t// 1. Existing options and now we have no options\n\telse if (existingOptions?.length && !expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'no options present',\n\t\t\toriginal: 'options present'\n\t\t};\n\t}\n\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (expectedOptions?.length) {\n\t\tlet processedIndex = 0;\n\t\tfor (const subcommandOption of expectedOptions) {\n\t\t\tconst currentSubCommandOptionIndex = processedIndex++;\n\t\t\tconst existingSubcommandOption = existingOptions![currentSubCommandOptionIndex];\n\n\t\t\tyield* reportOptionDifferences({\n\t\t\t\tcurrentIndex: currentSubCommandOptionIndex,\n\t\t\t\toption: subcommandOption,\n\t\t\t\texistingOption: existingSubcommandOption,\n\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t});\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (processedIndex < existingOptions!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingOptions![processedIndex]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tprocessedIndex++;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}