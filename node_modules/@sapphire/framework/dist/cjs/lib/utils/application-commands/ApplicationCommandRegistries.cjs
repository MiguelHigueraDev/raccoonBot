'use strict';

var pieces = require('@sapphire/pieces');
var discord_js = require('discord.js');
var Enums_cjs = require('../../types/Enums.cjs');
var Events_cjs = require('../../types/Events.cjs');
var ApplicationCommandRegistry_cjs = require('./ApplicationCommandRegistry.cjs');
var getNeededParameters_cjs = require('./getNeededParameters.cjs');
var registriesErrors_cjs = require('./registriesErrors.cjs');
var registriesLog_cjs = require('./registriesLog.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
exports.defaultBehaviorWhenNotIdentical = Enums_cjs.RegisterBehavior.Overwrite;
exports.defaultGuildIds = void 0;
var registries = /* @__PURE__ */ new Map();
var allGuildIdsToFetchCommandsFor = /* @__PURE__ */ new Set();
function acquire(commandName) {
  const existing = registries.get(commandName);
  if (existing) {
    return existing;
  }
  const newRegistry = new ApplicationCommandRegistry_cjs.ApplicationCommandRegistry(commandName);
  registries.set(commandName, newRegistry);
  return newRegistry;
}
__name(acquire, "acquire");
function setDefaultBehaviorWhenNotIdentical(behavior) {
  exports.defaultBehaviorWhenNotIdentical = behavior ?? Enums_cjs.RegisterBehavior.Overwrite;
}
__name(setDefaultBehaviorWhenNotIdentical, "setDefaultBehaviorWhenNotIdentical");
function getDefaultBehaviorWhenNotIdentical() {
  return exports.defaultBehaviorWhenNotIdentical;
}
__name(getDefaultBehaviorWhenNotIdentical, "getDefaultBehaviorWhenNotIdentical");
function setDefaultGuildIds(guildIds) {
  exports.defaultGuildIds = guildIds ?? void 0;
}
__name(setDefaultGuildIds, "setDefaultGuildIds");
function getDefaultGuildIds() {
  return exports.defaultGuildIds;
}
__name(getDefaultGuildIds, "getDefaultGuildIds");
async function handleRegistryAPICalls() {
  pieces.container.client.emit(Events_cjs.Events.ApplicationCommandRegistriesInitialising);
  const commandStore = pieces.container.stores.get("commands");
  for (const command of commandStore.values()) {
    if (command.registerApplicationCommands) {
      try {
        await command.registerApplicationCommands(command.applicationCommandRegistry);
      } catch (error) {
        registriesErrors_cjs.emitPerRegistryError(error, command);
      }
    }
  }
  if (getDefaultBehaviorWhenNotIdentical() === Enums_cjs.RegisterBehavior.BulkOverwrite) {
    await handleBulkOverwrite(commandStore, pieces.container.client.application.commands);
    return;
  }
  const params = await getNeededParameters_cjs.getNeededRegistryParameters(allGuildIdsToFetchCommandsFor);
  await handleAppendOrUpdate(commandStore, params);
}
__name(handleRegistryAPICalls, "handleRegistryAPICalls");
async function handleBulkOverwrite(commandStore, applicationCommands) {
  const now = Date.now();
  const foundGlobalCommands = [];
  const foundGuildCommands = {};
  for (const command of commandStore.values()) {
    const registry = command.applicationCommandRegistry;
    for (const call of registry["apiCalls"]) {
      if (call.registerOptions.guildIds?.length) {
        for (const guildId of call.registerOptions.guildIds) {
          foundGuildCommands[guildId] ??= [];
          foundGuildCommands[guildId].push({ piece: command, data: call.builtData });
        }
        continue;
      }
      foundGlobalCommands.push({ piece: command, data: call.builtData });
    }
  }
  try {
    registriesLog_cjs.bulkOverwriteDebug(`Overwriting global application commands, now at ${foundGlobalCommands.length} commands`);
    const result = await applicationCommands.set(foundGlobalCommands.map((x) => x.data));
    for (const [id, globalCommand] of result.entries()) {
      const piece = foundGlobalCommands.find((x) => x.data.name === globalCommand.name)?.piece;
      if (piece) {
        const registry = piece.applicationCommandRegistry;
        switch (globalCommand.type) {
          case discord_js.ApplicationCommandType.ChatInput: {
            registry["handleIdAddition"](Enums_cjs.InternalRegistryAPIType.ChatInput, id);
            break;
          }
          case discord_js.ApplicationCommandType.User:
          case discord_js.ApplicationCommandType.Message: {
            registry["handleIdAddition"](Enums_cjs.InternalRegistryAPIType.ContextMenu, id);
            break;
          }
        }
        commandStore.aliases.set(id, piece);
      } else {
        registriesLog_cjs.bulkOverwriteWarn(
          `Registered global command "${globalCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
        );
      }
    }
    registriesLog_cjs.bulkOverwriteInfo(`Successfully overwrote global application commands. The application now has ${result.size} global commands`);
  } catch (error) {
    registriesErrors_cjs.emitBulkOverwriteError(error, null);
  }
  for (const [guildId, guildCommands] of Object.entries(foundGuildCommands)) {
    try {
      registriesLog_cjs.bulkOverwriteDebug(`Overwriting guild application commands for guild ${guildId}, now at ${guildCommands.length} commands`);
      const result = await applicationCommands.set(
        guildCommands.map((x) => x.data),
        guildId
      );
      for (const [id, guildCommand] of result.entries()) {
        const piece = guildCommands.find((x) => x.data.name === guildCommand.name)?.piece;
        if (piece) {
          const registry = piece.applicationCommandRegistry;
          switch (guildCommand.type) {
            case discord_js.ApplicationCommandType.ChatInput: {
              registry["handleIdAddition"](Enums_cjs.InternalRegistryAPIType.ChatInput, id, guildId);
              break;
            }
            case discord_js.ApplicationCommandType.User:
            case discord_js.ApplicationCommandType.Message: {
              registry["handleIdAddition"](Enums_cjs.InternalRegistryAPIType.ContextMenu, id, guildId);
              break;
            }
          }
          commandStore.aliases.set(id, piece);
        } else {
          registriesLog_cjs.bulkOverwriteWarn(
            `Registered guild command "${guildCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
          );
        }
      }
      registriesLog_cjs.bulkOverwriteInfo(
        `Successfully overwrote guild application commands for guild ${guildId}. The application now has ${result.size} guild commands for guild ${guildId}`
      );
    } catch (error) {
      registriesErrors_cjs.emitBulkOverwriteError(error, guildId);
    }
  }
  pieces.container.client.emit(Events_cjs.Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleBulkOverwrite, "handleBulkOverwrite");
async function handleAppendOrUpdate(commandStore, { applicationCommands, globalCommands, guildCommands }) {
  const now = Date.now();
  for (const registry of registries.values()) {
    await registry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    const piece = registry.command;
    if (piece) {
      for (const nameOrId of piece.applicationCommandRegistry.chatInputCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
      for (const nameOrId of piece.applicationCommandRegistry.contextMenuCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
    }
  }
  pieces.container.client.emit(Events_cjs.Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleAppendOrUpdate, "handleAppendOrUpdate");

exports.acquire = acquire;
exports.allGuildIdsToFetchCommandsFor = allGuildIdsToFetchCommandsFor;
exports.getDefaultBehaviorWhenNotIdentical = getDefaultBehaviorWhenNotIdentical;
exports.getDefaultGuildIds = getDefaultGuildIds;
exports.handleBulkOverwrite = handleBulkOverwrite;
exports.handleRegistryAPICalls = handleRegistryAPICalls;
exports.registries = registries;
exports.setDefaultBehaviorWhenNotIdentical = setDefaultBehaviorWhenNotIdentical;
exports.setDefaultGuildIds = setDefaultGuildIds;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=ApplicationCommandRegistries.cjs.map