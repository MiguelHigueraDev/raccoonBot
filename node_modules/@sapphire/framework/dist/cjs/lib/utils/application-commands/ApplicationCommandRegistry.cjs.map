{"version":3,"sources":["../../../../../src/lib/utils/application-commands/ApplicationCommandRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n\tContextMenuCommandBuilder,\n\tSlashCommandBuilder,\n\tSlashCommandOptionsOnlyBuilder,\n\tSlashCommandSubcommandsOnlyBuilder\n} from '@discordjs/builders';\nimport { container } from '@sapphire/pieces';\nimport { isNullishOrEmpty } from '@sapphire/utilities';\nimport {\n\tApplicationCommandType,\n\ttype RESTPostAPIChatInputApplicationCommandsJSONBody,\n\ttype RESTPostAPIContextMenuApplicationCommandsJSONBody\n} from 'discord-api-types/v10';\nimport type {\n\tApplicationCommand,\n\tApplicationCommandManager,\n\tChatInputApplicationCommandData,\n\tCollection,\n\tMessageApplicationCommandData,\n\tUserApplicationCommandData\n} from 'discord.js';\nimport { InternalRegistryAPIType, RegisterBehavior } from '../../types/Enums';\nimport { allGuildIdsToFetchCommandsFor, getDefaultBehaviorWhenNotIdentical, getDefaultGuildIds } from './ApplicationCommandRegistries';\nimport type { CommandDifference } from './compute-differences/_shared';\nimport { getCommandDifferences, getCommandDifferencesFast } from './computeDifferences';\nimport { convertApplicationCommandToApiData, normalizeChatInputCommand, normalizeContextMenuCommand } from './normalizeInputs';\n\nexport class ApplicationCommandRegistry {\n\tpublic readonly commandName: string;\n\n\tpublic readonly chatInputCommands = new Set<string>();\n\tpublic readonly contextMenuCommands = new Set<string>();\n\tpublic readonly guildIdsToFetch = new Set<string>();\n\n\tpublic globalCommandId: string | null = null;\n\tpublic readonly guildCommandIds = new Map<string, string>();\n\n\tprivate readonly apiCalls: InternalAPICall[] = [];\n\n\tpublic constructor(commandName: string) {\n\t\tthis.commandName = commandName;\n\t}\n\n\tpublic get command() {\n\t\treturn container.stores.get('commands').get(this.commandName);\n\t}\n\n\tpublic registerChatInputCommand(\n\t\tcommand:\n\t\t\t| ChatInputApplicationCommandData\n\t\t\t| SlashCommandBuilder\n\t\t\t| SlashCommandSubcommandsOnlyBuilder\n\t\t\t| SlashCommandOptionsOnlyBuilder\n\t\t\t| Omit<SlashCommandBuilder, 'addSubcommand' | 'addSubcommandGroup'>\n\t\t\t| ((builder: SlashCommandBuilder) => unknown),\n\t\toptions?: ApplicationCommandRegistryRegisterOptions\n\t) {\n\t\tconst builtData = normalizeChatInputCommand(command);\n\n\t\tthis.chatInputCommands.add(builtData.name);\n\n\t\tconst guildIdsToRegister = this.getGuildIdsToRegister(options);\n\n\t\tthis.apiCalls.push({\n\t\t\tbuiltData,\n\t\t\tregisterOptions: options ?? {\n\t\t\t\tregisterCommandIfMissing: true,\n\t\t\t\tbehaviorWhenNotIdentical: getDefaultBehaviorWhenNotIdentical(),\n\t\t\t\tguildIds: guildIdsToRegister\n\t\t\t},\n\t\t\ttype: InternalRegistryAPIType.ChatInput\n\t\t});\n\n\t\tif (options?.idHints) {\n\t\t\tfor (const hint of options.idHints) {\n\t\t\t\tthis.chatInputCommands.add(hint);\n\t\t\t}\n\t\t}\n\n\t\tthis.processGuildIds(guildIdsToRegister);\n\n\t\treturn this;\n\t}\n\n\tpublic registerContextMenuCommand(\n\t\tcommand:\n\t\t\t| UserApplicationCommandData\n\t\t\t| MessageApplicationCommandData\n\t\t\t| ContextMenuCommandBuilder\n\t\t\t| ((builder: ContextMenuCommandBuilder) => unknown),\n\t\toptions?: ApplicationCommandRegistryRegisterOptions\n\t) {\n\t\tconst builtData = normalizeContextMenuCommand(command);\n\n\t\tthis.contextMenuCommands.add(builtData.name);\n\n\t\tconst guildIdsToRegister = this.getGuildIdsToRegister(options);\n\n\t\tthis.apiCalls.push({\n\t\t\tbuiltData,\n\t\t\tregisterOptions: options ?? {\n\t\t\t\tregisterCommandIfMissing: true,\n\t\t\t\tbehaviorWhenNotIdentical: getDefaultBehaviorWhenNotIdentical(),\n\t\t\t\tguildIds: guildIdsToRegister\n\t\t\t},\n\t\t\ttype: InternalRegistryAPIType.ContextMenu\n\t\t});\n\n\t\tif (options?.idHints) {\n\t\t\tfor (const hint of options.idHints) {\n\t\t\t\tthis.contextMenuCommands.add(hint);\n\t\t\t}\n\t\t}\n\n\t\tthis.processGuildIds(guildIdsToRegister);\n\n\t\treturn this;\n\t}\n\n\tpublic addChatInputCommandNames(...names: string[] | string[][]) {\n\t\tconst flattened = names.flat(Infinity) as string[];\n\n\t\tfor (const command of flattened) {\n\t\t\tthis.debug(`Registering name \"${command}\" to internal chat input map`);\n\t\t\tthis.warn(\n\t\t\t\t`Registering the chat input command \"${command}\" using a name is not recommended.`,\n\t\t\t\t'Please use the \"addChatInputCommandIds\" method instead with a command id.'\n\t\t\t);\n\t\t\tthis.chatInputCommands.add(command);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic addContextMenuCommandNames(...names: string[] | string[][]) {\n\t\tconst flattened = names.flat(Infinity) as string[];\n\n\t\tfor (const command of flattened) {\n\t\t\tthis.debug(`Registering name \"${command}\" to internal context menu map`);\n\t\t\tthis.warn(\n\t\t\t\t`Registering the context menu command \"${command}\" using a name is not recommended.`,\n\t\t\t\t'Please use the \"addContextMenuCommandIds\" method instead with a command id.'\n\t\t\t);\n\t\t\tthis.contextMenuCommands.add(command);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic addChatInputCommandIds(...commandIds: string[] | string[][]) {\n\t\tconst flattened = commandIds.flat(Infinity) as string[];\n\n\t\tfor (const entry of flattened) {\n\t\t\ttry {\n\t\t\t\tBigInt(entry);\n\t\t\t\tthis.debug(`Registering id \"${entry}\" to internal chat input map`);\n\t\t\t} catch {\n\t\t\t\t// Don't be silly, save yourself the headaches and do as we say\n\t\t\t\tthis.debug(`Registering name \"${entry}\" to internal chat input map`);\n\t\t\t\tthis.warn(\n\t\t\t\t\t`Registering the chat input command \"${entry}\" using a name *and* trying to bypass this warning by calling \"addChatInputCommandIds\" is not recommended.`,\n\t\t\t\t\t'Please use the \"addChatInputCommandIds\" method with a valid command id instead.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.chatInputCommands.add(entry);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic addContextMenuCommandIds(...commandIds: string[] | string[][]) {\n\t\tconst flattened = commandIds.flat(Infinity) as string[];\n\n\t\tfor (const entry of flattened) {\n\t\t\ttry {\n\t\t\t\tBigInt(entry);\n\t\t\t\tthis.debug(`Registering id \"${entry}\" to internal context menu map`);\n\t\t\t} catch {\n\t\t\t\tthis.debug(`Registering name \"${entry}\" to internal context menu map`);\n\t\t\t\t// Don't be silly, save yourself the headaches and do as we say\n\t\t\t\tthis.warn(\n\t\t\t\t\t`Registering the context menu command \"${entry}\" using a name *and* trying to bypass this warning by calling \"addContextMenuCommandIds\" is not recommended.`,\n\t\t\t\t\t'Please use the \"addContextMenuCommandIds\" method with a valid command id instead.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.contextMenuCommands.add(entry);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected async runAPICalls(\n\t\tapplicationCommands: ApplicationCommandManager,\n\t\tglobalCommands: Collection<string, ApplicationCommand>,\n\t\tguildCommands: Map<string, Collection<string, ApplicationCommand>>\n\t) {\n\t\t// Early return for no API calls\n\t\tif (this.apiCalls.length === 0) {\n\t\t\t// If we have no API calls to do then we simply return (can happen if the registry is used directly)\n\t\t\tthis.trace('No API calls to run, and no command to register');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (getDefaultBehaviorWhenNotIdentical() === RegisterBehavior.BulkOverwrite) {\n\t\t\tthrow new RangeError(\n\t\t\t\t`\"runAPICalls\" was called for \"${this.commandName}\" but the defaultBehaviorWhenNotIdentical is \"BulkOverwrite\". This should not happen.`\n\t\t\t);\n\t\t}\n\n\t\tthis.debug(`Preparing to process ${this.apiCalls.length} possible command registrations / updates...`);\n\n\t\tconst results = await Promise.allSettled(\n\t\t\tthis.apiCalls.map((call) => this.handleAPICall(applicationCommands, globalCommands, guildCommands, call))\n\t\t);\n\n\t\tconst errored = results.filter((result) => result.status === 'rejected') as PromiseRejectedResult[];\n\n\t\tif (errored.length) {\n\t\t\tthis.error(`Received ${errored.length} errors while processing command registrations / updates`);\n\n\t\t\tfor (const error of errored) {\n\t\t\t\tthis.error(error.reason.stack ?? error.reason);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getGuildIdsToRegister(options?: ApplicationCommandRegistryRegisterOptions) {\n\t\tlet guildIdsToRegister: ApplicationCommandRegistry.RegisterOptions['guildIds'] = undefined;\n\n\t\tif (!isNullishOrEmpty(options?.guildIds)) {\n\t\t\tguildIdsToRegister = options!.guildIds;\n\t\t} else if (!isNullishOrEmpty(getDefaultGuildIds())) {\n\t\t\tguildIdsToRegister = getDefaultGuildIds();\n\t\t}\n\n\t\treturn guildIdsToRegister;\n\t}\n\n\tprivate processGuildIds(guildIdsToRegister: ApplicationCommandRegistry.RegisterOptions['guildIds']) {\n\t\tif (!isNullishOrEmpty(guildIdsToRegister)) {\n\t\t\tfor (const id of guildIdsToRegister) {\n\t\t\t\tthis.guildIdsToFetch.add(id);\n\t\t\t\tallGuildIdsToFetchCommandsFor.add(id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async handleAPICall(\n\t\tcommandsManager: ApplicationCommandManager,\n\t\tglobalCommands: Collection<string, ApplicationCommand>,\n\t\tallGuildsCommands: Map<string, Collection<string, ApplicationCommand>>,\n\t\tapiCall: InternalAPICall\n\t) {\n\t\tconst { builtData, registerOptions } = apiCall;\n\t\tconst commandName = builtData.name;\n\t\tconst behaviorIfNotEqual = registerOptions.behaviorWhenNotIdentical ?? getDefaultBehaviorWhenNotIdentical();\n\n\t\tconst findCallback = (entry: ApplicationCommand) => {\n\t\t\t// If the command is a chat input command, we need to check if the entry is a chat input command\n\t\t\tif (apiCall.type === InternalRegistryAPIType.ChatInput && entry.type !== ApplicationCommandType.ChatInput) return false;\n\t\t\t// If the command is a context menu command, we need to check if the entry is a context menu command of the same type\n\t\t\tif (apiCall.type === InternalRegistryAPIType.ContextMenu) {\n\t\t\t\t// If its a chat input command, it doesn't match\n\t\t\t\tif (entry.type === ApplicationCommandType.ChatInput) return false;\n\t\t\t\t// Check the command type (must match)\n\t\t\t\tif (apiCall.builtData.type !== entry.type) return false;\n\t\t\t}\n\n\t\t\t// Find the command by name or by id hint (mostly useful for context menus)\n\t\t\tconst isInIdHint = registerOptions.idHints?.includes(entry.id);\n\t\t\treturn typeof isInIdHint === 'boolean' ? isInIdHint || entry.name === commandName : entry.name === commandName;\n\t\t};\n\n\t\tlet type: string;\n\n\t\tswitch (apiCall.type) {\n\t\t\tcase InternalRegistryAPIType.ChatInput:\n\t\t\t\ttype = 'chat input';\n\t\t\t\tbreak;\n\t\t\tcase InternalRegistryAPIType.ContextMenu:\n\t\t\t\tswitch (apiCall.builtData.type) {\n\t\t\t\t\tcase ApplicationCommandType.Message:\n\t\t\t\t\t\ttype = 'message context menu';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ApplicationCommandType.User:\n\t\t\t\t\t\ttype = 'user context menu';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttype = 'unknown-type context menu';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttype = 'unknown';\n\t\t}\n\n\t\tif (!registerOptions.guildIds?.length) {\n\t\t\tconst globalCommand = globalCommands.find(findCallback);\n\n\t\t\tif (globalCommand) {\n\t\t\t\tswitch (apiCall.type) {\n\t\t\t\t\tcase InternalRegistryAPIType.ChatInput:\n\t\t\t\t\t\tthis.addChatInputCommandIds(globalCommand.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase InternalRegistryAPIType.ContextMenu:\n\t\t\t\t\t\tthis.addContextMenuCommandIds(globalCommand.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthis.debug(`Checking if command \"${commandName}\" is identical with global ${type} command with id \"${globalCommand.id}\"`);\n\t\t\t\tawait this.handleCommandPresent(globalCommand, builtData, behaviorIfNotEqual, null);\n\t\t\t} else if (registerOptions.registerCommandIfMissing ?? true) {\n\t\t\t\tthis.debug(`Creating new global ${type} command with name \"${commandName}\"`);\n\t\t\t\tawait this.createMissingCommand(commandsManager, builtData, type);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Doing nothing about missing global ${type} command with name \"${commandName}\"`);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const guildId of registerOptions.guildIds) {\n\t\t\tconst guildCommands = allGuildsCommands.get(guildId);\n\n\t\t\tif (!guildCommands) {\n\t\t\t\tthis.debug(`There are no commands for guild with id \"${guildId}\". Will create ${type} command \"${commandName}\".`);\n\t\t\t\tawait this.createMissingCommand(commandsManager, builtData, type, guildId);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst existingGuildCommand = guildCommands.find(findCallback);\n\n\t\t\tif (existingGuildCommand) {\n\t\t\t\tthis.debug(`Checking if guild ${type} command \"${commandName}\" is identical to command \"${existingGuildCommand.id}\"`);\n\n\t\t\t\tswitch (apiCall.type) {\n\t\t\t\t\tcase InternalRegistryAPIType.ChatInput:\n\t\t\t\t\t\tthis.addChatInputCommandIds(existingGuildCommand.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase InternalRegistryAPIType.ContextMenu:\n\t\t\t\t\t\tthis.addContextMenuCommandIds(existingGuildCommand.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tawait this.handleCommandPresent(existingGuildCommand, builtData, behaviorIfNotEqual, guildId);\n\t\t\t} else if (registerOptions.registerCommandIfMissing ?? true) {\n\t\t\t\tthis.debug(`Creating new guild ${type} command with name \"${commandName}\" for guild \"${guildId}\"`);\n\t\t\t\tawait this.createMissingCommand(commandsManager, builtData, type, guildId);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Doing nothing about missing guild ${type} command with name \"${commandName}\" for guild \"${guildId}\"`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async handleCommandPresent(\n\t\tapplicationCommand: ApplicationCommand,\n\t\tapiData: InternalAPICall['builtData'],\n\t\tbehaviorIfNotEqual: RegisterBehavior,\n\t\tguildId: string | null\n\t) {\n\t\tif (guildId) {\n\t\t\tthis.guildCommandIds.set(guildId, applicationCommand.id);\n\t\t} else {\n\t\t\tthis.globalCommandId = applicationCommand.id;\n\t\t}\n\n\t\tif (behaviorIfNotEqual === RegisterBehavior.BulkOverwrite) {\n\t\t\tthis.debug(\n\t\t\t\t`Command \"${this.commandName}\" has the behaviorIfNotEqual set to \"BulkOverwrite\" which is invalid. Using defaultBehaviorWhenNotIdentical instead`\n\t\t\t);\n\n\t\t\tbehaviorIfNotEqual = getDefaultBehaviorWhenNotIdentical();\n\n\t\t\tif (behaviorIfNotEqual === RegisterBehavior.BulkOverwrite) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid behaviorIfNotEqual value (\"BulkOverwrite\") for command \"${this.commandName}\", and defaultBehaviorWhenNotIdentical is also \"BulkOverwrite\". This should not happen.`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tlet differences: CommandDifference[] = [];\n\n\t\tif (behaviorIfNotEqual === RegisterBehavior.VerboseOverwrite) {\n\t\t\tconst now = Date.now();\n\n\t\t\t// Step 0: compute differences\n\t\t\tdifferences = [...getCommandDifferences(convertApplicationCommandToApiData(applicationCommand), apiData, guildId !== null)];\n\n\t\t\tconst later = Date.now() - now;\n\t\t\tthis.debug(`Took ${later}ms to process differences via computing differences`);\n\n\t\t\t// Step 1: if there are no differences, return\n\t\t\tif (!differences.length) {\n\t\t\t\tthis.debug(\n\t\t\t\t\t`${guildId ? 'Guild command' : 'Command'} \"${apiData.name}\" is identical to command \"${applicationCommand.name}\" (${\n\t\t\t\t\t\tapplicationCommand.id\n\t\t\t\t\t})`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Run the fast path even if the user wants to just log if the command has a difference\n\t\tif (behaviorIfNotEqual === RegisterBehavior.Overwrite || behaviorIfNotEqual === RegisterBehavior.LogToConsole) {\n\t\t\tconst now = Date.now();\n\n\t\t\t// Step 0: compute differences\n\t\t\tconst areThereDifferences = getCommandDifferencesFast(convertApplicationCommandToApiData(applicationCommand), apiData, guildId !== null);\n\n\t\t\tconst later = Date.now() - now;\n\t\t\tthis.debug(`Took ${later}ms to process differences via fast compute differences`);\n\n\t\t\t// Step 1: if there are no differences, return\n\t\t\tif (!areThereDifferences) {\n\t\t\t\tthis.debug(\n\t\t\t\t\t`${guildId ? 'Guild command' : 'Command'} \"${apiData.name}\" is identical to command \"${applicationCommand.name}\" (${\n\t\t\t\t\t\tapplicationCommand.id\n\t\t\t\t\t})`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.logCommandDifferencesFound(applicationCommand, behaviorIfNotEqual === RegisterBehavior.LogToConsole, differences);\n\n\t\t// Step 2: if the behavior is to log to console, only log the differences\n\t\tif (behaviorIfNotEqual === RegisterBehavior.LogToConsole) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Step 3: if the behavior is to update, update the command\n\t\ttry {\n\t\t\tawait applicationCommand.edit(apiData as ChatInputApplicationCommandData);\n\t\t\tthis.debug(`Updated command ${applicationCommand.name} (${applicationCommand.id}) with new api data`);\n\t\t} catch (error) {\n\t\t\tthis.error(`Failed to update command ${applicationCommand.name} (${applicationCommand.id})`, error);\n\t\t}\n\t}\n\n\tprivate logCommandDifferencesFound(applicationCommand: ApplicationCommand, logAsWarn: boolean, differences: CommandDifference[]) {\n\t\tconst finalMessage: string[] = [];\n\t\tconst pad = ' '.repeat(5);\n\n\t\tfor (const difference of differences) {\n\t\t\tfinalMessage.push(\n\t\t\t\t[\n\t\t\t\t\t`└── At path: ${difference.key}`, //\n\t\t\t\t\t`${pad}├── Received: ${difference.original}`,\n\t\t\t\t\t`${pad}└── Expected: ${difference.expected}`,\n\t\t\t\t\t''\n\t\t\t\t].join('\\n')\n\t\t\t);\n\t\t}\n\n\t\tconst finalMessageNewLine = finalMessage.length ? '\\n' : '';\n\t\tconst header = `Found differences for command \"${applicationCommand.name}\" (${applicationCommand.id}) versus provided api data.${finalMessageNewLine}`;\n\n\t\tlogAsWarn ? this.warn(header, ...finalMessage) : this.debug(header, ...finalMessage);\n\t}\n\n\tprivate async createMissingCommand(\n\t\tcommandsManager: ApplicationCommandManager,\n\t\tapiData: InternalAPICall['builtData'],\n\t\ttype: string,\n\t\tguildId?: string\n\t) {\n\t\ttry {\n\t\t\tconst result = await commandsManager.create(apiData, guildId);\n\n\t\t\tif (guildId) {\n\t\t\t\tthis.guildCommandIds.set(guildId, result.id);\n\t\t\t} else {\n\t\t\t\tthis.globalCommandId = result.id;\n\t\t\t}\n\n\t\t\tthis.info(\n\t\t\t\t`Successfully created ${type}${guildId ? ' guild' : ''} command \"${apiData.name}\" with id \"${\n\t\t\t\t\tresult.id\n\t\t\t\t}\". You should add the id to the \"idHints\" property of the register method you used!`\n\t\t\t);\n\n\t\t\tswitch (apiData.type) {\n\t\t\t\tcase undefined:\n\t\t\t\tcase ApplicationCommandType.ChatInput:\n\t\t\t\t\tthis.addChatInputCommandIds(result.id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ApplicationCommandType.Message:\n\t\t\t\tcase ApplicationCommandType.User:\n\t\t\t\t\tthis.addContextMenuCommandIds(result.id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.error(\n\t\t\t\t`Failed to register${guildId ? ' guild' : ''} application command with name \"${apiData.name}\"${\n\t\t\t\t\tguildId ? ` for guild \"${guildId}\"` : ''\n\t\t\t\t}`,\n\t\t\t\terr\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate info(message: string, ...other: unknown[]) {\n\t\tcontainer.logger.info(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);\n\t}\n\n\tprivate error(message: string, ...other: unknown[]) {\n\t\tcontainer.logger.error(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);\n\t}\n\n\tprivate warn(message: string, ...other: unknown[]) {\n\t\tcontainer.logger.warn(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);\n\t}\n\n\tprivate debug(message: string, ...other: unknown[]) {\n\t\tcontainer.logger.debug(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);\n\t}\n\n\tprivate trace(message: string, ...other: unknown[]) {\n\t\tcontainer.logger.trace(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);\n\t}\n}\n\nexport namespace ApplicationCommandRegistry {\n\texport interface RegisterOptions {\n\t\t/**\n\t\t * If this is specified, the application commands will only be registered for these guild ids.\n\t\t */\n\t\tguildIds?: string[];\n\t\t/**\n\t\t * If we should register the command when it is missing\n\t\t * @default true\n\t\t */\n\t\tregisterCommandIfMissing?: boolean;\n\t\t/**\n\t\t * Specifies what we should do when the command is present, but not identical with the data you provided\n\t\t * @default `ApplicationCommandRegistries.getDefaultBehaviorWhenNotIdentical()`\n\t\t */\n\t\tbehaviorWhenNotIdentical?: Exclude<RegisterBehavior, RegisterBehavior.BulkOverwrite>;\n\t\t/**\n\t\t * Specifies a list of command ids that we should check in the event of a name mismatch\n\t\t * @default []\n\t\t */\n\t\tidHints?: string[];\n\t}\n}\n\nexport type ApplicationCommandRegistryRegisterOptions = ApplicationCommandRegistry.RegisterOptions;\n\ntype InternalRegisterOptions = Omit<ApplicationCommandRegistry.RegisterOptions, 'behaviorWhenNotIdentical'> & {\n\tbehaviorWhenNotIdentical?: RegisterBehavior;\n};\n\nexport type InternalAPICall =\n\t| {\n\t\t\tbuiltData: RESTPostAPIChatInputApplicationCommandsJSONBody;\n\t\t\tregisterOptions: InternalRegisterOptions;\n\t\t\ttype: InternalRegistryAPIType.ChatInput;\n\t  }\n\t| {\n\t\t\tbuiltData: RESTPostAPIContextMenuApplicationCommandsJSONBody;\n\t\t\tregisterOptions: InternalRegisterOptions;\n\t\t\ttype: InternalRegistryAPIType.ContextMenu;\n\t  };\n"]}