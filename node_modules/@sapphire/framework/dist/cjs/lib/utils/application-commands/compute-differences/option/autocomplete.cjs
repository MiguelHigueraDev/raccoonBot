'use strict';

var localizations_cjs = require('../localizations.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function* handleAutocomplete({
  currentIndex,
  existingOption,
  expectedOption,
  keyPath
}) {
  if (!existingOption.autocomplete && expectedOption.autocomplete) {
    yield {
      key: `${keyPath(currentIndex)}.autocomplete`,
      expected: "autocomplete enabled",
      original: "autocomplete disabled"
    };
  } else if (existingOption.autocomplete && !expectedOption.autocomplete) {
    yield {
      key: `${keyPath(currentIndex)}.autocomplete`,
      expected: "autocomplete disabled",
      original: "autocomplete enabled"
    };
  }
  if (!expectedOption.autocomplete && !existingOption.autocomplete) {
    if (!existingOption.choices?.length && expectedOption.choices?.length) {
      yield {
        key: `${keyPath(currentIndex)}.choices`,
        expected: "choices present",
        original: "no choices present"
      };
    } else if (existingOption.choices?.length && !expectedOption.choices?.length) {
      yield {
        key: `${keyPath(currentIndex)}.choices`,
        expected: "no choices present",
        original: "choices present"
      };
    } else if (expectedOption.choices?.length && existingOption.choices?.length) {
      let index = 0;
      for (const choice of expectedOption.choices) {
        const currentChoiceIndex = index++;
        const existingChoice = existingOption.choices[currentChoiceIndex];
        if (existingChoice === void 0) {
          yield {
            key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,
            original: "no choice present",
            expected: "choice present"
          };
        } else {
          if (choice.name !== existingChoice.name) {
            yield {
              key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,
              original: existingChoice.name,
              expected: choice.name
            };
          }
          const originalLocalizedNames = existingChoice.name_localizations;
          const expectedLocalizedNames = choice.name_localizations;
          yield* localizations_cjs.checkLocalizations({
            localeMapName: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,
            localePresentMessage: "localized names",
            localeMissingMessage: "no localized names",
            originalLocalizedDescriptions: originalLocalizedNames,
            expectedLocalizedDescriptions: expectedLocalizedNames
          });
          if (choice.value !== existingChoice.value) {
            yield {
              key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,
              original: String(existingChoice.value),
              expected: String(choice.value)
            };
          }
        }
      }
      if (index < existingOption.choices.length) {
        let choice;
        while ((choice = existingOption.choices[index]) !== void 0) {
          yield {
            key: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,
            expected: "no choice present",
            original: `choice with name "${choice.name}" and value ${typeof choice.value === "number" ? choice.value : `"${choice.value}"`} present`
          };
          index++;
        }
      }
    }
  }
}
__name(handleAutocomplete, "handleAutocomplete");

exports.handleAutocomplete = handleAutocomplete;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=autocomplete.cjs.map