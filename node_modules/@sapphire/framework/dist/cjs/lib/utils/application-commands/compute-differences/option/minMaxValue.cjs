'use strict';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/lib/utils/application-commands/compute-differences/option/minMaxValue.ts
function* handleMinMaxValueOptions({
  currentIndex,
  existingOption,
  expectedOption,
  keyPath
}) {
  if (existingOption.min_value === void 0 && expectedOption.min_value !== void 0) {
    yield {
      key: `${keyPath(currentIndex)}.min_value`,
      expected: "min_value present",
      original: "no min_value present"
    };
  } else if (existingOption.min_value !== void 0 && expectedOption.min_value === void 0) {
    yield {
      key: `${keyPath(currentIndex)}.min_value`,
      expected: "no min_value present",
      original: "min_value present"
    };
  } else if (existingOption.min_value !== expectedOption.min_value) {
    yield {
      key: `${keyPath(currentIndex)}.min_value`,
      original: String(existingOption.min_value),
      expected: String(expectedOption.min_value)
    };
  }
  if (existingOption.max_value === void 0 && expectedOption.max_value !== void 0) {
    yield {
      key: `${keyPath(currentIndex)}.max_value`,
      expected: "max_value present",
      original: "no max_value present"
    };
  } else if (existingOption.max_value !== void 0 && expectedOption.max_value === void 0) {
    yield {
      key: `${keyPath(currentIndex)}.max_value`,
      expected: "no max_value present",
      original: "max_value present"
    };
  } else if (existingOption.max_value !== expectedOption.max_value) {
    yield {
      key: `${keyPath(currentIndex)}.max_value`,
      original: String(existingOption.max_value),
      expected: String(expectedOption.max_value)
    };
  }
}
__name(handleMinMaxValueOptions, "handleMinMaxValueOptions");

exports.handleMinMaxValueOptions = handleMinMaxValueOptions;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=minMaxValue.cjs.map