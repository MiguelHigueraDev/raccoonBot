'use strict';

var pieces = require('@sapphire/pieces');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function getNeededRegistryParameters(guildIds = /* @__PURE__ */ new Set()) {
  const { client } = pieces.container;
  const applicationCommands = client.application.commands;
  const globalCommands = await applicationCommands.fetch({ withLocalizations: true });
  const guildCommands = await fetchGuildCommands(applicationCommands, guildIds);
  return {
    applicationCommands,
    globalCommands,
    guildCommands
  };
}
__name(getNeededRegistryParameters, "getNeededRegistryParameters");
async function fetchGuildCommands(commands, guildIds) {
  const map = /* @__PURE__ */ new Map();
  for (const guildId of guildIds) {
    try {
      const guildCommands = await commands.fetch({ guildId, withLocalizations: true });
      map.set(guildId, guildCommands);
    } catch (err) {
      const { preventFailedToFetchLogForGuilds } = pieces.container.client.options;
      if (preventFailedToFetchLogForGuilds === true)
        continue;
      if (Array.isArray(preventFailedToFetchLogForGuilds) && !preventFailedToFetchLogForGuilds?.includes(guildId)) {
        const guild = pieces.container.client.guilds.resolve(guildId) ?? { name: "Guild not in cache" };
        pieces.container.logger.warn(
          `ApplicationCommandRegistries: Failed to fetch guild commands for guild "${guild.name}" (${guildId}).`,
          'Make sure to authorize your application with the "applications.commands" scope in that guild.'
        );
      }
    }
  }
  return map;
}
__name(fetchGuildCommands, "fetchGuildCommands");

exports.getNeededRegistryParameters = getNeededRegistryParameters;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=getNeededParameters.cjs.map