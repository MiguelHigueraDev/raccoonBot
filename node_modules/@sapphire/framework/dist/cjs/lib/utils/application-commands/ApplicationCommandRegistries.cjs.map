{"version":3,"sources":["../../../../../src/lib/utils/application-commands/ApplicationCommandRegistries.ts"],"names":[],"mappings":"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","sourcesContent":["import { container } from '@sapphire/pieces';\nimport type { RESTPostAPIApplicationCommandsJSONBody } from 'discord-api-types/v10';\nimport type { ApplicationCommandManager } from 'discord.js';\nimport type { Command } from '../../structures/Command';\nimport type { CommandStore } from '../../structures/CommandStore';\nimport { RegisterBehavior } from '../../types/Enums';\nimport { Events } from '../../types/Events';\nimport { ApplicationCommandRegistry } from './ApplicationCommandRegistry';\nimport { getNeededRegistryParameters } from './getNeededParameters';\nimport { emitBulkOverwriteError, emitPerRegistryError } from './registriesErrors';\nimport { bulkOverwriteDebug, bulkOverwriteInfo, bulkOverwriteWarn } from './registriesLog';\n\nexport let defaultBehaviorWhenNotIdentical = RegisterBehavior.Overwrite;\nexport let defaultGuildIds: ApplicationCommandRegistry.RegisterOptions['guildIds'] = undefined;\n\nexport const registries = new Map<string, ApplicationCommandRegistry>();\n\nexport const allGuildIdsToFetchCommandsFor = new Set<string>();\n\n/**\n * Acquires a registry for a command by its name.\n * @param commandName The name of the command.\n * @returns The application command registry for the command\n */\nexport function acquire(commandName: string) {\n\tconst existing = registries.get(commandName);\n\tif (existing) {\n\t\treturn existing;\n\t}\n\n\tconst newRegistry = new ApplicationCommandRegistry(commandName);\n\tregistries.set(commandName, newRegistry);\n\n\treturn newRegistry;\n}\n\n/**\n * Sets the default behavior when registered commands aren't identical to provided data.\n * @param behavior The default behavior to have. Set this to `null` to reset it to the default\n * of `RegisterBehavior.Overwrite`.\n */\nexport function setDefaultBehaviorWhenNotIdentical(behavior?: RegisterBehavior | null) {\n\tdefaultBehaviorWhenNotIdentical = behavior ?? RegisterBehavior.Overwrite;\n}\n\nexport function getDefaultBehaviorWhenNotIdentical() {\n\treturn defaultBehaviorWhenNotIdentical;\n}\n\n/**\n * Sets the default guild ids for registering commands. This is used when a command is registered _without_ providing\n * `guildIds` in that command's own {@link Command.registerApplicationCommands} method.\n * @param guildIds The default guildIds to set. Set this to `null` to reset it to the default\n * of `undefined`.\n */\nexport function setDefaultGuildIds(guildIds?: ApplicationCommandRegistry.RegisterOptions['guildIds'] | null) {\n\tdefaultGuildIds = guildIds ?? undefined;\n}\n\nexport function getDefaultGuildIds() {\n\treturn defaultGuildIds;\n}\n\nexport async function handleRegistryAPICalls() {\n\tcontainer.client.emit(Events.ApplicationCommandRegistriesInitialising);\n\n\tconst commandStore = container.stores.get('commands');\n\n\tfor (const command of commandStore.values()) {\n\t\tif (command.registerApplicationCommands) {\n\t\t\ttry {\n\t\t\t\tawait command.registerApplicationCommands(command.applicationCommandRegistry);\n\t\t\t} catch (error) {\n\t\t\t\temitPerRegistryError(error, command);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (getDefaultBehaviorWhenNotIdentical() === RegisterBehavior.BulkOverwrite) {\n\t\tawait handleBulkOverwrite(commandStore, container.client.application!.commands);\n\t\treturn;\n\t}\n\n\tconst params = await getNeededRegistryParameters(allGuildIdsToFetchCommandsFor);\n\n\tawait handleAppendOrUpdate(commandStore, params);\n}\n\nexport async function handleBulkOverwrite(commandStore: CommandStore, applicationCommands: ApplicationCommandManager) {\n\tconst now = Date.now();\n\n\t// Map registries by guild, global, etc\n\tconst foundGlobalCommands: BulkOverwriteData[] = [];\n\tconst foundGuildCommands: Record<string, BulkOverwriteData[]> = {};\n\n\t// Collect all data\n\tfor (const command of commandStore.values()) {\n\t\tconst registry = command.applicationCommandRegistry;\n\n\t\tfor (const call of registry['apiCalls']) {\n\t\t\t// Guild only cmd\n\t\t\tif (call.registerOptions.guildIds?.length) {\n\t\t\t\tfor (const guildId of call.registerOptions.guildIds) {\n\t\t\t\t\tfoundGuildCommands[guildId] ??= [];\n\n\t\t\t\t\tfoundGuildCommands[guildId].push({ piece: command, data: call.builtData });\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Global command\n\t\t\tfoundGlobalCommands.push({ piece: command, data: call.builtData });\n\t\t}\n\t}\n\n\t// Handle global commands\n\ttry {\n\t\tbulkOverwriteDebug(`Overwriting global application commands, now at ${foundGlobalCommands.length} commands`);\n\t\tconst result = await applicationCommands.set(foundGlobalCommands.map((x) => x.data));\n\n\t\t// Go through each registered command, find its piece and alias it\n\t\tfor (const [id, globalCommand] of result.entries()) {\n\t\t\tconst piece = foundGlobalCommands.find((x) => x.data.name === globalCommand.name)?.piece;\n\n\t\t\tif (piece) {\n\t\t\t\tconst registry = piece.applicationCommandRegistry;\n\n\t\t\t\tregistry.globalCommandId = id;\n\t\t\t\tregistry.addChatInputCommandIds(id);\n\n\t\t\t\t// idHints are useless, and any manually added id or names could end up not being valid any longer if you use bulk overwrites\n\t\t\t\t// That said, this might be an issue, so we might need to do it like `handleAppendOrUpdate`\n\t\t\t\tcommandStore.aliases.set(id, piece);\n\t\t\t} else {\n\t\t\t\tbulkOverwriteWarn(\n\t\t\t\t\t`Registered global command \"${globalCommand.name}\" (${id}) but failed to find the piece in the command store. This should not happen`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tbulkOverwriteInfo(`Successfully overwrote global application commands. The application now has ${result.size} global commands`);\n\t} catch (error) {\n\t\temitBulkOverwriteError(error, null);\n\t}\n\n\t// Handle guild commands\n\tfor (const [guildId, guildCommands] of Object.entries(foundGuildCommands)) {\n\t\ttry {\n\t\t\tbulkOverwriteDebug(`Overwriting guild application commands for guild ${guildId}, now at ${guildCommands.length} commands`);\n\t\t\tconst result = await applicationCommands.set(\n\t\t\t\tguildCommands.map((x) => x.data),\n\t\t\t\tguildId\n\t\t\t);\n\n\t\t\t// Go through each registered command, find its piece and alias it\n\t\t\tfor (const [id, guildCommand] of result.entries()) {\n\t\t\t\t// I really hope nobody has a guild command with the same name as another command -.-\n\t\t\t\t// Not like they could anyways as Discord would throw an error for duplicate names\n\t\t\t\t// But yknow... If you're reading this and you did this... Why?\n\t\t\t\tconst piece = guildCommands.find((x) => x.data.name === guildCommand.name)?.piece;\n\n\t\t\t\tif (piece) {\n\t\t\t\t\tconst registry = piece.applicationCommandRegistry;\n\t\t\t\t\tregistry.guildCommandIds.set(guildId, id);\n\n\t\t\t\t\tregistry.addChatInputCommandIds(id);\n\n\t\t\t\t\t// idHints are useless, and any manually added ids or names could no longer be valid if you use bulk overwrites.\n\t\t\t\t\t// That said, this might be an issue, so we might need to do it like `handleAppendOrUpdate`\n\t\t\t\t\tcommandStore.aliases.set(id, piece);\n\t\t\t\t} else {\n\t\t\t\t\tbulkOverwriteWarn(\n\t\t\t\t\t\t`Registered guild command \"${guildCommand.name}\" (${id}) but failed to find the piece in the command store. This should not happen`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbulkOverwriteInfo(\n\t\t\t\t`Successfully overwrote guild application commands for guild ${guildId}. The application now has ${result.size} guild commands for guild ${guildId}`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\temitBulkOverwriteError(error, guildId);\n\t\t}\n\t}\n\n\tcontainer.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);\n}\n\nasync function handleAppendOrUpdate(\n\tcommandStore: CommandStore,\n\t{ applicationCommands, globalCommands, guildCommands }: Awaited<ReturnType<typeof getNeededRegistryParameters>>\n) {\n\tconst now = Date.now();\n\n\tfor (const registry of registries.values()) {\n\t\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\t\tawait registry['runAPICalls'](applicationCommands, globalCommands, guildCommands);\n\n\t\tconst piece = registry.command;\n\n\t\tif (piece) {\n\t\t\tfor (const nameOrId of piece.applicationCommandRegistry.chatInputCommands) {\n\t\t\t\tcommandStore.aliases.set(nameOrId, piece);\n\t\t\t}\n\n\t\t\tfor (const nameOrId of piece.applicationCommandRegistry.contextMenuCommands) {\n\t\t\t\tcommandStore.aliases.set(nameOrId, piece);\n\t\t\t}\n\t\t}\n\t}\n\n\tcontainer.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);\n}\n\ninterface BulkOverwriteData {\n\tpiece: Command;\n\tdata: RESTPostAPIApplicationCommandsJSONBody;\n}\n"]}