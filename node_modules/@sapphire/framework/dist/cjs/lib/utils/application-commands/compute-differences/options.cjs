'use strict';

var _shared_cjs = require('./_shared.cjs');
var option_cjs = require('./option.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function* checkOptions(existingOptions, newOptions) {
  if (!existingOptions?.length && newOptions?.length) {
    yield {
      key: "options",
      original: "no options present",
      expected: "options present"
    };
  } else if (existingOptions?.length && !newOptions?.length) {
    yield {
      key: "options",
      original: "options present",
      expected: "no options present"
    };
  } else if (newOptions?.length) {
    let index = 0;
    for (const option of newOptions) {
      const currentIndex = index++;
      const existingOption = existingOptions[currentIndex];
      yield* option_cjs.reportOptionDifferences({ currentIndex, option, existingOption });
    }
    if (index < existingOptions.length) {
      let option;
      while ((option = existingOptions[index]) !== void 0) {
        const expectedType = _shared_cjs.optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
        yield {
          key: `existing command option at index ${index}`,
          expected: "no option present",
          original: `${expectedType} with name ${option.name}`
        };
        index++;
      }
    }
  }
}
__name(checkOptions, "checkOptions");

exports.checkOptions = checkOptions;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=options.cjs.map