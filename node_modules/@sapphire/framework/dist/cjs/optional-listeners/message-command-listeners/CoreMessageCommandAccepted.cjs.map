{"version":3,"sources":["../../../../src/optional-listeners/message-command-listeners/CoreMessageCommandAccepted.ts"],"names":["result"],"mappings":";;;;AAAA,SAAS,cAAc;AACvB,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,cAAkD;AAEpD,IAAM,gBAAN,MAAM,sBAAqB,SAA+C;AAAA,EACzE,YAAY,SAAiC;AACnD,UAAM,SAAS,EAAE,OAAO,OAAO,uBAAuB,CAAC;AAAA,EACxD;AAAA,EAEA,MAAa,IAAI,SAAwC;AACxD,UAAM,EAAE,SAAS,SAAS,YAAY,QAAQ,IAAI;AAClD,UAAM,OAAO,MAAM,QAAQ,gBAAgB,SAAS,YAAY,OAAO;AAEvE,UAAM,SAAS,MAAM,OAAO,UAAU,YAAY;AACjD,cAAQ,OAAO,KAAK,OAAO,mBAAmB,SAAS,SAAS,EAAE,GAAG,SAAS,KAAK,CAAC;AAEpF,YAAM,YAAY,IAAI,UAAU;AAChC,YAAMA,UAAS,MAAM,QAAQ,WAAW,SAAS,MAAM,OAAO;AAC9D,YAAM,EAAE,SAAS,IAAI,UAAU,KAAK;AAEpC,cAAQ,OAAO,KAAK,OAAO,uBAAuB,EAAE,GAAG,SAAS,MAAM,QAAAA,SAAQ,SAAS,CAAC;AAExF,aAAO;AAAA,IACR,CAAC;AAED,WAAO,WAAW,CAAC,UAAU,QAAQ,OAAO,KAAK,OAAO,qBAAqB,OAAO,EAAE,GAAG,SAAS,MAAM,UAAU,GAAG,CAAC,CAAC;AAEvH,YAAQ,OAAO,KAAK,OAAO,sBAAsB,SAAS,SAAS;AAAA,MAClE,GAAG;AAAA,MACH;AAAA,MACA,SAAS,OAAO,KAAK;AAAA,MACrB,UAAU,OAAO,SAAS,EAAE;AAAA,IAC7B,CAAC;AAAA,EACF;AACD;AA9BiF;AAA1E,IAAM,eAAN","sourcesContent":["import { Result } from '@sapphire/result';\nimport { Stopwatch } from '@sapphire/stopwatch';\nimport { Listener } from '../../lib/structures/Listener';\nimport { Events, type MessageCommandAcceptedPayload } from '../../lib/types/Events';\n\nexport class CoreListener extends Listener<typeof Events.MessageCommandAccepted> {\n\tpublic constructor(context: Listener.LoaderContext) {\n\t\tsuper(context, { event: Events.MessageCommandAccepted });\n\t}\n\n\tpublic async run(payload: MessageCommandAcceptedPayload) {\n\t\tconst { message, command, parameters, context } = payload;\n\t\tconst args = await command.messagePreParse(message, parameters, context);\n\n\t\tconst result = await Result.fromAsync(async () => {\n\t\t\tmessage.client.emit(Events.MessageCommandRun, message, command, { ...payload, args });\n\n\t\t\tconst stopwatch = new Stopwatch();\n\t\t\tconst result = await command.messageRun(message, args, context);\n\t\t\tconst { duration } = stopwatch.stop();\n\n\t\t\tmessage.client.emit(Events.MessageCommandSuccess, { ...payload, args, result, duration });\n\n\t\t\treturn duration;\n\t\t});\n\n\t\tresult.inspectErr((error) => message.client.emit(Events.MessageCommandError, error, { ...payload, args, duration: -1 }));\n\n\t\tmessage.client.emit(Events.MessageCommandFinish, message, command, {\n\t\t\t...payload,\n\t\t\targs,\n\t\t\tsuccess: result.isOk(),\n\t\t\tduration: result.unwrapOr(-1)\n\t\t});\n\t}\n}\n"]}