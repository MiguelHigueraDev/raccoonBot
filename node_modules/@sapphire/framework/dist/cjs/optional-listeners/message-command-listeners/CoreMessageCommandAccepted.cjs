'use strict';

var result = require('@sapphire/result');
var stopwatch = require('@sapphire/stopwatch');
var Listener_cjs = require('../../lib/structures/Listener.cjs');
var Events_cjs = require('../../lib/types/Events.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var _CoreListener = class _CoreListener extends Listener_cjs.Listener {
  constructor(context) {
    super(context, { event: Events_cjs.Events.MessageCommandAccepted });
  }
  async run(payload) {
    const { message, command, parameters, context } = payload;
    const args = await command.messagePreParse(message, parameters, context);
    const result$1 = await result.Result.fromAsync(async () => {
      message.client.emit(Events_cjs.Events.MessageCommandRun, message, command, { ...payload, args });
      const stopwatch$1 = new stopwatch.Stopwatch();
      const result2 = await command.messageRun(message, args, context);
      const { duration } = stopwatch$1.stop();
      message.client.emit(Events_cjs.Events.MessageCommandSuccess, { ...payload, args, result: result2, duration });
      return duration;
    });
    result$1.inspectErr((error) => message.client.emit(Events_cjs.Events.MessageCommandError, error, { ...payload, args, duration: -1 }));
    message.client.emit(Events_cjs.Events.MessageCommandFinish, message, command, {
      ...payload,
      args,
      success: result$1.isOk(),
      duration: result$1.unwrapOr(-1)
    });
  }
};
__name(_CoreListener, "CoreListener");
var CoreListener = _CoreListener;

exports.CoreListener = CoreListener;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=CoreMessageCommandAccepted.cjs.map