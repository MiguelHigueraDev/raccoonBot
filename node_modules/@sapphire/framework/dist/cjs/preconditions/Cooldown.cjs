'use strict';

var pieces = require('@sapphire/pieces');
var ratelimits = require('@sapphire/ratelimits');
var discord_js = require('discord.js');
var Identifiers_cjs = require('../lib/errors/Identifiers.cjs');
var Precondition_cjs = require('../lib/structures/Precondition.cjs');
var Enums_cjs = require('../lib/types/Enums.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var _CorePrecondition = class _CorePrecondition extends Precondition_cjs.AllFlowsPrecondition {
  constructor() {
    super(...arguments);
    this.buckets = /* @__PURE__ */ new WeakMap();
  }
  messageRun(message, command, context) {
    const cooldownId = this.getIdFromMessage(message, context);
    return this.sharedRun(message.author.id, command, context, cooldownId, "message");
  }
  chatInputRun(interaction, command, context) {
    const cooldownId = this.getIdFromInteraction(interaction, context);
    return this.sharedRun(interaction.user.id, command, context, cooldownId, "chat input");
  }
  contextMenuRun(interaction, command, context) {
    const cooldownId = this.getIdFromInteraction(interaction, context);
    return this.sharedRun(interaction.user.id, command, context, cooldownId, "context menu");
  }
  sharedRun(authorId, command, context, cooldownId, commandType) {
    if (context.external)
      return this.ok();
    if (!context.delay)
      return this.ok();
    if (context.filteredUsers?.includes(authorId))
      return this.ok();
    const rateLimit = this.getManager(command, context).acquire(cooldownId);
    if (rateLimit.limited) {
      const remaining = rateLimit.remainingTime;
      const nextAvailable = discord_js.time(Math.floor(rateLimit.expires / 1e3), discord_js.TimestampStyles.RelativeTime);
      return this.error({
        identifier: Identifiers_cjs.Identifiers.PreconditionCooldown,
        message: `There is a cooldown in effect for this ${commandType} command. It'll be available ${nextAvailable}.`,
        context: { remaining }
      });
    }
    rateLimit.consume();
    return this.ok();
  }
  getIdFromMessage(message, context) {
    switch (context.scope) {
      case Enums_cjs.BucketScope.Global:
        return "global";
      case Enums_cjs.BucketScope.Channel:
        return message.channelId;
      case Enums_cjs.BucketScope.Guild:
        return message.guildId ?? message.channelId;
      default:
        return message.author.id;
    }
  }
  getIdFromInteraction(interaction, context) {
    switch (context.scope) {
      case Enums_cjs.BucketScope.Global:
        return "global";
      case Enums_cjs.BucketScope.Channel:
        return interaction.channelId;
      case Enums_cjs.BucketScope.Guild:
        return interaction.guildId ?? interaction.channelId;
      default:
        return interaction.user.id;
    }
  }
  getManager(command, context) {
    let manager = this.buckets.get(command);
    if (!manager) {
      manager = new ratelimits.RateLimitManager(context.delay, context.limit);
      this.buckets.set(command, manager);
    }
    return manager;
  }
};
__name(_CorePrecondition, "CorePrecondition");
var CorePrecondition = _CorePrecondition;
void pieces.container.stores.loadPiece({
  name: "Cooldown",
  piece: CorePrecondition,
  store: "preconditions"
});

exports.CorePrecondition = CorePrecondition;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Cooldown.cjs.map