import { Piece, Store, StoreRegistry, AliasPiece, AliasPieceJSON, AliasStore, LoaderStrategy } from '@sapphire/pieces';
export { AliasPiece, AliasPieceJSON, AliasPieceOptions, AliasStore, Container, LoaderError, LoaderPieceContext, MissingExportsError, Piece, PieceContext, PieceJSON, PieceLocationJSON, PieceOf, PieceOptions, Store, StoreManagerManuallyRegisteredPiece, StoreManuallyRegisteredPiece, StoreOf, StoreOptions, StoreRegistry, StoreRegistryEntries, StoreRegistryKey, StoreRegistryValue, container } from '@sapphire/pieces';
import { Awaitable, NonNullObject, Nullish } from '@sapphire/utilities';
export { Awaitable } from '@sapphire/utilities';
import * as discord_js from 'discord.js';
import { Interaction, Client, ClientEvents, Message, AutocompleteInteraction, ChatInputCommandInteraction, ContextMenuCommandInteraction, Snowflake, ChatInputApplicationCommandData, UserApplicationCommandData, MessageApplicationCommandData, ApplicationCommandManager, Collection, ApplicationCommand, ChannelType, PermissionsBitField, CommandInteraction, TextBasedChannel, PermissionResolvable, DMChannel, CategoryChannel, NewsChannel, ThreadChannel, TextChannel, StageChannel, VoiceChannel, GuildMember, Role, User, ClientOptions, Events as Events$1, PermissionsString, Guild, PartialDMChannel } from 'discord.js';
import { Result, Option } from '@sapphire/result';
export * from '@sapphire/result';
import { ChannelTypes, GuildBasedChannelTypes, TextBasedChannelTypes, AnyInteraction } from '@sapphire/discord.js-utilities';
import { ArgumentStream, IUnorderedStrategy, Lexer } from '@sapphire/lexure';
import { URL as URL$1 } from 'node:url';
import { EventEmitter } from 'node:events';
import { SlashCommandBuilder, SlashCommandSubcommandsOnlyBuilder, SlashCommandOptionsOnlyBuilder, ContextMenuCommandBuilder } from '@discordjs/builders';
import { RateLimitManager } from '@sapphire/ratelimits';

declare enum CooldownLevel {
    Author = "author",
    Channel = "channel",
    Guild = "guild"
}
declare enum PluginHook {
    PreGenericsInitialization = "preGenericsInitialization",
    PreInitialization = "preInitialization",
    PostInitialization = "postInitialization",
    PreLogin = "preLogin",
    PostLogin = "postLogin"
}
/**
 * The scope the cooldown applies to.
 */
declare enum BucketScope {
    /**
     * Per channel cooldowns.
     */
    Channel = 0,
    /**
     * Global cooldowns.
     */
    Global = 1,
    /**
     * Per guild cooldowns.
     */
    Guild = 2,
    /**
     * Per user cooldowns.
     */
    User = 3
}
declare enum RegisterBehavior {
    Overwrite = "OVERWRITE",
    LogToConsole = "LOG_TO_CONSOLE",
    /**
     * Finds all differences in the commands provided using our internal computation method, and logs them to the console, while applying them.
     *
     * @danger This can potentially cause slowdowns when booting up your bot as computing differences on big commands can take a while.
     * We recommend you use `OVERWRITE` instead in production.
     */
    VerboseOverwrite = "VERBOSE_OVERWRITE",
    /**
     * Makes Sapphire handle all command registrations, removals, and updates for you.
     *
     * This mode can only be set as the **default** behavior, and cannot be set per-command.
     *
     * In this mode:
     * - any `idHints` set per-command are no longer respected, and can be omitted.
     * - any `behaviorWhenNotIdentical` that are set per-command are no longer respected, and can be omitted.
     * - any application commands that are *not* registered through Sapphire's {@link ApplicationCommandRegistry} are removed from the application.
     * 	- the same applies for guild commands, but only for guilds that are registered in the registry via `guildIds`.
     */
    BulkOverwrite = "BULK_OVERWRITE"
}
declare enum InternalRegistryAPIType {
    ChatInput = 0,
    ContextMenu = 1
}
/**
 * The allowed values for {@link CommandOptions.runIn} as an enum.
 * @since 2.0.0
 */
declare enum CommandOptionsRunTypeEnum {
    Dm = "DM",
    GuildText = "GUILD_TEXT",
    GuildVoice = "GUILD_VOICE",
    GuildNews = "GUILD_NEWS",
    GuildNewsThread = "GUILD_NEWS_THREAD",
    GuildPublicThread = "GUILD_PUBLIC_THREAD",
    GuildPrivateThread = "GUILD_PRIVATE_THREAD",
    GuildAny = "GUILD_ANY"
}
/**
 * The available command pre-conditions.
 * @since 2.0.0
 */
declare enum CommandPreConditions {
    Cooldown = "Cooldown",
    /** @deprecated Use {@link RunIn} instead. */
    DirectMessageOnly = "DMOnly",
    RunIn = "RunIn",
    /** @deprecated Use {@link RunIn} instead. */
    GuildNewsOnly = "GuildNewsOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildNewsThreadOnly = "GuildNewsThreadOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildOnly = "GuildOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildPrivateThreadOnly = "GuildPrivateThreadOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildPublicThreadOnly = "GuildPublicThreadOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildTextOnly = "GuildTextOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildVoiceOnly = "GuildVoiceOnly",
    /** @deprecated Use {@link RunIn} instead. */
    GuildThreadOnly = "GuildThreadOnly",
    NotSafeForWork = "NSFW",
    ClientPermissions = "ClientPermissions",
    UserPermissions = "UserPermissions"
}

/**
 * The UserError class to be emitted in the pieces.
 * @property name This will be `'UserError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class UserError extends Error {
    /**
     * An identifier, useful to localize emitted errors.
     */
    readonly identifier: string;
    /**
     * User-provided context.
     */
    readonly context: unknown;
    /**
     * Constructs an UserError.
     * @param options The UserError options
     */
    constructor(options: UserError.Options);
    get name(): string;
}
declare namespace UserError {
    /**
     * The options for {@link UserError}.
     * @since 1.0.0
     */
    interface Options {
        /**
         * The identifier for this error.
         * @since 1.0.0
         */
        identifier: string;
        /**
         * The message to be passed to the Error constructor.
         * @since 1.0.0
         */
        message?: string;
        /**
         * The extra context to provide more information about this error.
         * @since 1.0.0
         * @default null
         */
        context?: unknown;
    }
}

declare enum Identifiers {
    ArgsMissing = "argsMissing",
    ArgsUnavailable = "argsUnavailable",
    ArgumentBooleanError = "booleanError",
    ArgumentChannelError = "channelError",
    ArgumentDateError = "dateError",
    ArgumentDateTooEarly = "dateTooEarly",
    ArgumentDateTooFar = "dateTooFar",
    ArgumentDMChannelError = "dmChannelError",
    ArgumentEmojiError = "emojiError",
    ArgumentFloatError = "floatError",
    ArgumentFloatTooLarge = "floatTooLarge",
    ArgumentFloatTooSmall = "floatTooSmall",
    ArgumentGuildError = "guildError",
    ArgumentGuildCategoryChannelError = "categoryChannelError",
    ArgumentGuildChannelError = "guildChannelError",
    ArgumentGuildChannelMissingGuildError = "guildChannelMissingGuildError",
    ArgumentGuildNewsChannelError = "guildNewsChannelError",
    ArgumentGuildNewsThreadChannelError = "guildNewsThreadChannelError",
    ArgumentGuildPrivateThreadChannelError = "guildPrivateThreadChannelError",
    ArgumentGuildPublicThreadChannelError = "guildPublicThreadChannelError",
    ArgumentGuildStageVoiceChannelError = "guildStageVoiceChannelError",
    ArgumentGuildTextChannelError = "guildTextChannelError",
    ArgumentGuildThreadChannelError = "guildThreadChannelError",
    ArgumentGuildVoiceChannelError = "guildVoiceChannelError",
    ArgumentHyperlinkError = "hyperlinkError",
    ArgumentIntegerError = "integerError",
    ArgumentIntegerTooLarge = "integerTooLarge",
    ArgumentIntegerTooSmall = "integerTooSmall",
    ArgumentMemberError = "memberError",
    ArgumentMemberMissingGuild = "memberMissingGuild",
    ArgumentMessageError = "messageError",
    ArgumentNumberError = "numberError",
    ArgumentNumberTooLarge = "numberTooLarge",
    ArgumentNumberTooSmall = "numberTooSmall",
    ArgumentRoleError = "roleError",
    ArgumentRoleMissingGuild = "roleMissingGuild",
    ArgumentStringTooLong = "stringTooLong",
    ArgumentStringTooShort = "stringTooShort",
    ArgumentUserError = "userError",
    ArgumentEnumEmptyError = "enumEmptyError",
    ArgumentEnumError = "enumError",
    CommandDisabled = "commandDisabled",
    PreconditionCooldown = "preconditionCooldown",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionDMOnly = "preconditionDmOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildNewsOnly = "preconditionGuildNewsOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildNewsThreadOnly = "preconditionGuildNewsThreadOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildOnly = "preconditionGuildOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildPrivateThreadOnly = "preconditionGuildPrivateThreadOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildPublicThreadOnly = "preconditionGuildPublicThreadOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildTextOnly = "preconditionGuildTextOnly",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionGuildVoiceOnly = "preconditionGuildVoiceOnly",
    PreconditionNSFW = "preconditionNsfw",
    PreconditionClientPermissions = "preconditionClientPermissions",
    PreconditionClientPermissionsNoClient = "preconditionClientPermissionsNoClient",
    PreconditionClientPermissionsNoPermissions = "preconditionClientPermissionsNoPermissions",
    PreconditionRunIn = "preconditionRunIn",
    PreconditionUserPermissions = "preconditionUserPermissions",
    PreconditionUserPermissionsNoPermissions = "preconditionUserPermissionsNoPermissions",
    /** @deprecated Use {@link PreconditionRunIn} instead. */
    PreconditionThreadOnly = "preconditionThreadOnly",
    PreconditionUnavailable = "preconditionUnavailable",
    PreconditionMissingMessageHandler = "preconditionMissingMessageHandler",
    PreconditionMissingChatInputHandler = "preconditionMissingChatInputHandler",
    PreconditionMissingContextMenuHandler = "preconditionMissingContextMenuHandler"
}

declare function resolveEmoji(parameter: string): Result<EmojiObject, Identifiers>;
interface EmojiObject {
    name: string | null;
    id: string | null;
    animated?: boolean;
}

interface InteractionHandlerOptions extends Piece.Options {
    /**
     * The type of interaction this handler is for. Must be one of {@link InteractionHandlerTypes}.
     */
    readonly interactionHandlerType: InteractionHandlerTypes;
}
interface InteractionHandlerJSON extends Piece.JSON {
    interactionHandlerType: InteractionHandlerTypes;
}
type InteractionHandlerParseResult<Instance extends InteractionHandler> = Option.UnwrapSome<Awaited<ReturnType<Instance['parse']>>>;
declare abstract class InteractionHandler<Options extends InteractionHandler.Options = InteractionHandler.Options> extends Piece<Options, 'interaction-handlers'> {
    /**
     * The type for this handler
     * @since 3.0.0
     */
    readonly interactionHandlerType: InteractionHandlerTypes;
    constructor(context: InteractionHandler.LoaderContext, options: Options);
    abstract run(interaction: Interaction, parsedData?: unknown): unknown;
    /**
     * A custom function that will be called when checking if an interaction should be passed to this handler.
     * You can use this method to not only filter by ids, but also pre-parse the data from the id for use in the run method.
     *
     * By default, all interactions of the type you specified will run in a handler. You should override this method
     * to change that behavior.
     *
     * @example
     * ```typescript
     * // Parsing a button handler
     * public override parse(interaction: ButtonInteraction) {
     *   if (interaction.customId.startsWith('my-awesome-clicky-button')) {
     * 	   // Returning a `some` here means that the run method should be called next!
     *     return this.some({ isMyBotAwesome: true, awesomenessLevel: 9001 });
     *   }
     *
     *   // Returning a `none` means this interaction shouldn't run in this handler
     *   return this.none();
     * }
     * ```
     *
     * @example
     * ```typescript
     * // Getting data from a database based on the custom id
     * public override async parse(interaction: ButtonInteraction) {
     *   // This code is purely for demonstration purposes only!
     *   if (interaction.customId.startsWith('example-data')) {
     *     const [, userId, channelId] = interaction.customId.split('.');
     *
     * 	   const dataFromDatabase = await container.prisma.exampleData.findFirst({ where: { userId, channelId } });
     *
     *     // Returning a `some` here means that the run method should be called next!
     *     return this.some(dataFromDatabase);
     *   }
     *
     *   // Returning a `none` means this interaction shouldn't run in this handler
     *   return this.none();
     * }
     * ```
     *
     * @returns An {@link Option} (or a {@link Promise Promised} {@link Option}) that indicates if this interaction should be
     * handled by this handler, and any extra data that should be passed to the {@link InteractionHandler.run run method}
     */
    parse(_interaction: Interaction): Awaitable<Option<unknown>>;
    some(): Option.Some<never>;
    some<T>(data: T): Option.Some<T>;
    none(): Option.None;
    toJSON(): InteractionHandlerJSON;
}
declare namespace InteractionHandler {
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Piece.LoaderContext<'interaction-handlers'>;
    type Options = InteractionHandlerOptions;
    type JSON = InteractionHandlerJSON;
    type ParseResult<Instance extends InteractionHandler> = InteractionHandlerParseResult<Instance>;
}
declare enum InteractionHandlerTypes {
    Button = 0,
    SelectMenu = 1,
    ModalSubmit = 2,
    MessageComponent = 3,
    Autocomplete = 4
}

interface ListenerOptions extends Piece.Options {
    readonly emitter?: keyof Client | EventEmitter;
    readonly event?: string | symbol;
    readonly once?: boolean;
}
interface ListenerJSON extends Piece.JSON {
    event: string | symbol;
    once: boolean;
}
/**
 * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In
 * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Events, Listener } from '@sapphire/framework';
 *
 * // Define a class extending `Listener`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreListener extends Listener<typeof Events.ClientReady> {
 *   public constructor(context: Listener.LoaderContext) {
 *     super(context, { event: Events.ClientReady, once: true });
 *   }
 *
 *   public run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Events, Listener } = require('@sapphire/framework');
 *
 * // Define a class extending `Listener`, then export it.
 * module.exports = class CoreListener extends Listener {
 *   constructor(context) {
 *     super(context, { event: Events.ClientReady, once: true });
 *   }
 *
 *   run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 */
declare abstract class Listener<E extends keyof ClientEvents | symbol = '', Options extends Listener.Options = Listener.Options> extends Piece<Options, 'listeners'> {
    /**
     * The emitter, if any.
     * @since 2.0.0
     */
    readonly emitter: EventEmitter | null;
    /**
     * The name of the event the listener listens to.
     * @since 2.0.0
     */
    readonly event: string | symbol;
    /**
     * Whether the listener will be unloaded after the first run.
     * @since 2.0.0
     */
    readonly once: boolean;
    private _listener;
    constructor(context: Listener.LoaderContext, options?: Options);
    abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;
    toJSON(): ListenerJSON;
    private _run;
    private _runOnce;
}
declare namespace Listener {
    type Options = ListenerOptions;
    type JSON = ListenerJSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Piece.LoaderContext<'listeners'>;
}

/**
 * The strategy options used in Sapphire.
 */
interface FlagStrategyOptions {
    /**
     * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    flags?: readonly string[] | boolean;
    /**
     * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    options?: readonly string[] | boolean;
    /**
     * The prefixes for both flags and options.
     * @default ['--', '-', '—']
     */
    prefixes?: string[];
    /**
     * The flag separators.
     * @default ['=', ':']
     */
    separators?: string[];
}

declare class InteractionHandlerStore extends Store<InteractionHandler, 'interaction-handlers'> {
    constructor();
    run(interaction: Interaction): Promise<boolean>;
}
declare const InteractionHandlerFilters: Map<InteractionHandlerTypes, (interaction: Interaction) => boolean>;

declare class ListenerStore extends Store<Listener, 'listeners'> {
    constructor();
}

/**
 * The logger levels for the {@link ILogger}.
 */
declare enum LogLevel {
    /**
     * The lowest log level, used when calling {@link ILogger.trace}.
     */
    Trace = 10,
    /**
     * The debug level, used when calling {@link ILogger.debug}.
     */
    Debug = 20,
    /**
     * The info level, used when calling {@link ILogger.info}.
     */
    Info = 30,
    /**
     * The warning level, used when calling {@link ILogger.warn}.
     */
    Warn = 40,
    /**
     * The error level, used when calling {@link ILogger.error}.
     */
    Error = 50,
    /**
     * The critical level, used when calling {@link ILogger.fatal}.
     */
    Fatal = 60,
    /**
     * An unknown or uncategorized level.
     */
    None = 100
}
interface ILogger {
    /**
     * Checks whether a level is supported.
     * @param level The level to check.
     */
    has(level: LogLevel): boolean;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Trace} as level.
     * @param values The values to log.
     */
    trace(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Debug} as level.
     * @param values The values to log.
     */
    debug(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Info} as level.
     * @param values The values to log.
     */
    info(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Warn} as level.
     * @param values The values to log.
     */
    warn(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Error} as level.
     * @param values The values to log.
     */
    error(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Fatal} as level.
     * @param values The values to log.
     */
    fatal(...values: readonly unknown[]): void;
    /**
     * Writes the log message given a level and the value(s).
     * @param level The log level.
     * @param values The values to log.
     */
    write(level: LogLevel, ...values: readonly unknown[]): void;
}

declare const preGenericsInitialization: unique symbol;
declare const preInitialization: unique symbol;
declare const postInitialization: unique symbol;
declare const preLogin: unique symbol;
declare const postLogin: unique symbol;

declare class ApplicationCommandRegistry {
    readonly commandName: string;
    readonly chatInputCommands: Set<string>;
    readonly contextMenuCommands: Set<string>;
    readonly guildIdsToFetch: Set<string>;
    globalCommandId: string | null;
    readonly guildCommandIds: Map<string, string>;
    private readonly apiCalls;
    constructor(commandName: string);
    get command(): Command<Args, CommandOptions> | undefined;
    registerChatInputCommand(command: ChatInputApplicationCommandData | SlashCommandBuilder | SlashCommandSubcommandsOnlyBuilder | SlashCommandOptionsOnlyBuilder | Omit<SlashCommandBuilder, 'addSubcommand' | 'addSubcommandGroup'> | ((builder: SlashCommandBuilder) => unknown), options?: ApplicationCommandRegistryRegisterOptions): this;
    registerContextMenuCommand(command: UserApplicationCommandData | MessageApplicationCommandData | ContextMenuCommandBuilder | ((builder: ContextMenuCommandBuilder) => unknown), options?: ApplicationCommandRegistryRegisterOptions): this;
    addChatInputCommandNames(...names: string[] | string[][]): this;
    addContextMenuCommandNames(...names: string[] | string[][]): this;
    addChatInputCommandIds(...commandIds: string[] | string[][]): this;
    addContextMenuCommandIds(...commandIds: string[] | string[][]): this;
    protected runAPICalls(applicationCommands: ApplicationCommandManager, globalCommands: Collection<string, ApplicationCommand>, guildCommands: Map<string, Collection<string, ApplicationCommand>>): Promise<void>;
    private getGuildIdsToRegister;
    private processGuildIds;
    private handleAPICall;
    private handleCommandPresent;
    private logCommandDifferencesFound;
    private createMissingCommand;
    private info;
    private error;
    private warn;
    private debug;
    private trace;
}
declare namespace ApplicationCommandRegistry {
    interface RegisterOptions {
        /**
         * If this is specified, the application commands will only be registered for these guild ids.
         */
        guildIds?: string[];
        /**
         * If we should register the command when it is missing
         * @default true
         */
        registerCommandIfMissing?: boolean;
        /**
         * Specifies what we should do when the command is present, but not identical with the data you provided
         * @default `ApplicationCommandRegistries.getDefaultBehaviorWhenNotIdentical()`
         */
        behaviorWhenNotIdentical?: Exclude<RegisterBehavior, RegisterBehavior.BulkOverwrite>;
        /**
         * Specifies a list of command ids that we should check in the event of a name mismatch
         * @default []
         */
        idHints?: string[];
    }
}
type ApplicationCommandRegistryRegisterOptions = ApplicationCommandRegistry.RegisterOptions;

interface CooldownPreconditionContext extends AllFlowsPrecondition.Context {
    scope?: BucketScope;
    delay: number;
    limit?: number;
    filteredUsers?: Snowflake[];
}
declare class CorePrecondition$e extends AllFlowsPrecondition {
    buckets: WeakMap<Command<Args, CommandOptions>, RateLimitManager<string>>;
    messageRun(message: Message, command: Command, context: CooldownPreconditionContext): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction, command: Command, context: CooldownPreconditionContext): AllFlowsPrecondition.Result;
    contextMenuRun(interaction: ContextMenuCommandInteraction, command: Command, context: CooldownPreconditionContext): AllFlowsPrecondition.Result;
    private sharedRun;
    private getIdFromMessage;
    private getIdFromInteraction;
    private getManager;
}

/**
 * Errors thrown by preconditions
 * @property name This will be `'PreconditionError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class PreconditionError extends UserError {
    readonly precondition: Precondition;
    constructor(options: PreconditionError.Options);
    get name(): string;
}
declare namespace PreconditionError {
    /**
     * The options for {@link PreconditionError}.
     * @since 1.0.0
     */
    interface Options extends Omit<UserError.Options, 'identifier'> {
        /**
         * The precondition that caused the error.
         * @since 1.0.0
         */
        precondition: Precondition;
        /**
         * The identifier.
         * @since 1.0.0
         * @default precondition.name
         */
        identifier?: string;
    }
}

type PreconditionResult = Awaitable<Result<unknown, UserError>>;
type AsyncPreconditionResult = Promise<Result<unknown, UserError>>;
/**
 * The registered preconditions and their contexts, if any. When registering new ones, it is recommended to use
 * [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) so
 * custom ones are registered.
 *
 * When a key's value is `never`, it means that it does not take any context, which allows you to pass its identifier as
 * a bare string (e.g. `preconditions: ['NSFW']`), however, if context is required, a non-`never` type should be passed,
 * which will type {@link PreconditionContainerArray#append} and require an object with the name and a `context` with
 * the defined type.
 *
 * @example
 * ```typescript
 * declare module '@sapphire/framework' {
 *   interface Preconditions {
 *     // A precondition named `Moderator` which does not read `context`:
 *     Moderator: never;
 *
 *     // A precondition named `ChannelPermissions` which does read `context`:
 *     ChannelPermissions: {
 *       permissions: Permissions;
 *     };
 *   }
 * }
 *
 * // [✔] These are valid:
 * preconditions.append('Moderator');
 * preconditions.append({ name: 'Moderator' });
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { permissions: new Permissions(8) }
 * });
 *
 * // [X] These are invalid:
 * preconditions.append({ name: 'Moderator', context: {} });
 * // ➡ `never` keys do not accept `context`.
 *
 * preconditions.append('ChannelPermissions');
 * // ➡ non-`never` keys always require `context`, a string cannot be used.
 *
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { unknownProperty: 1 }
 * });
 * // ➡ mismatching `context` properties, `{ unknownProperty: number }` is not
 * // assignable to `{ permissions: Permissions }`.
 * ```
 */
interface Preconditions {
    Cooldown: CooldownPreconditionContext;
    DMOnly: never;
    Enabled: never;
    GuildNewsOnly: never;
    GuildNewsThreadOnly: never;
    GuildOnly: never;
    GuildPrivateThreadOnly: never;
    GuildPublicThreadOnly: never;
    GuildTextOnly: never;
    GuildVoiceOnly: never;
    GuildThreadOnly: never;
    NSFW: never;
    RunIn: {
        types: readonly ChannelType[] | RunInPreconditionCommandSpecificData;
    };
    ClientPermissions: {
        permissions: PermissionsBitField;
    };
    UserPermissions: {
        permissions: PermissionsBitField;
    };
}
/**
 * The specific data for the precondition types for the `RunIn` precondition, when the command
 * specified the types for specific command types.
 */
interface RunInPreconditionCommandSpecificData {
    messageRun: readonly ChannelType[];
    chatInputRun: readonly ChannelType[];
    contextMenuRun: readonly ChannelType[];
}
type PreconditionKeys = keyof Preconditions;
type SimplePreconditionKeys = {
    [K in PreconditionKeys]: Preconditions[K] extends never ? K : never;
}[PreconditionKeys];
interface PreconditionOptions extends Piece.Options {
    /**
     * The position for the precondition to be set at in the global precondition list. If set to `null`, this
     * precondition will not be set as a global one.
     * @default null
     */
    position?: number | null;
}
interface PreconditionContext extends Record<PropertyKey, unknown> {
    external?: boolean;
}
declare class Precondition<Options extends Precondition.Options = Precondition.Options> extends Piece<Options, 'preconditions'> {
    readonly position: number | null;
    constructor(context: Precondition.LoaderContext, options?: Options);
    messageRun?(message: Message, command: MessageCommand, context: Precondition.Context): Precondition.Result;
    chatInputRun?(interaction: ChatInputCommandInteraction, command: ChatInputCommand, context: Precondition.Context): Precondition.Result;
    contextMenuRun?(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, context: Precondition.Context): Precondition.Result;
    ok(): Precondition.Result;
    /**
     * Constructs a {@link PreconditionError} with the precondition parameter set to `this`.
     * @param options The information.
     */
    error(options?: Omit<PreconditionError.Options, 'precondition'>): Precondition.Result;
    protected fetchChannelFromInteraction(interaction: CommandInteraction): Promise<TextBasedChannel>;
}
declare namespace Precondition {
    type Options = PreconditionOptions;
    type LoaderContext = Piece.LoaderContext<'preconditions'>;
    type Context = PreconditionContext;
    type Result = PreconditionResult;
    type AsyncResult = AsyncPreconditionResult;
}
declare abstract class AllFlowsPrecondition extends Precondition {
    abstract messageRun(message: Message, command: MessageCommand, context: Precondition.Context): Precondition.Result;
    abstract chatInputRun(interaction: ChatInputCommandInteraction, command: ChatInputCommand, context: Precondition.Context): Precondition.Result;
    abstract contextMenuRun(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, context: Precondition.Context): Precondition.Result;
}
declare namespace AllFlowsPrecondition {
    type Options = PreconditionOptions;
    type LoaderContext = Piece.LoaderContext<'preconditions'>;
    type Context = PreconditionContext;
    type Result = PreconditionResult;
    type AsyncResult = AsyncPreconditionResult;
}

/**
 * Defines the result's value for a PreconditionContainer.
 * @since 1.0.0
 */
type PreconditionContainerResult = Result<unknown, UserError>;
/**
 * Defines the return type of the generic {@link IPreconditionContainer.messageRun}.
 * @since 1.0.0
 */
type PreconditionContainerReturn = Awaitable<PreconditionContainerResult>;
/**
 * Async-only version of {@link PreconditionContainerReturn}, to be used when the run method is async.
 * @since 1.0.0
 */
type AsyncPreconditionContainerReturn = Promise<PreconditionContainerResult>;
/**
 * An abstracted precondition container to be implemented by classes.
 * @since 1.0.0
 */
interface IPreconditionContainer {
    /**
     * Runs a precondition container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param context The context for the precondition.
     */
    messageRun(message: Message, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs a precondition container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context The context for the precondition.
     */
    chatInputRun(interaction: ChatInputCommandInteraction, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs a precondition container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context The context for the precondition.
     */
    contextMenuRun(interaction: ContextMenuCommandInteraction, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
}

/**
 * Defines the simple options for the {@link PreconditionContainerSingle}, where only the name of the precondition can
 * be defined.
 * @since 2.0.0
 */
interface SimplePreconditionSingleResolvableDetails {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 2.0.0
     */
    name: SimplePreconditionKeys;
}
/**
 * Defines the detailed options for the {@link PreconditionContainerSingle}, where both the {@link PreconditionContext} and the
 * name of the precondition can be defined.
 * @since 1.0.0
 */
interface PreconditionSingleResolvableDetails<K extends PreconditionKeys = PreconditionKeys> {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 1.0.0
     */
    name: K;
    /**
     * The context to be set at {@link PreconditionContainerSingle.context}.
     * @since 1.0.0
     */
    context: Preconditions[K];
}
/**
 * Defines the data accepted by {@link PreconditionContainerSingle}'s constructor.
 * @since 1.0.0
 */
type PreconditionSingleResolvable = SimplePreconditionKeys | SimplePreconditionSingleResolvableDetails | PreconditionSingleResolvableDetails;
/**
 * An {@link IPreconditionContainer} which runs a single precondition from {@link SapphireClient.preconditions}.
 * @since 1.0.0
 */
declare class PreconditionContainerSingle implements IPreconditionContainer {
    /**
     * The context to be used when calling {@link Precondition.run}. This will always be an empty object (`{}`) when the
     * container was constructed with a string, otherwise it is a direct reference to the value from
     * {@link PreconditionSingleResolvableDetails.context}.
     * @since 1.0.0
     */
    readonly context: Record<PropertyKey, unknown>;
    /**
     * The name of the precondition to run.
     * @since 1.0.0
     */
    readonly name: string;
    constructor(data: PreconditionSingleResolvable);
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param context  The context for the message precondition.
     */
    messageRun(message: Message, command: MessageCommand, context?: PreconditionContext): PreconditionResult;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context  The context for the chat input command precondition.
     */
    chatInputRun(interaction: ChatInputCommandInteraction, command: ChatInputCommand, context?: PreconditionContext): PreconditionResult;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context  The context for the context menu command precondition.
     */
    contextMenuRun(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, context?: PreconditionContext): PreconditionResult;
}

/**
 * Defines the condition for {@link PreconditionContainerArray}s to run.
 * @since 1.0.0
 */
interface IPreconditionCondition {
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.Sequential}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    messageSequential(message: Message, command: MessageCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.Parallel}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    messageParallel(message: Message, command: MessageCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.Sequential}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    chatInputSequential(interaction: ChatInputCommandInteraction, command: ChatInputCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.Parallel}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    chatInputParallel(interaction: ChatInputCommandInteraction, command: ChatInputCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.Sequential}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    contextMenuSequential(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.Parallel}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     * @param context The context for the precondition.
     */
    contextMenuParallel(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
}

/**
 * The run mode for a {@link PreconditionContainerArray}.
 * @since 1.0.0
 */
declare enum PreconditionRunMode {
    /**
     * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous
     * tasks, but is performance savvy.
     * @since 1.0.0
     */
    Sequential = 0,
    /**
     * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have
     * completed.
     * @since 1.0.0
     */
    Parallel = 1
}
/**
 * The condition for a {@link PreconditionContainerArray}.
 */
declare enum PreconditionRunCondition {
    /**
     * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.
     * @since 1.0.0
     */
    And = 0,
    /**
     * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.
     * @since 1.0.0
     */
    Or = 1
}
/**
 * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the
 * entries can be defined.
 * @since 1.0.0
 */
interface PreconditionArrayResolvableDetails {
    /**
     * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.
     * @since 1.0.0
     */
    entries: readonly PreconditionEntryResolvable[];
    /**
     * The mode the {@link PreconditionContainerArray} will run.
     * @since 1.0.0
     */
    mode: PreconditionRunMode;
}
/**
 * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.
 * @since 1.0.0
 */
type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;
/**
 * Defines the data accepted for each entry of the array.
 * @since 1.0.0
 * @seealso {@link PreconditionArrayResolvable}
 * @seealso {@link PreconditionArrayResolvableDetails.entries}
 */
type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;
/**
 * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.
 *
 * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level
 * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).
 *
 * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:
 * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.
 * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.
 * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.
 *
 * In other words, it is identical to doing:
 * ```typescript
 * Connect && (Moderator || (DJ && SongAuthor));
 * ```
 * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),
 * see {@link PreconditionContainerArray.conditions} for more information.
 * @since 1.0.0
 */
declare class PreconditionContainerArray implements IPreconditionContainer {
    /**
     * The mode at which this precondition will run.
     * @since 1.0.0
     */
    readonly mode: PreconditionRunMode;
    /**
     * The {@link IPreconditionContainer}s the array holds.
     * @since 1.0.0
     */
    readonly entries: IPreconditionContainer[];
    /**
     * The {@link PreconditionRunCondition} that defines how entries must be handled.
     * @since 1.0.0
     */
    readonly runCondition: PreconditionRunCondition;
    constructor(data?: PreconditionArrayResolvable, parent?: PreconditionContainerArray | null);
    /**
     * Adds a new entry to the array.
     * @since 1.0.0
     * @param entry The value to add to the entries.
     */
    add(entry: IPreconditionContainer): this;
    append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;
    append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param context The context for the message command precondition.
     */
    messageRun(message: Message, command: MessageCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context The context for the chat input precondition.
     */
    chatInputRun(interaction: ChatInputCommandInteraction, command: ChatInputCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param context  The context for the context menu precondition.
     */
    contextMenuRun(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Parses the precondition entry resolvables, and adds them to the entries.
     * @since 1.0.0
     * @param entries The entries to parse.
     */
    protected parse(entries: Iterable<PreconditionEntryResolvable>): this;
    /**
     * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.
     * @since 1.0.0
     */
    protected get condition(): IPreconditionCondition;
    /**
     * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then
     * inserting {@link IPreconditionCondition}s.
     * @since 1.0.0
     * @example
     * ```typescript
     * // Adding more kinds of conditions
     *
     * // Set the new condition:
     * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);
     *
     * // Augment Sapphire to add the new condition, in case of a JavaScript
     * // project, this can be moved to an `Augments.d.ts` (or any other name)
     * // file somewhere:
     * declare module '@sapphire/framework' {
     *   export enum PreconditionRunCondition {
     *     Random = 2
     *   }
     * }
     * ```
     */
    static readonly conditions: Collection<PreconditionRunCondition, IPreconditionCondition>;
}

type DetailedDescriptionCommand = string | DetailedDescriptionCommandObject;
interface DetailedDescriptionCommandObject extends NonNullObject {
}
/**
 * The allowed values for {@link CommandOptions.runIn}.
 * @remark It is discouraged to use this type, we recommend using {@link CommandOptionsRunTypeEnum} instead.
 * @since 2.0.0
 */
type CommandOptionsRunType = 'DM' | 'GUILD_TEXT' | 'GUILD_VOICE' | 'GUILD_NEWS' | 'GUILD_NEWS_THREAD' | 'GUILD_PUBLIC_THREAD' | 'GUILD_PRIVATE_THREAD' | 'GUILD_ANY';
/**
 * The allowed values for {@link CommandOptions.runIn}.
 * @since 4.7.0
 */
type CommandRunInUnion = ChannelType | Command.RunInTypes | CommandOptionsRunTypeEnum | readonly (ChannelType | Command.RunInTypes | CommandOptionsRunTypeEnum)[] | Nullish;
/**
 * A more detailed structure for {@link CommandOptions.runIn} when you want to have a different `runIn` for each
 * command type.
 * @since 4.7.0
 */
interface CommandSpecificRunIn {
    chatInputRun?: CommandRunInUnion;
    messageRun?: CommandRunInUnion;
    contextMenuRun?: CommandRunInUnion;
}
/**
 * The {@link Command} options.
 * @since 1.0.0
 */
interface CommandOptions extends AliasPiece.Options, FlagStrategyOptions {
    /**
     * Whether to add aliases for commands with dashes in them
     * @since 1.0.0
     * @default false
     */
    generateDashLessAliases?: boolean;
    /**
     * Whether to add aliases for commands with underscores in them
     * @since 3.0.0
     * @default false
     */
    generateUnderscoreLessAliases?: boolean;
    /**
     * The description for the command.
     * @since 1.0.0
     * @default ''
     */
    description?: string;
    /**
     * The detailed description for the command.
     * @since 1.0.0
     * @default ''
     */
    detailedDescription?: DetailedDescriptionCommand;
    /**
     * The full category path for the command
     * @since 2.0.0
     * @default 'An array of folder names that lead back to the folder that is registered for in the commands store'
     * @example
     * ```typescript
     * // Given a file named `ping.js` at the path of `commands/General/ping.js`
     * ['General']
     *
     * // Given a file named `info.js` at the path of `commands/General/About/ping.js`
     * ['General', 'About']
     * ```
     */
    fullCategory?: string[];
    /**
     * The {@link Precondition}s to be run, accepts an array of their names.
     * @seealso {@link PreconditionContainerArray}
     * @since 1.0.0
     * @default []
     */
    preconditions?: readonly PreconditionEntryResolvable[];
    /**
     * The quotes accepted by this command, pass `[]` to disable them.
     * @since 1.0.0
     * @default
     * [
     *   ['"', '"'], // Double quotes
     *   ['“', '”'], // Fancy quotes (on iOS)
     *   ['「', '」'] // Corner brackets (CJK)
     *   ['«', '»'] // French quotes (guillemets)
     * ]
     */
    quotes?: [string, string][];
    /**
     * Sets whether the command should be treated as NSFW. If set to true, the `NSFW` precondition will be added to the list.
     * @since 2.0.0
     * @default false
     */
    nsfw?: boolean;
    /**
     * The amount of entries the cooldown can have before filling up, if set to a non-zero value alongside {@link CommandOptions.cooldownDelay}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 1
     */
    cooldownLimit?: number;
    /**
     * The time in milliseconds for the cooldown entries to reset, if set to a non-zero value alongside {@link CommandOptions.cooldownLimit}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 0
     */
    cooldownDelay?: number;
    /**
     * The scope of the cooldown entries.
     * @since 2.0.0
     * @default BucketScope.User
     */
    cooldownScope?: BucketScope;
    /**
     * The users that are exempt from the Cooldown precondition.
     * Use this to filter out someone like a bot owner
     * @since 2.0.0
     * @default undefined
     */
    cooldownFilteredUsers?: Snowflake[];
    /**
     * The required permissions for the client.
     * @since 2.0.0
     * @default 0
     */
    requiredClientPermissions?: PermissionResolvable;
    /**
     * The required permissions for the user.
     * @since 2.0.0
     * @default 0
     */
    requiredUserPermissions?: PermissionResolvable;
    /**
     * The channels the command should run in. If set to `null`, no precondition entry will be added.
     * Some optimizations are applied when given an array to reduce the amount of preconditions run
     * (e.g. `'GUILD_TEXT'` and `'GUILD_NEWS'` becomes `'GUILD_ANY'`, and if both `'DM'` and `'GUILD_ANY'` are defined,
     * then no precondition entry is added as it runs in all channels).
     *
     * This can be both {@link CommandRunInUnion} which will have the same precondition apply to all the types of commands,
     * or you can use {@link CommandSpecificRunIn} to apply different preconditions to different types of commands.
     * @since 2.0.0
     * @default null
     */
    runIn?: CommandRunInUnion | CommandSpecificRunIn;
    /**
     * If {@link SapphireClient.typing} is true, this option will override it.
     * Otherwise, this option has no effect - you may call {@link Channel#sendTyping}` in the run method if you want specific commands to display the typing status.
     * @default true
     */
    typing?: boolean;
}
interface MessageCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The prefix used to run this command.
     *
     * This is a string for the mention and default prefix, and a RegExp for the `regexPrefix`.
     */
    prefix: string | RegExp;
    /**
     * The alias used to run this command.
     */
    commandName: string;
    /**
     * The matched prefix, this will always be the same as {@link MessageCommand.RunContext.prefix} if it was a string, otherwise it is
     * the result of doing `prefix.exec(content)[0]`.
     */
    commandPrefix: string;
}
interface ChatInputCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface ContextMenuCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface AutocompleteCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface CommandJSON extends AliasPieceJSON {
    description: string;
    detailedDescription: DetailedDescriptionCommand;
    category: string | null;
}
type AutocompleteCommand = Command & Required<Pick<Command, 'autocompleteRun'>>;
declare namespace AutocompleteCommand {
    type Options = Command.Options;
    type JSON = Command.JSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Command.LoaderContext;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = AutocompleteCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = AutocompleteInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
type ContextMenuCommand = Command & Required<Pick<Command, 'contextMenuRun'>>;
declare namespace ContextMenuCommand {
    type Options = Command.Options;
    type JSON = Command.JSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Command.LoaderContext;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = ContextMenuCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = ContextMenuCommandInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
type MessageCommand = Command & Required<Pick<Command, 'messageRun'>>;
declare namespace MessageCommand {
    type Options = Command.Options;
    type JSON = Command.JSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Command.LoaderContext;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = MessageCommandContext;
}
type ChatInputCommand = Command & Required<Pick<Command, 'chatInputRun'>>;
declare namespace ChatInputCommand {
    type Options = Command.Options;
    type JSON = Command.JSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = Command.LoaderContext;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = ChatInputCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = ChatInputCommandInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}

/**
 * Defines a synchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.
 */
type ArgumentResult<T> = Result<T, ArgumentError<T>>;
/**
 * Defines a synchronous or asynchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.
 */
type AwaitableArgumentResult<T> = Awaitable<ArgumentResult<T>>;
/**
 * Defines an asynchronous result of an {@link Argument}, check {@link Argument.Result} for the synchronous version.
 */
type AsyncArgumentResult<T> = Promise<ArgumentResult<T>>;
interface IArgument<T> {
    /**
     * The name of the argument, this is used to make the identification of an argument easier.
     */
    readonly name: string;
    /**
     * The method which is called when invoking the argument.
     * @param parameter The string parameter to parse.
     * @param context The context for the method call, contains the message, command, and other options.
     */
    run(parameter: string, context: Argument.Context<T>): Argument.AwaitableResult<T>;
}
interface ArgumentOptions extends AliasPiece.Options {
}
interface ArgumentContext<T = unknown> extends Record<PropertyKey, unknown> {
    argument: IArgument<T>;
    args: Args;
    message: Message;
    command: MessageCommand;
    commandContext: MessageCommand.RunContext;
    minimum?: number;
    maximum?: number;
    inclusive?: boolean;
}
/**
 * The base argument class. This class is abstract and is to be extended by subclasses implementing the methods. In
 * Sapphire's workflow, arguments are called when using {@link Args}'s methods (usually used inside {@link Command}s by default).
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Argument } from '@sapphire/framework';
 * import { URL } from 'node:url';
 *
 * // Define a class extending `Argument`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreArgument extends Argument<URL> {
 *   public constructor(context: Argument.LoaderContext) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   public run(argument: string, context: Argument.Context): Argument.Result<URL> {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error({
 *         parameter: argument,
 *         context,
 *         identifier: 'ArgumentHyperlinkInvalidURL',
 *         message: 'The argument did not resolve to a valid URL.'
 *       });
 *     }
 *   }
 * }
 *
 * // Augment the ArgType structure so `args.pick('url')`, `args.repeat('url')`
 * // and others have a return type of `URL`.
 * declare module '@sapphire/framework' {
 *   export interface ArgType {
 *     url: URL;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Argument } = require('@sapphire/framework');
 *
 * // Define a class extending `Argument`, then export it.
 * module.exports = class CoreArgument extends Argument {
 *   constructor(context) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   run(argument, context) {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error({
 *         parameter: argument,
 *         context,
 *         identifier: 'ArgumentHyperlinkInvalidURL',
 *         message: 'The argument did not resolve to a valid URL.'
 *       });
 *     }
 *   }
 * }
 * ```
 */
declare abstract class Argument<T = unknown, Options extends Argument.Options = Argument.Options> extends AliasPiece<Options, 'arguments'> implements IArgument<T> {
    constructor(context: Argument.LoaderContext, options?: Options);
    abstract run(parameter: string, context: Argument.Context<T>): Argument.AwaitableResult<T>;
    /**
     * Wraps a value into a successful value.
     * @param value The value to wrap.
     */
    ok(value: T): Argument.Result<T>;
    /**
     * Constructs an {@link Err} result containing an {@link ArgumentError} with a custom type.
     * @param options The options to pass to the ArgumentError.
     */
    error(options: Omit<ArgumentError.Options<T>, 'argument'>): Argument.Result<T>;
}
declare namespace Argument {
    type Options = ArgumentOptions;
    type Context<T = unknown> = ArgumentContext<T>;
    type LoaderContext = AliasPiece.LoaderContext<'arguments'>;
    type Result<T> = ArgumentResult<T>;
    type AwaitableResult<T> = AwaitableArgumentResult<T>;
    type AsyncResult<T> = AsyncArgumentResult<T>;
}

/**
 * Errors thrown by the argument parser
 * @since 1.0.0
 * @property name This will be `'ArgumentError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class ArgumentError<T = unknown> extends UserError {
    readonly argument: IArgument<T>;
    readonly parameter: string;
    constructor(options: ArgumentError.Options<T>);
    get name(): string;
}
declare namespace ArgumentError {
    /**
     * The options for {@link ArgumentError}.
     * @since 1.0.0
     */
    interface Options<T> extends Omit<UserError.Options, 'identifier'> {
        /**
         * The argument that caused the error.
         * @since 1.0.0
         */
        argument: IArgument<T>;
        /**
         * The parameter that failed to be parsed.
         * @since 1.0.0
         */
        parameter: string;
        /**
         * The identifier.
         * @since 1.0.0
         * @default argument.name
         */
        identifier?: string;
    }
}

/**
 * The argument parser to be used in {@link Command}.
 */
declare class Args {
    /**
     * The original message that triggered the command.
     */
    readonly message: Message;
    /**
     * The command that is being run.
     */
    readonly command: MessageCommand;
    /**
     * The context of the command being run.
     */
    readonly commandContext: MessageCommand.RunContext;
    /**
     * The internal Lexure parser.
     */
    protected readonly parser: ArgumentStream;
    /**
     * The states stored in the args.
     * @see Args#save
     * @see Args#restore
     */
    private readonly states;
    constructor(message: Message, command: MessageCommand, parser: ArgumentStream, context: MessageCommand.RunContext);
    /**
     * Sets the parser to the first token.
     */
    start(): Args;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @param options The pickResult options.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((parameter, { argument }) => {
     *   const parsed = Number(parameter);
     *   if (Number.isNaN(parsed)) {
     *     return Args.error({ argument, parameter, identifier: 'ArgumentNumberNaN', message: 'You must write a valid number.' });
     *   }
     *
     *   return Args.ok(parsed);
     * });
     *
     * const a = await args.pickResult(resolver);
     * if (!a.success) throw new UserError('ArgumentNumberNaN', 'You must write a valid number.');
     *
     * await message.channel.send(`The result is: ${a.value ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pickResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<ResultType<T>>;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @param options The pickResult options.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the first one did not match.');
     *
     * const b = await args.pickResult('integer');
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the second one did not match.');
     *
     * await message.channel.send(`The result is: ${a.value + b.value}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pickResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ResultType<ArgType[K]>>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The pick options.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((parameter, { argument }) => {
     *   const parsed = Number(parameter);
     *   if (Number.isNaN(parsed)) {
     *     return Args.error({ argument, parameter, identifier: 'ArgumentNumberNaN', message: 'You must write a valid number.' });
     *   }
     *
     *   return Args.ok(parsed);
     * });
     *
     * const a = await args.pick(resolver);
     *
     * await message.channel.send(`The result is: ${a ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pick<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The pick options.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pick('integer');
     * const b = await args.pick('integer');
     * await message.channel.send(`The result is: ${a + b}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pick<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @param options The restResult options.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((parameter) => Args.ok(parameter.split('').reverse()));
     *
     * const a = await args.restResult(resolver);
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write some text.');
     *
     * await message.channel.send(`The reversed value is... ${a.value}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    restResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<ResultType<T>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @param options The restResult options.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the former did not match.');
     *
     * const b = await args.restResult('string', { minimum: 1 });
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the latter did not match.');
     *
     * await message.channel.send(`The repeated value is... ${b.value.repeat(a.value)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    restResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ResultType<ArgType[K]>>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The rest options.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((arg) => Args.ok(arg.split('').reverse()));
     * const a = await args.rest(resolver);
     * await message.channel.send(`The reversed value is... ${a}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    rest<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The rest options.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pick('integer');
     * const b = await args.rest('string', { minimum: 1 });
     * await message.channel.send(`The repeated value is... ${b.repeat(a)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    rest<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @param options The repeatResult options.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const resolver = Args.make((arg) => Args.ok(arg.split('').reverse()));
     * const result = await args.repeatResult(resolver, { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): olleH !dlroW"
     * ```
     */
    repeatResult<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<ArrayResultType<T>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @param options The repeatResult options.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const result = await args.repeatResult('string', { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeatResult<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<ArrayResultType<ArgType[K]>>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The repeat options.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const resolver = Args.make((arg) => Args.ok(arg.split('').reverse()));
     * const result = await args.repeat(resolver, { times: 5 });
     * await message.channel.send(`You have written ${result.length} word(s): ${result.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<T[]>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @param options The repeat options.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const words = await args.repeat('string', { times: 5 });
     * await message.channel.send(`You have written ${words.length} word(s): ${words.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<ArgType[K][]>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !reversedandscreamfirst hello world
     * const resolver = Args.make((arg) => Args.ok(arg.split('').reverse().join('')));
     *
     * const result = await args.repeatResult(resolver);
     * await result.inspectAsync((value) =>
     * 	message.channel.send(`Reversed ${value.length} word(s): ${value.join(' ')}`)
     * ); // Reversed 2 word(s): olleh dlrow
     *
     * const firstWord = await args.pickResult('string');
     * await firstWord.inspectAsync((value) =>
     * 	message.channel.send(firstWord.value.toUpperCase())
     * ); // HELLO
     * ```
     */
    peekResult<T>(type: () => Argument.Result<T>): Promise<ResultType<T>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @param options The peekResult options.
     * @example
     * ```typescript
     * // !reverseandscreamfirst sapphire community
     * const resolver = Args.make((arg) => Args.ok(arg.split('').reverse().join('')));
     *
     * const peekedWord = await args.peekResult(resolver);
     * await peekedWord.inspectAsync((value) => message.channel.send(value)); // erihppas
     *
     * const firstWord = await args.pickResult('string');
     * await firstWord.inspectAsync((value) => message.channel.send(value.toUpperCase())); // SAPPHIRE
     * ```
     */
    peekResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<ResultType<T>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @param options The peekResult options.
     * @example
     * ```typescript
     * // !datethenaddtwo 1608867472611
     * const date = await args.peekResult('date');
     * await date.inspectAsync((value) =>
     * 	message.channel.send(`Your date (in UTC): ${value.toUTCString()}`)
     * ); // Your date (in UTC): Fri, 25 Dec 2020 03:37:52 GMT
     *
     * const result = await args.pickResult('number', { maximum: Number.MAX_SAFE_INTEGER - 2 });
     * await result.inspectAsync((value) =>
     * 	message.channel.send(`Your number plus two: ${value + 2}`)
     * ); // Your number plus two: 1608867472613
     * ```
     */
    peekResult<K extends keyof ArgType>(type: (() => Awaitable<Argument.Result<ArgType[K]>>) | K, options?: ArgOptions): Promise<ResultType<ArgType[K]>>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !bigintsumthensquarefirst 25 50 75
     * const resolver = Args.make((arg, { argument }) => {
     *   try {
     *     return Args.ok(BigInt(arg));
     *   } catch {
     *     return Args.error({ parameter: arg, argument, identifier: 'InvalidBigInt', message: 'You must specify a valid number for a bigint.' })
     *   }
     * });
     *
     * const peeked = await args.repeatResult(resolver);
     * await peeked.inspectAsync((value) => message.channel.send(`Sum: **${value.reduce((x, y) => x + y, 0n)}**`)); // Sum: 150n
     *
     * const first = await args.pick(resolver);
     * await message.channel.send(`First bigint squared: ${first**2n}`); // First bigint squared: 625
     * ```
     */
    peek<T>(type: () => Argument.Result<T>): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @param options The peek options.
     * @example
     * ```typescript
     * import { SnowflakeRegex } from '@sapphire/discord.js-utilities';
     * import { DiscordSnowflake } from '@sapphire/snowflake';
     *
     * // !createdat 730159185517477900
     * const snowflakeResolver = Args.make<bigint>((arg, { argument }) => {
     *   return SnowflakeRegex.test(arg)
     *     ? Args.ok(BigInt(arg))
     *     : Args.error({ parameter: arg, argument, identifier: 'InvalidSnowflake', message: 'You must specify a valid snowflake.' });
     * });
     *
     * const snowflake = await args.peek(snowflakeResolver);
     * const timestamp = Number((snowflake >> 22n) + DiscordSnowflake.epoch);
     * const createdAt = new Date(timestamp);
     *
     * await message.channel.send(
     *   `The snowflake ${snowflake} was registered on ${createdAt.toUTCString()}.`
     * ); // The snowflake 730159185517477900 was registered on Tue, 07 Jul 2020 20:31:55 GMT.
     *
     * const id = await args.pick('string');
     * await message.channel.send(`Your ID, reversed: ${id.split('').reverse().join('')}`); // Your ID, reversed: 009774715581951037
     * ```
     */
    peek<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @param options The peek options.
     * @example
     * ```typescript
     * // !messagelink https://discord.com/channels/737141877803057244/737142209639350343/791843123898089483
     * const remoteMessage = await args.peek('message');
     * await message.channel.send(
     *   `${remoteMessage.author.tag}: ${remoteMessage.content}`
     * ); // RealShadowNova#7462: Yeah, Sapphire has been a great experience so far, especially being able to help and contribute.
     *
     * const url = await args.pick('hyperlink');
     * await message.channel.send(`Hostname: ${url.hostname}`); // Hostname: discord.com
     * ```
     */
    peek<K extends keyof ArgType>(type: (() => Argument.Result<ArgType[K]>) | K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves the next raw argument from the parser.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.nextMaybe());
     * // -> { exists: true, value: '1' }
     * ```
     */
    nextMaybe(): Option<string>;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be used if the transformation succeeds.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> { exists: true, value: 1 }
     * ```
     */
    nextMaybe<T>(cb: ArgsNextCallback<T>): Option<T>;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.next());
     * // -> '1'
     * ```
     */
    next(): string;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> 1
     * ```
     */
    next<T>(cb: ArgsNextCallback<T>): T;
    /**
     * Checks if one or more flag were given.
     * @param keys The name(s) of the flag.
     * @example
     * ```typescript
     * // Suppose args are from '--f --g'.
     * console.log(args.getFlags('f'));
     * // >>> true
     *
     * console.log(args.getFlags('g', 'h'));
     * // >>> true
     *
     * console.log(args.getFlags('h'));
     * // >>> false
     * ```
     */
    getFlags(...keys: readonly string[]): boolean;
    /**
     * Gets the last value of one or more options as an {@link Option}.
     * If you do not care about safely handling non-existing values
     * you can use {@link Args.getOption} to get `string | null` as return type
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOptionResult('a'));
     * // >>> Some { value: '1' }
     *
     * console.log(args.getOptionResult('b', 'c'));
     * // >>> Some { value: '2' }
     *
     * console.log(args.getOptionResult('d'));
     * // >>> None {}
     * ```
     */
    getOptionResult(...keys: readonly string[]): Option<string>;
    /**
     * Gets the last value of one or more options.
     * Similar to {@link Args.getOptionResult} but returns the value on success, or `null` if not.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOption('a'));
     * // >>> '1'
     *
     * console.log(args.getOption('b', 'c'));
     * // >>> '2'
     *
     * console.log(args.getOption('d'));
     * // >>> null
     * ```
     */
    getOption(...keys: readonly string[]): string | null;
    /**
     * Gets all the values of one or more option.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptionsResult('a'));
     * // >>> Some { value: [ '1' ] }
     *
     * console.log(args.getOptionsResult('a', 'd'));
     * // >>> Some { value: [ '1' ] }
     *
     * console.log(args.getOptionsResult('b', 'c'));
     * // >>> Some { value: [ '2', '3' ] }
     *
     * console.log(args.getOptionsResult('d'));
     * // >>> None {}
     * ```
     */
    getOptionsResult(...keys: readonly string[]): Option<readonly string[]>;
    /**
     * Gets all the values of one or more option.
     * Similar to {@link Args.getOptionsResult} but returns the value on success, or `null` if not.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptions('a'));
     * // >>> ['1', '1']
     *
     * console.log(args.getOptions('b', 'c'));
     * // >>> ['2', '3']
     *
     * console.log(args.getOptions('d'));
     * // >>> null
     * ```
     */
    getOptions(...keys: readonly string[]): readonly string[] | null;
    /**
     * Saves the current state into the stack following a FILO strategy (first-in, last-out).
     * @see Args#restore
     */
    save(): void;
    /**
     * Restores the previously saved state from the stack.
     * @see Args#save
     */
    restore(): void;
    /**
     * Whether all arguments have been consumed.
     */
    get finished(): boolean;
    /**
     * Defines the `JSON.stringify` override.
     */
    toJSON(): ArgsJson;
    protected unavailableArgument<T>(type: string | IArgument<T>): Result.Err<UserError>;
    protected missingArguments(): Result.Err<UserError>;
    /**
     * Resolves an argument.
     * @param arg The argument name or {@link IArgument} instance.
     */
    private resolveArgument;
    /**
     * Converts a callback into a usable argument.
     * @param cb The callback to convert into an {@link IArgument}.
     * @param name The name of the argument.
     */
    static make<T>(cb: IArgument<T>['run'], name?: string): IArgument<T>;
    /**
     * Constructs an {@link Ok} result.
     * @param value The value to pass.
     */
    static ok<T>(value: T): Result.Ok<T>;
    /**
     * Constructs an {@link Err} result containing an {@link ArgumentError}.
     * @param options The options for the argument error.
     */
    static error<T>(options: ArgumentError.Options<T>): Result.Err<ArgumentError<T>>;
}
interface ArgsJson {
    message: Message<boolean>;
    command: MessageCommand;
    commandContext: MessageCommand.RunContext;
}
interface ArgType {
    boolean: boolean;
    channel: ChannelTypes;
    date: Date;
    dmChannel: DMChannel;
    emoji: EmojiObject;
    float: number;
    guildCategoryChannel: CategoryChannel;
    guildChannel: GuildBasedChannelTypes;
    guildNewsChannel: NewsChannel;
    guildNewsThreadChannel: ThreadChannel & {
        type: ChannelType.AnnouncementThread;
        parent: NewsChannel | null;
    };
    guildPrivateThreadChannel: ThreadChannel & {
        type: ChannelType.PrivateThread;
        parent: TextChannel | null;
    };
    guildPublicThreadChannel: ThreadChannel & {
        type: ChannelType.PublicThread;
        parent: TextChannel | null;
    };
    guildStageVoiceChannel: StageChannel;
    guildTextChannel: TextChannel;
    guildThreadChannel: ThreadChannel;
    guildVoiceChannel: VoiceChannel;
    hyperlink: URL$1;
    integer: number;
    member: GuildMember;
    message: Message;
    number: number;
    role: Role;
    string: string;
    url: URL$1;
    user: User;
    enum: string;
}
interface ArgOptions extends Omit<Argument.Context, 'message' | 'command'> {
}
interface RepeatArgOptions extends ArgOptions {
    /**
     * The maximum amount of times the argument can be repeated.
     * @default Infinity
     */
    times?: number;
}
/**
 * The callback used for {@link Args.nextMaybe} and {@link Args.next}.
 */
interface ArgsNextCallback<T> {
    /**
     * The value to be mapped.
     */
    (value: string): Option<T>;
}
type ResultType<T> = Result<T, UserError | ArgumentError<T>>;
type ArrayResultType<T> = Result<T[], UserError | ArgumentError<T>>;

declare class Command<PreParseReturn = Args, Options extends Command.Options = Command.Options> extends AliasPiece<Options, 'commands'> {
    /**
     * A basic summary about the command
     * @since 1.0.0
     */
    description: string;
    /**
     * The preconditions to be run.
     * @since 1.0.0
     */
    preconditions: PreconditionContainerArray;
    /**
     * Longer version of command's summary and how to use it
     * @since 1.0.0
     */
    detailedDescription: DetailedDescriptionCommand;
    /**
     * The full category for the command, can be overridden by setting the {@link Command.Options.fullCategory} option.
     *
     * If {@link Command.Options.fullCategory} is not set, then:
     * - If the command is loaded from the file system, then this is the command's location in file system relative to
     *   the commands folder. For example, if you have a command located at `commands/General/Information/info.ts` then
     *   this property will be `['General', 'Info']`.
     * - If the command is virtual, then this will be `[]`.
     *
     * @since 2.0.0
     */
    readonly fullCategory: readonly string[];
    /**
     * The strategy to use for the lexer.
     * @since 1.0.0
     */
    strategy: IUnorderedStrategy;
    /**
     * If {@link SapphireClient.typing} is true, it can be overridden for a specific command using this property, set via its options.
     * Otherwise, this property will be ignored.
     * @default true
     */
    typing: boolean;
    /**
     * The application command registry associated with this command.
     * @since 3.0.0
     */
    readonly applicationCommandRegistry: ApplicationCommandRegistry;
    /**
     * The lexer to be used for command parsing
     * @since 1.0.0
     * @private
     */
    protected lexer: Lexer;
    /**
     * @since 1.0.0
     * @param context The context.
     * @param options Optional Command settings.
     */
    constructor(context: Command.LoaderContext, options?: Options);
    /**
     * The message pre-parse method. This method can be overridden by plugins to define their own argument parser.
     * @param message The message that triggered the command.
     * @param parameters The raw parameters as a single string.
     * @param context The command-context used in this execution.
     */
    messagePreParse(message: Message, parameters: string, context: MessageCommand.RunContext): Awaitable<PreParseReturn>;
    /**
     * The main category for the command, if any.
     *
     * This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get category(): string | null;
    /**
     * The sub-category for the command, if any.
     *
     * This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise
     * it returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get subCategory(): string | null;
    /**
     * The parent category for the command.
     *
     * This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get parentCategory(): string | null;
    /**
     * Executes the message command's logic.
     * @param message The message that triggered the command.
     * @param args The value returned by {@link Command.messagePreParse}, by default an instance of {@link Args}.
     * @param context The context in which the command was executed.
     */
    messageRun?(message: Message, args: PreParseReturn, context: MessageCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the application command's logic.
     * @param interaction The interaction that triggered the command.
     * @param context The chat input command run context.
     */
    chatInputRun?(interaction: ChatInputCommandInteraction, context: ChatInputCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the context menu's logic.
     * @param interaction The interaction that triggered the command.
     * @param context The context menu command run context.
     */
    contextMenuRun?(interaction: ContextMenuCommandInteraction, context: ContextMenuCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the autocomplete logic.
     *
     * :::tip
     *
     * You may use this, or alternatively create an {@link InteractionHandler interaction handler} to handle autocomplete interactions.
     * Keep in mind that commands take precedence over interaction handlers.
     *
     * :::
     *
     * @param interaction The interaction that triggered the autocomplete.
     */
    autocompleteRun?(interaction: AutocompleteInteraction): Awaitable<unknown>;
    /**
     * Defines the JSON.stringify behavior of the command.
     */
    toJSON(): CommandJSON;
    /**
     * Registers the application commands that should be handled by this command.
     * @param registry This command's registry
     */
    registerApplicationCommands?(registry: ApplicationCommandRegistry): Awaitable<void>;
    /**
     * Type-guard that ensures the command supports message commands by checking if the handler for it is present
     */
    supportsMessageCommands(): this is MessageCommand;
    /**
     * Type-guard that ensures the command supports chat input commands by checking if the handler for it is present
     */
    supportsChatInputCommands(): this is ChatInputCommand;
    /**
     * Type-guard that ensures the command supports context menu commands by checking if the handler for it is present
     */
    supportsContextMenuCommands(): this is ContextMenuCommand;
    /**
     * Type-guard that ensures the command supports handling autocomplete interactions by checking if the handler for it is present
     */
    supportsAutocompleteInteractions(): this is AutocompleteCommand;
    reload(): Promise<void>;
    /**
     * Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},
     * {@link Command#parseConstructorPreConditionsNsfw},
     * {@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and
     * {@link Command#parseConstructorPreConditionsCooldown}.
     * @since 2.0.0
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditions(options: Command.Options): void;
    /**
     * Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsNsfw(options: Command.Options): void;
    /**
     * Appends the `RunIn` precondition based on the values passed, defaulting to `null`, which doesn't add a
     * precondition.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRunIn(options: Command.Options): void;
    /**
     * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredClientPermissions(options: Command.Options): void;
    /**
     * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredUserPermissions(options: Command.Options): void;
    /**
     * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and
     * {@link Command.Options.cooldownDelay} are both non-zero.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsCooldown(options: Command.Options): void;
    /**
     * Resolves the {@link Command.Options.runIn} option into a {@link Command.RunInTypes} array.
     * @param types The types to resolve.
     * @returns The resolved types, or `null` if no types were resolved.
     */
    protected resolveConstructorPreConditionsRunType(types: CommandRunInUnion): readonly ChannelType[] | null;
    static runInTypeIsSpecificsObject(types: Command.Options['runIn']): types is CommandSpecificRunIn;
}
declare namespace Command {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    /** @deprecated Use {@linkcode LoaderContext} instead. */
    type Context = LoaderContext;
    type LoaderContext = AliasPiece.LoaderContext<'commands'>;
    type RunInTypes = CommandOptionsRunType;
    type RunInUnion = CommandRunInUnion;
    type SpecificRunIn = CommandSpecificRunIn;
    type ChatInputCommandInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.ChatInputCommandInteraction<Cached>;
    type ContextMenuCommandInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.ContextMenuCommandInteraction<Cached>;
    type AutocompleteInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.AutocompleteInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}

/**
 * Stores all Command pieces
 * @since 1.0.0
 */
declare class CommandStore extends AliasStore<Command, 'commands'> {
    constructor();
    /**
     * Get all the command categories.
     */
    get categories(): string[];
    unload(name: string | Command): Promise<Command<Args, CommandOptions>>;
    loadAll(): Promise<void>;
}
/**
 * Acquires a registry for a command by its name.
 * @param commandName The name of the command.
 * @returns The application command registry for the command
 */
declare function acquire(commandName: string): ApplicationCommandRegistry;
/**
 * Sets the default behavior when registered commands aren't identical to provided data.
 * @param behavior The default behavior to have. Set this to `null` to reset it to the default
 * of `RegisterBehavior.Overwrite`.
 */
declare function setDefaultBehaviorWhenNotIdentical(behavior?: RegisterBehavior | null): void;
declare function getDefaultBehaviorWhenNotIdentical(): RegisterBehavior;
/**
 * Sets the default guild ids for registering commands. This is used when a command is registered _without_ providing
 * `guildIds` in that command's own {@link Command.registerApplicationCommands} method.
 * @param guildIds The default guildIds to set. Set this to `null` to reset it to the default
 * of `undefined`.
 */
declare function setDefaultGuildIds(guildIds?: ApplicationCommandRegistry.RegisterOptions['guildIds'] | null): void;
declare function getDefaultGuildIds(): string[] | undefined;

declare abstract class Plugin {
    static [preGenericsInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [postInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
    static [postLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
}

type AsyncPluginHooks = PluginHook.PreLogin | PluginHook.PostLogin;
interface SapphirePluginAsyncHook {
    (this: SapphireClient, options: ClientOptions): Awaitable<unknown>;
}
type SyncPluginHooks = Exclude<PluginHook, AsyncPluginHooks>;
interface SapphirePluginHook {
    (this: SapphireClient, options: ClientOptions): unknown;
}
interface SapphirePluginHookEntry<T = SapphirePluginHook | SapphirePluginAsyncHook> {
    hook: T;
    type: PluginHook;
    name?: string;
}
declare class PluginManager {
    readonly registry: Set<SapphirePluginHookEntry<SapphirePluginAsyncHook | SapphirePluginHook>>;
    registerHook(hook: SapphirePluginHook, type: SyncPluginHooks, name?: string): this;
    registerHook(hook: SapphirePluginAsyncHook, type: AsyncPluginHooks, name?: string): this;
    registerPreGenericsInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPostInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    registerPostLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    use(plugin: typeof Plugin): this;
    values(): Generator<SapphirePluginHookEntry, void, unknown>;
    values(hook: SyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginHook>, void, unknown>;
    values(hook: AsyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginAsyncHook>, void, unknown>;
}

declare class ArgumentStore extends AliasStore<Argument, 'arguments'> {
    constructor();
}

declare class PreconditionStore extends Store<Precondition, 'preconditions'> {
    private readonly globalPreconditions;
    constructor();
    messageRun(message: Message, command: MessageCommand, context?: Precondition.Context): AsyncPreconditionResult;
    chatInputRun(interaction: ChatInputCommandInteraction, command: ChatInputCommand, context?: Precondition.Context): AsyncPreconditionResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, context?: Precondition.Context): AsyncPreconditionResult;
    set(key: string, value: Precondition): this;
    delete(key: string): boolean;
    clear(): void;
}

declare const Events: {
    readonly ApplicationCommandPermissionsUpdate: Events$1.ApplicationCommandPermissionsUpdate;
    readonly AutoModerationActionExecution: Events$1.AutoModerationActionExecution;
    readonly AutoModerationRuleCreate: Events$1.AutoModerationRuleCreate;
    readonly AutoModerationRuleDelete: Events$1.AutoModerationRuleDelete;
    readonly AutoModerationRuleUpdate: Events$1.AutoModerationRuleUpdate;
    readonly CacheSweep: Events$1.CacheSweep;
    readonly ChannelCreate: Events$1.ChannelCreate;
    readonly ChannelDelete: Events$1.ChannelDelete;
    readonly ChannelPinsUpdate: Events$1.ChannelPinsUpdate;
    readonly ChannelUpdate: Events$1.ChannelUpdate;
    readonly ClientReady: Events$1.ClientReady;
    readonly Debug: Events$1.Debug;
    readonly Error: Events$1.Error;
    readonly GuildAuditLogEntryCreate: Events$1.GuildAuditLogEntryCreate;
    readonly GuildAvailable: Events$1.GuildAvailable;
    readonly GuildBanAdd: Events$1.GuildBanAdd;
    readonly GuildBanRemove: Events$1.GuildBanRemove;
    readonly GuildCreate: Events$1.GuildCreate;
    readonly GuildDelete: Events$1.GuildDelete;
    readonly GuildEmojiCreate: Events$1.GuildEmojiCreate;
    readonly GuildEmojiDelete: Events$1.GuildEmojiDelete;
    readonly GuildEmojiUpdate: Events$1.GuildEmojiUpdate;
    readonly GuildIntegrationsUpdate: Events$1.GuildIntegrationsUpdate;
    readonly GuildMemberAdd: Events$1.GuildMemberAdd;
    readonly GuildMemberAvailable: Events$1.GuildMemberAvailable;
    readonly GuildMemberRemove: Events$1.GuildMemberRemove;
    readonly GuildMembersChunk: Events$1.GuildMembersChunk;
    readonly GuildMemberUpdate: Events$1.GuildMemberUpdate;
    readonly GuildRoleCreate: Events$1.GuildRoleCreate;
    readonly GuildRoleDelete: Events$1.GuildRoleDelete;
    readonly GuildRoleUpdate: Events$1.GuildRoleUpdate;
    readonly GuildScheduledEventCreate: Events$1.GuildScheduledEventCreate;
    readonly GuildScheduledEventDelete: Events$1.GuildScheduledEventDelete;
    readonly GuildScheduledEventUpdate: Events$1.GuildScheduledEventUpdate;
    readonly GuildScheduledEventUserAdd: Events$1.GuildScheduledEventUserAdd;
    readonly GuildScheduledEventUserRemove: Events$1.GuildScheduledEventUserRemove;
    readonly GuildStickerCreate: Events$1.GuildStickerCreate;
    readonly GuildStickerDelete: Events$1.GuildStickerDelete;
    readonly GuildStickerUpdate: Events$1.GuildStickerUpdate;
    readonly GuildUnavailable: Events$1.GuildUnavailable;
    readonly GuildUpdate: Events$1.GuildUpdate;
    readonly InteractionCreate: Events$1.InteractionCreate;
    readonly Invalidated: Events$1.Invalidated;
    readonly InviteCreate: Events$1.InviteCreate;
    readonly InviteDelete: Events$1.InviteDelete;
    readonly MessageBulkDelete: Events$1.MessageBulkDelete;
    readonly MessageCreate: Events$1.MessageCreate;
    readonly MessageDelete: Events$1.MessageDelete;
    readonly MessageReactionAdd: Events$1.MessageReactionAdd;
    readonly MessageReactionRemove: Events$1.MessageReactionRemove;
    readonly MessageReactionRemoveAll: Events$1.MessageReactionRemoveAll;
    readonly MessageReactionRemoveEmoji: Events$1.MessageReactionRemoveEmoji;
    readonly MessageUpdate: Events$1.MessageUpdate;
    readonly PresenceUpdate: Events$1.PresenceUpdate;
    readonly Raw: Events$1.Raw;
    readonly ShardDisconnect: Events$1.ShardDisconnect;
    readonly ShardError: Events$1.ShardError;
    readonly ShardReady: Events$1.ShardReady;
    readonly ShardReconnecting: Events$1.ShardReconnecting;
    readonly ShardResume: Events$1.ShardResume;
    readonly StageInstanceCreate: Events$1.StageInstanceCreate;
    readonly StageInstanceDelete: Events$1.StageInstanceDelete;
    readonly StageInstanceUpdate: Events$1.StageInstanceUpdate;
    readonly ThreadCreate: Events$1.ThreadCreate;
    readonly ThreadDelete: Events$1.ThreadDelete;
    readonly ThreadListSync: Events$1.ThreadListSync;
    readonly ThreadMembersUpdate: Events$1.ThreadMembersUpdate;
    readonly ThreadMemberUpdate: Events$1.ThreadMemberUpdate;
    readonly ThreadUpdate: Events$1.ThreadUpdate;
    readonly TypingStart: Events$1.TypingStart;
    readonly UserUpdate: Events$1.UserUpdate;
    readonly VoiceServerUpdate: Events$1.VoiceServerUpdate;
    readonly VoiceStateUpdate: Events$1.VoiceStateUpdate;
    readonly Warn: Events$1.Warn;
    readonly WebhooksUpdate: Events$1.WebhooksUpdate;
    /**
     * Emitted when a message is created that was not sent by bots or webhooks.
     * @param {Message} message The created message
     */
    readonly PreMessageParsed: "preMessageParsed";
    /**
     * Emitted when a message is created consisting of only the bot's mention.
     * @param {Message} message The created message
     */
    readonly MentionPrefixOnly: "mentionPrefixOnly";
    /**
     * Emitted when a message is created that does not start with a valid prefix.
     * @param {Message} message The created message
     */
    readonly NonPrefixedMessage: "nonPrefixedMessage";
    /**
     * Emitted when a message is created that does starts with a valid prefix.
     * @param {Message} message The created message
     */
    readonly PrefixedMessage: "prefixedMessage";
    /**
     * Emitted when a message starts with a valid prefix but does not include a command name.
     * @param {UnknownMessageCommandNamePayload} payload
     */
    readonly UnknownMessageCommandName: "unknownMessageCommandName";
    /**
     * Emitted when the name of a sent message command does not match any loaded commands.
     * @param {UnknownMessageCommandPayload} payload The contextual payload
     */
    readonly UnknownMessageCommand: "unknownMessageCommand";
    /**
     * Emitted when a message command is executed but a `messageRun` method is not found.
     * @param {CommandDoesNotHaveMessageCommandHandler} payload The contextual payload
     */
    readonly CommandDoesNotHaveMessageCommandHandler: "commandDoesNotHaveMessageCommandHandler";
    /**
     * Emitted before the `messageRun` method of a command is run.
     * @param {PreMessageCommandRunPayload} payload The contextual payload
     */
    readonly PreMessageCommandRun: "preMessageCommandRun";
    /**
     * Emitted when a precondition denies a message command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {MessageCommandDeniedPayload} payload The contextual payload
     */
    readonly MessageCommandDenied: "messageCommandDenied";
    /**
     * Emitted when a message command passes all precondition checks, if any.
     * @param {MessageCommandAcceptedPayload} payload The contextual payload
     */
    readonly MessageCommandAccepted: "messageCommandAccepted";
    /**
     * Emitted directly before a message command is run.
     * @param {Message} message The message that executed the command
     * @param {Command} command The command that is being run
     * @param {MessageCommandRunPayload} payload The contextual payload
     */
    readonly MessageCommandRun: "messageCommandRun";
    /**
     * Emitted after a message command runs successfully.
     * @param {MessageCommandSuccessPayload} payload The contextual payload
     */
    readonly MessageCommandSuccess: "messageCommandSuccess";
    /**
     * Emitted after a message command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {MessageCommandErrorPayload} payload The contextual payload
     */
    readonly MessageCommandError: "messageCommandError";
    /**
     * Emitted directly after a message command finished running, regardless of the outcome.
     * @param {Message} message The message that executed the command
     * @param {Command} command The command that finished running
     * @param {MessageCommandFinishPayload} payload The contextual payload
     */
    readonly MessageCommandFinish: "messageCommandFinish";
    /**
     * Emitted after the bot unsuccessfully tried to start typing when a command is executed.
     * @param error The error that was thrown
     * @param payload The contextual payload
     */
    readonly MessageCommandTypingError: "messageCommandTypingError";
    /**
     * Emitted when an error is encountered when executing a listener.
     * @param {*} error The error that was thrown
     * @param {ListenerErrorPayload} payload The contextual payload
     */
    readonly ListenerError: "listenerError";
    /**
     * Emitted when an error is encountered when handling the command application command registry.
     * @param {*} error The error that was thrown
     * @param {Command} command The command whose registry caused the error
     */
    readonly CommandApplicationCommandRegistryError: "commandApplicationCommandRegistryError";
    /**
     * Emitted when the application command registries are being initialized.
     */
    readonly ApplicationCommandRegistriesInitialising: "applicationCommandRegistriesInitialising";
    /**
     * Emitted once the application command registries have been initialized.
     * @param {Map<string, ApplicationCommandRegistry>} registries The initialised registries
     */
    readonly ApplicationCommandRegistriesRegistered: "applicationCommandRegistriesRegistered";
    /**
     * Emitted when an error is encountered when handling the command registries in bulk overwrite mode.
     * @param {*} error The error that was thrown
     * @param {string|null} guildId The guild id where the error was thrown
     */
    readonly ApplicationCommandRegistriesBulkOverwriteError: "applicationCommandRegistriesBulkOverwriteError";
    /**
     * Emitted after a piece is loaded.
     * @param {Store<Piece>} store The store in which the piece belongs to
     * @param {Piece} piece The piece that was loaded
     */
    readonly PiecePostLoad: "piecePostLoad";
    /**
     * Emitted when a piece is unloaded.
     * @param {Store<Piece>} store The store in which the piece belongs to
     * @param {Piece} piece The piece that was unloaded
     */
    readonly PieceUnload: "pieceUnload";
    /**
     * Emitted when a plugin is loaded.
     * @param {PluginHook} hook The plugin hook that was loaded
     * @param {string | undefined} name The name of the plugin, if any
     */
    readonly PluginLoaded: "pluginLoaded";
    /**
     * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered)
     * Use the {@link option} parameter to determine if `some` or `none` was passed.
     * @param {Option.None | Option.Some<unknown>} option The {@link Option} from the `parse` method.
     * @param {InteractionHandlerParseSuccess} payload The contextual payload
     */
    readonly InteractionHandlerParseSuccess: "interactionHandlerParseSuccess";
    /**
     * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered) and `some` is returned.
     * @param {Option.Some<unknown>} option The {@link Option.Some} from the `parse` method.
     * @param {InteractionHandlerParseSome} payload The contextual payload
     */
    readonly InteractionHandlerParseSome: "interactionHandlerParseSome";
    /**
     * Emitted when the `parse` method of an interaction handler passes successfully (no errors are encountered) and `none` is returned.
     * @param {Option.None} option The {@link Option.None} from the `parse` method.
     * @param {InteractionHandlerParseNone} payload The contextual payload
     */
    readonly InteractionHandlerParseNone: "interactionHandlerParseNone";
    /**
     * Emitted when the `parse` method of an interaction handler encounters an error.
     * @param {*} error The error that was encountered
     * @param {InteractionHandlerParseError} payload The contextual payload
     */
    readonly InteractionHandlerParseError: "interactionHandlerParseError";
    /**
     * Emitted when an error is encountered when executing an interaction handler.
     * @param {*} error The error that was encountered
     * @param {InteractionHandlerError} payload The contextual payload
     */
    readonly InteractionHandlerError: "interactionHandlerError";
    /**
     * Emitted when an autocomplete interaction is recieved.
     * @param {AutocompleteInteraction} interaction The interaction that was recieved
     */
    readonly PossibleAutocompleteInteraction: "possibleAutocompleteInteraction";
    /**
     * Emitted after an autocomplete interaction handler runs successfully.
     * @param {AutocompleteInteractionPayload} payload The contextual payload
     */
    readonly CommandAutocompleteInteractionSuccess: "commandAutocompleteInteractionSuccess";
    /**
     * Emitted when an error is encountered when executing an autocomplete interaction handler.
     * @param {*} error The error that was encountered
     * @param {AutocompleteInteractionPayload} payload The contextual payload
     */
    readonly CommandAutocompleteInteractionError: "commandAutocompleteInteractionError";
    /**
     * Emitted when a chat input command interaction is recieved.
     * @param {ChatInputCommandInteraction} interaction The interaction that was recieved.
     */
    readonly PossibleChatInputCommand: "possibleChatInputCommand";
    /**
     * Emitted when the name of a sent chat input command does not match any loaded commands.
     * @param {UnknownChatInputCommandPayload} payload The contextual payload
     */
    readonly UnknownChatInputCommand: "unknownChatInputCommand";
    /**
     * Emitted when a chat input command is executed but a `chatInputRun` method is not found.
     * @param {CommandDoesNotHaveChatInputCommandHandlerPayload} payload The contextual payload
     */
    readonly CommandDoesNotHaveChatInputCommandHandler: "commandDoesNotHaveChatInputCommandHandler";
    /**
     * Emitted before the `chatInputRun` method of a command is run.
     * @param {PreChatInputCommandRunPayload} payload The contextual payload
     */
    readonly PreChatInputCommandRun: "preChatInputCommandRun";
    /**
     * Emitted when a precondition denies a chat input command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {ChatInputCommandDeniedPayload} payload The contextual payload
     */
    readonly ChatInputCommandDenied: "chatInputCommandDenied";
    /**
     * Emitted when a chat input command passes all precondition checks, if any.
     * @param {ChatInputCommandAcceptedPayload} payload The contextual payload
     */
    readonly ChatInputCommandAccepted: "chatInputCommandAccepted";
    /**
     * Emitted directly before a chat input command is run.
     * @param {ChatInputCommandInteraction} interaction The interaction that executed the command
     * @param {ChatInputCommand} command The command that is being run
     * @param {ChatInputCommandRunPayload} payload The contextual payload
     */
    readonly ChatInputCommandRun: "chatInputCommandRun";
    /**
     * Emitted after a chat input command runs successfully.
     * @param {ChatInputCommandSuccessPayload} payload The contextual payload
     */
    readonly ChatInputCommandSuccess: "chatInputCommandSuccess";
    /**
     * Emitted after a chat input command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {ChatInputCommandErrorPayload} payload The contextual payload
     */
    readonly ChatInputCommandError: "chatInputCommandError";
    /**
     * Emitted directly after a chat input command finished running, regardless of the outcome.
     * @param {Interaction} interaction The interaction that executed the command
     * @param {ChatInputCommand} command The command that finished running
     * @param {ChatInputCommandFinishPayload} payload The contextual payload
     */
    readonly ChatInputCommandFinish: "chatInputCommandFinish";
    /**
     * Emitted when a context menu interaction is recieved.
     * @param {ContextMenuCommandInteraction} interaction The interaction that was recieved.
     */
    readonly PossibleContextMenuCommand: "possibleContextMenuCommand";
    /**
     * Emitted when the name of a sent context menu command does not match any loaded commands.
     * @param {UnknownContextMenuCommandPayload} payload The contextual payload
     */
    readonly UnknownContextMenuCommand: "unknownContextMenuCommand";
    /**
     * Emitted when a chat input command is executed but a `contextMenuRun` method is not found.
     * @param {CommandDoesNotHaveContextMenuCommandHandlerPayload} payload The contextual payload
     */
    readonly CommandDoesNotHaveContextMenuCommandHandler: "commandDoesNotHaveContextMenuCommandHandler";
    /**
     * Emitted before the `contextMenuRun` method of a command is run.
     * @param {PreContextMenuCommandRunPayload} payload The contextual payload
     */
    readonly PreContextMenuCommandRun: "preContextMenuCommandRun";
    /**
     * Emitted when a precondition denies a context menu command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {ContextMenuCommandDeniedPayload} payload The contextual payload
     */
    readonly ContextMenuCommandDenied: "contextMenuCommandDenied";
    /**
     * Emitted when a context menu command passes all precondition checks, if any.
     * @param {ContextMenuCommandAcceptedPayload} payload The contextual payload
     */
    readonly ContextMenuCommandAccepted: "contextMenuCommandAccepted";
    /**
     * Emitted directly before a context menu command is run.
     * @param {ContextMenuCommandInteraction} interaction The interaction that executed the command
     * @param {ContextMenuCommand} command The command that is being run
     * @param {ContextMenuCommandRunPayload} payload The contextual payload
     */
    readonly ContextMenuCommandRun: "contextMenuCommandRun";
    /**
     * Emitted after a context menu command runs successfully.
     * @param {ContextMenuCommandSuccessPayload} payload The contextual payload
     */
    readonly ContextMenuCommandSuccess: "contextMenuCommandSuccess";
    /**
     * Emitted after a context menu command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {ContextMenuCommandErrorPayload} payload The contextual payload
     */
    readonly ContextMenuCommandError: "contextMenuCommandError";
    /**
     * Emitted directly after a context menu command finished running, regardless of the outcome.
     * @param {Interaction} interaction The interaction that executed the command
     * @param {ContextMenuCommand} command The command that finished running
     * @param {ContextMenuCommandFinishPayload} payload The contextual payload
     */
    readonly ContextMenuCommandFinish: "contextMenuCommandFinish";
};
interface IPieceError {
    piece: Piece;
}
interface ListenerErrorPayload extends IPieceError {
    piece: Listener;
}
interface UnknownMessageCommandNamePayload {
    message: Message;
    prefix: string | RegExp;
    commandPrefix: string;
}
interface CommandDoesNotHaveMessageCommandHandler {
    message: Message;
    prefix: string | RegExp;
    commandPrefix: string;
    command: Command;
}
interface UnknownMessageCommandPayload extends UnknownMessageCommandNamePayload {
    commandName: string;
}
interface IMessageCommandPayload {
    message: Message;
    command: MessageCommand;
}
interface PreMessageCommandRunPayload extends MessageCommandDeniedPayload {
}
interface MessageCommandDeniedPayload extends IMessageCommandPayload {
    parameters: string;
    context: MessageCommand.RunContext;
}
interface MessageCommandAcceptedPayload extends IMessageCommandPayload {
    parameters: string;
    context: MessageCommand.RunContext;
}
interface MessageCommandRunPayload extends MessageCommandAcceptedPayload {
    args: unknown;
}
interface MessageCommandFinishPayload extends MessageCommandRunPayload {
    success: boolean;
    duration: number;
}
interface MessageCommandErrorPayload extends MessageCommandRunPayload {
    duration: number;
}
interface MessageCommandSuccessPayload extends MessageCommandRunPayload {
    result: unknown;
    duration: number;
}
interface MessageCommandTypingErrorPayload extends MessageCommandRunPayload {
}
interface UnknownChatInputCommandPayload {
    interaction: ChatInputCommandInteraction;
    context: ChatInputCommandContext;
}
interface CommandDoesNotHaveChatInputCommandHandlerPayload {
    interaction: ChatInputCommandInteraction;
    command: Command;
    context: ChatInputCommandContext;
}
interface IChatInputCommandPayload {
    interaction: ChatInputCommandInteraction;
    command: ChatInputCommand;
}
interface PreChatInputCommandRunPayload extends IChatInputCommandPayload {
    context: ChatInputCommandContext;
}
interface ChatInputCommandDeniedPayload extends IChatInputCommandPayload {
    context: ChatInputCommandContext;
}
interface ChatInputCommandAcceptedPayload extends PreChatInputCommandRunPayload {
}
interface ChatInputCommandRunPayload extends ChatInputCommandAcceptedPayload {
}
interface ChatInputCommandFinishPayload extends ChatInputCommandAcceptedPayload {
    success: boolean;
    duration: number;
}
interface ChatInputCommandSuccessPayload extends ChatInputCommandRunPayload {
    result: unknown;
    duration: number;
}
interface ChatInputCommandErrorPayload extends IChatInputCommandPayload {
    duration: number;
}
interface UnknownContextMenuCommandPayload {
    interaction: ContextMenuCommandInteraction;
    context: ContextMenuCommandContext;
}
interface CommandDoesNotHaveContextMenuCommandHandlerPayload {
    interaction: ContextMenuCommandInteraction;
    context: ContextMenuCommandContext;
    command: Command;
}
interface IContextMenuCommandPayload {
    interaction: ContextMenuCommandInteraction;
    command: ContextMenuCommand;
}
interface PreContextMenuCommandRunPayload extends IContextMenuCommandPayload {
    context: ContextMenuCommandContext;
}
interface ContextMenuCommandDeniedPayload extends IContextMenuCommandPayload {
    context: ContextMenuCommandContext;
}
interface ContextMenuCommandAcceptedPayload extends PreContextMenuCommandRunPayload {
}
interface ContextMenuCommandRunPayload extends ContextMenuCommandAcceptedPayload {
}
interface ContextMenuCommandFinishPayload extends ContextMenuCommandAcceptedPayload {
    success: boolean;
    duration: number;
}
interface ContextMenuCommandSuccessPayload extends ContextMenuCommandRunPayload {
    result: unknown;
    duration: number;
}
interface ContextMenuCommandErrorPayload extends IContextMenuCommandPayload {
    duration: number;
}
interface IInteractionHandlerPayload {
    interaction: Interaction;
    handler: InteractionHandler;
}
interface InteractionHandlerParseSuccess extends IInteractionHandlerPayload {
}
interface InteractionHandlerParseSome<T = unknown> extends IInteractionHandlerPayload {
    /**
     * The value that was passed to the `some` function.
     */
    value: T;
}
interface InteractionHandlerParseNone extends IInteractionHandlerPayload {
}
interface InteractionHandlerParseError extends IInteractionHandlerPayload {
}
interface InteractionHandlerError extends IInteractionHandlerPayload {
}
interface AutocompleteInteractionPayload {
    interaction: AutocompleteInteraction;
    command: AutocompleteCommand;
    context: AutocompleteCommandContext;
}
declare const SapphireEvents: typeof Events;

/**
 * A valid prefix in Sapphire.
 * * `string`: a single prefix, e.g. `'!'`.
 * * `string[]`: an array of prefixes, e.g. `['!', '.']`.
 * * `null`: disabled prefix, locks the bot's command usage to mentions only.
 */
type SapphirePrefix = string | readonly string[] | null;
interface SapphirePrefixHook {
    (message: Message): Awaitable<SapphirePrefix>;
}
interface SapphireClientOptions {
    /**
     * The base user directory, if set to `null`, Sapphire will not call {@linkcode StoreRegistry.registerPath()},
     * meaning that you will need to manually set each folder for each store or use {@linkcode StoreRegistry.loadPiece()}.
     * Please read the aforementioned methods' documentation for more information.
     * @since 1.0.0
     * @default undefined
     */
    baseUserDirectory?: URL | string | null;
    /**
     * Whether commands can be case-insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitiveCommands?: boolean | null;
    /**
     * Whether prefixes can be case-insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitivePrefixes?: boolean | null;
    /**
     * The default prefix, in case of `null`, only mention prefix will trigger the bot's commands.
     * @since 1.0.0
     * @default null
     */
    defaultPrefix?: SapphirePrefix;
    /**
     * The regex prefix, an alternative to a mention or regular prefix to allow creating natural language command messages
     * @since 1.0.0
     * @example
     * ```typescript
     * /^(hey +)?bot[,! ]/i
     *
     * // Matches:
     * // - hey bot,
     * // - hey bot!
     * // - hey bot
     * // - bot,
     * // - bot!
     * // - bot
     * ```
     */
    regexPrefix?: RegExp;
    /**
     * The prefix hook, by default it is a callback function that returns {@link SapphireClientOptions.defaultPrefix}.
     * @since 1.0.0
     * @default () => client.options.defaultPrefix
     */
    fetchPrefix?: SapphirePrefixHook;
    /**
     * The client's ID, this is automatically set by the CoreReady event.
     * @since 1.0.0
     * @default this.client.user?.id ?? null
     */
    id?: Snowflake;
    /**
     * The logger options, defaults to an instance of {@link Logger} when {@link ClientLoggerOptions.instance} is not specified.
     * @since 1.0.0
     * @default { instance: new Logger(LogLevel.Info) }
     */
    logger?: ClientLoggerOptions;
    /**
     * Whether trace logging should be enabled.
     * @since 2.0.0
     * @default container.logger.has(LogLevel.Trace)
     */
    enableLoaderTraceLoggings?: boolean;
    /**
     * If Sapphire should load the pre-included application command registries status listeners that log the status of registering application commands to the {@link SapphireClient.logger} instance.
     * This includes the events {@link Events.ApplicationCommandRegistriesInitialising} and {@link Events.ApplicationCommandRegistriesRegistered}.
     * @since 4.4.0
     * @default true
     */
    loadApplicationCommandRegistriesStatusListeners?: boolean;
    /**
     * If Sapphire should load the pre-included error event listeners that log any encountered errors to the {@link SapphireClient.logger} instance
     * @since 1.0.0
     * @default true
     */
    loadDefaultErrorListeners?: boolean;
    /**
     * If Sapphire should load the pre-included message command listeners that are used to process incoming messages for commands.
     * @since 3.0.0
     * @default false
     */
    loadMessageCommandListeners?: boolean;
    /**
     * Controls whether the bot will automatically appear to be typing when a command is accepted.
     * @default false
     */
    typing?: boolean;
    /**
     * Sets the default cooldown time for all commands.
     * @default "No cooldown options"
     */
    defaultCooldown?: CooldownOptions;
    /**
     * Controls whether the bot has mention as a prefix disabled
     * @default false
     */
    disableMentionPrefix?: boolean;
    /**
     * Whenever starting the bot process Sapphire may report errors when failing to fetch guild commands.
     * One of the causes for this can be when a bot was invited to a server without the `application.commands` scope.
     *
     * Normally this produce a log in the console at the WARN level, however because bot lists have a tendency to invite your
     * bot specifically without the scope to ensure that your Chat Input and Context Menu commands do not show up as usable commands
     * in that server, you may want to include their guild ids in this list.
     *
     * By adding ids to this list, whenever a guild id matches one of the ids in the list no warning log message will be emitted for that guild.
     *
     * By setting this value to `true`, no warning log message will be emitted for any guilds we couldn't fetch the commands from.
     *
     * Note that this specifically applies to the warning log:
     *
     * > ApplicationCommandRegistries: Failed to fetch guild commands for guild \<guild name\> (\<guild id\>). Make sure to authorize your application with the "applications.commands" scope in that guild.
     */
    preventFailedToFetchLogForGuilds?: string[] | true;
}
/**
 * The base {@link Client} extension that makes Sapphire work. When building a Discord bot with the framework, the developer
 * must either use this class, or extend it.
 *
 * Sapphire also automatically detects the folders to scan for pieces, please read {@link StoreRegistry.registerPath}
 * for reference. This method is called at the start of the {@link SapphireClient.login} method.
 *
 * @see {@link SapphireClientOptions} for all options available to the Sapphire Client. You can also provide all of discord.js' [ClientOptions](https://discord.js.org/docs/packages/discord.js/main/ClientOptions:Interface)
 *
 * @since 1.0.0
 * @example
 * ```typescript
 * const client = new SapphireClient({
 *   presence: {
 *     activity: {
 *       name: 'for commands!',
 *       type: 'LISTENING'
 *     }
 *   }
 * });
 *
 * client.login(process.env.DISCORD_TOKEN)
 *   .catch(console.error);
 * ```
 *
 * @example
 * ```typescript
 * // Automatically scan from a specific directory, e.g. the main
 * // file is at `/home/me/bot/index.js` and all your pieces are at
 * // `/home/me/bot/pieces` (e.g. `/home/me/bot/pieces/commands/MyCommand.js`):
 * const client = new SapphireClient({
 *   baseUserDirectory: join(__dirname, 'pieces'),
 *   // More options...
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Opt-out automatic scanning:
 * const client = new SapphireClient({
 *   baseUserDirectory: null,
 *   // More options...
 * });
 * ```
 */
declare class SapphireClient<Ready extends boolean = boolean> extends Client<Ready> {
    /**
     * The client's ID, used for the user prefix.
     * @since 1.0.0
     */
    id: Snowflake | null;
    /**
     * The method to be overridden by the developer.
     * @since 1.0.0
     * @return A string for a single prefix, an array of strings for matching multiple, or null for no match (mention prefix only).
     * @example
     * ```typescript
     * // Return always the same prefix (unconfigurable):
     * client.fetchPrefix = () => '!';
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from a SQL database:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getOne('SELECT prefix FROM public.guild WHERE id = $1', [message.guild.id]);
     *   return guild?.prefix ?? '!';
     * };
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from an ORM:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getRepository(GuildEntity).findOne({ id: message.guild.id });
     *   return guild?.prefix ?? '!';
     * };
     * ```
     */
    fetchPrefix: SapphirePrefixHook;
    /**
     * The logger to be used by the framework and plugins. By default, a {@link Logger} instance is used, which emits the
     * messages to the console.
     * @since 1.0.0
     */
    logger: ILogger;
    /**
     * Whether the bot has mention as a prefix disabled
     * @default false
     * @example
     * ```typescript
     * client.disableMentionPrefix = false;
     * ```
     */
    disableMentionPrefix?: boolean;
    /**
     * The registered stores.
     * @since 1.0.0
     */
    stores: StoreRegistry;
    constructor(options: ClientOptions);
    /**
     * Loads all pieces, then logs the client in, establishing a websocket connection to Discord.
     * @since 1.0.0
     * @param token Token of the account to log in with.
     * @return Token of the account used.
     */
    login(token?: string): Promise<string>;
    static plugins: PluginManager;
    static use(plugin: typeof Plugin): typeof SapphireClient;
}
interface ClientLoggerOptions {
    level?: LogLevel;
    instance?: ILogger;
}
interface CooldownOptions {
    scope?: BucketScope;
    delay?: number;
    limit?: number;
    filteredUsers?: Snowflake[];
    filteredCommands?: string[];
}
declare module 'discord.js' {
    interface ClientEvents {
        [SapphireEvents.PieceUnload]: [store: Store<Piece>, piece: Piece];
        [SapphireEvents.PiecePostLoad]: [store: Store<Piece>, piece: Piece];
        [SapphireEvents.ListenerError]: [error: unknown, payload: ListenerErrorPayload];
        [SapphireEvents.CommandApplicationCommandRegistryError]: [error: unknown, command: Command];
        [SapphireEvents.ApplicationCommandRegistriesInitialising]: [];
        [SapphireEvents.ApplicationCommandRegistriesRegistered]: [registries: Map<string, ApplicationCommandRegistry>, timeTaken: number];
        [SapphireEvents.ApplicationCommandRegistriesBulkOverwriteError]: [error: unknown, guildId: string | null];
        [SapphireEvents.PreMessageParsed]: [message: Message];
        [SapphireEvents.MentionPrefixOnly]: [message: Message];
        [SapphireEvents.NonPrefixedMessage]: [message: Message];
        [SapphireEvents.PrefixedMessage]: [message: Message, prefix: string | RegExp];
        [SapphireEvents.UnknownMessageCommandName]: [payload: UnknownMessageCommandNamePayload];
        [SapphireEvents.UnknownMessageCommand]: [payload: UnknownMessageCommandPayload];
        [SapphireEvents.CommandDoesNotHaveMessageCommandHandler]: [payload: CommandDoesNotHaveMessageCommandHandler];
        [SapphireEvents.PreMessageCommandRun]: [payload: PreMessageCommandRunPayload];
        [SapphireEvents.MessageCommandDenied]: [error: UserError, payload: MessageCommandDeniedPayload];
        [SapphireEvents.MessageCommandAccepted]: [payload: MessageCommandAcceptedPayload];
        [SapphireEvents.MessageCommandRun]: [message: Message, command: Command, payload: MessageCommandRunPayload];
        [SapphireEvents.MessageCommandSuccess]: [payload: MessageCommandSuccessPayload];
        [SapphireEvents.MessageCommandError]: [error: unknown, payload: MessageCommandErrorPayload];
        [SapphireEvents.MessageCommandFinish]: [message: Message, command: Command, payload: MessageCommandFinishPayload];
        [SapphireEvents.MessageCommandTypingError]: [error: Error, payload: MessageCommandTypingErrorPayload];
        [SapphireEvents.PluginLoaded]: [hook: PluginHook, name: string | undefined];
        [SapphireEvents.InteractionHandlerParseSuccess]: [option: Option<unknown>, payload: InteractionHandlerParseSuccess];
        [SapphireEvents.InteractionHandlerParseSome]: [option: Option.Some<unknown>, payload: InteractionHandlerParseSome];
        [SapphireEvents.InteractionHandlerParseNone]: [option: Option.None, payload: InteractionHandlerParseNone];
        [SapphireEvents.InteractionHandlerParseError]: [error: unknown, payload: InteractionHandlerParseError];
        [SapphireEvents.InteractionHandlerError]: [error: unknown, payload: InteractionHandlerError];
        [SapphireEvents.PossibleAutocompleteInteraction]: [interaction: AutocompleteInteraction];
        [SapphireEvents.CommandAutocompleteInteractionError]: [error: unknown, payload: AutocompleteInteractionPayload];
        [SapphireEvents.CommandAutocompleteInteractionSuccess]: [payload: AutocompleteInteractionPayload];
        [SapphireEvents.PossibleChatInputCommand]: [interaction: ChatInputCommandInteraction];
        [SapphireEvents.UnknownChatInputCommand]: [payload: UnknownChatInputCommandPayload];
        [SapphireEvents.CommandDoesNotHaveChatInputCommandHandler]: [payload: CommandDoesNotHaveChatInputCommandHandlerPayload];
        [SapphireEvents.PreChatInputCommandRun]: [payload: PreChatInputCommandRunPayload];
        [SapphireEvents.ChatInputCommandDenied]: [error: UserError, payload: ChatInputCommandDeniedPayload];
        [SapphireEvents.ChatInputCommandAccepted]: [payload: ChatInputCommandAcceptedPayload];
        [SapphireEvents.ChatInputCommandRun]: [
            interaction: ChatInputCommandInteraction,
            command: ChatInputCommand,
            payload: ChatInputCommandRunPayload
        ];
        [SapphireEvents.ChatInputCommandSuccess]: [payload: ChatInputCommandSuccessPayload];
        [SapphireEvents.ChatInputCommandError]: [error: unknown, payload: ChatInputCommandErrorPayload];
        [SapphireEvents.ChatInputCommandFinish]: [
            interaction: ChatInputCommandInteraction,
            command: ChatInputCommand,
            payload: ChatInputCommandFinishPayload
        ];
        [SapphireEvents.PossibleContextMenuCommand]: [interaction: ContextMenuCommandInteraction];
        [SapphireEvents.UnknownContextMenuCommand]: [payload: UnknownContextMenuCommandPayload];
        [SapphireEvents.CommandDoesNotHaveContextMenuCommandHandler]: [payload: CommandDoesNotHaveContextMenuCommandHandlerPayload];
        [SapphireEvents.PreContextMenuCommandRun]: [payload: PreContextMenuCommandRunPayload];
        [SapphireEvents.ContextMenuCommandDenied]: [error: UserError, payload: ContextMenuCommandDeniedPayload];
        [SapphireEvents.ContextMenuCommandAccepted]: [payload: ContextMenuCommandAcceptedPayload];
        [SapphireEvents.ContextMenuCommandRun]: [
            interaction: ContextMenuCommandInteraction,
            command: ContextMenuCommand,
            payload: ContextMenuCommandRunPayload
        ];
        [SapphireEvents.ContextMenuCommandSuccess]: [payload: ContextMenuCommandSuccessPayload];
        [SapphireEvents.ContextMenuCommandError]: [error: unknown, payload: ContextMenuCommandErrorPayload];
        [SapphireEvents.ContextMenuCommandFinish]: [
            interaction: ContextMenuCommandInteraction,
            command: ContextMenuCommand,
            payload: ContextMenuCommandFinishPayload
        ];
        [K: string]: unknown[];
    }
}
declare module 'discord.js' {
    interface Client {
        id: Snowflake | null;
        logger: ILogger;
        stores: StoreRegistry;
        fetchPrefix: SapphirePrefixHook;
    }
    interface ClientOptions extends SapphireClientOptions {
    }
}
declare module '@sapphire/pieces' {
    interface Container {
        client: SapphireClient;
        logger: ILogger;
        applicationCommandRegistries: {
            acquire: typeof acquire;
        };
    }
    interface StoreRegistryEntries {
        arguments: ArgumentStore;
        commands: CommandStore;
        'interaction-handlers': InteractionHandlerStore;
        listeners: ListenerStore;
        preconditions: PreconditionStore;
    }
}

interface PermissionPreconditionContext extends AllFlowsPrecondition.Context {
    permissions?: PermissionsBitField;
}
declare class CorePrecondition$d extends AllFlowsPrecondition {
    private readonly dmChannelPermissions;
    messageRun(message: Message, _: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.AsyncResult;
    chatInputRun(interaction: ChatInputCommandInteraction, _: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction, _: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.AsyncResult;
    private getPermissionsForChannel;
    private sharedRun;
    static readonly readablePermissions: Record<PermissionsString, string>;
}

declare class CorePrecondition$c extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.Result;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.Result;
    private makeSharedError;
}

declare class CorePrecondition$b extends AllFlowsPrecondition {
    constructor(context: AllFlowsPrecondition.LoaderContext);
    messageRun(_: Message, command: Command, context: AllFlowsPrecondition.Context): AllFlowsPrecondition.Result;
    chatInputRun(_: ChatInputCommandInteraction, command: Command, context: AllFlowsPrecondition.Context): AllFlowsPrecondition.Result;
    contextMenuRun(_: ContextMenuCommandInteraction, command: Command, context: AllFlowsPrecondition.Context): AllFlowsPrecondition.Result;
}

declare class CorePrecondition$a extends AllFlowsPrecondition {
    private readonly allowedTypes;
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$9 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$8 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.Result;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.Result;
    private makeSharedError;
}

declare class CorePrecondition$7 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$6 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$5 extends AllFlowsPrecondition {
    private readonly allowedTypes;
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$4 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$3 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition$2 extends AllFlowsPrecondition {
    messageRun(message: Message): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction): AllFlowsPrecondition.AsyncResult;
}

interface RunInPreconditionContext extends AllFlowsPrecondition.Context {
    types?: Preconditions['RunIn']['types'];
}
declare class CorePrecondition$1 extends AllFlowsPrecondition {
    messageRun(message: Message<boolean>, _: MessageCommand, context: RunInPreconditionContext): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction, _: ChatInputCommand, context: RunInPreconditionContext): AllFlowsPrecondition.AsyncResult;
    contextMenuRun(interaction: ContextMenuCommandInteraction, _: ContextMenuCommand, context: RunInPreconditionContext): AllFlowsPrecondition.AsyncResult;
    private makeSharedError;
}

declare class CorePrecondition extends AllFlowsPrecondition {
    private readonly dmChannelPermissions;
    messageRun(message: Message, _command: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.Result;
    chatInputRun(interaction: ChatInputCommandInteraction, _command: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.Result;
    contextMenuRun(interaction: ContextMenuCommandInteraction, _command: Command, context: PermissionPreconditionContext): AllFlowsPrecondition.Result;
    private sharedRun;
}

/**
 * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a
 * non-zero bitfield.
 * @param requiredClientPermissions The required client permissions.
 * @param preconditionContainerArray The precondition container array to append the precondition to.
 */
declare function parseConstructorPreConditionsRequiredClientPermissions(requiredClientPermissions: PermissionResolvable | undefined, preconditionContainerArray: PreconditionContainerArray): void;

/**
 * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and
 * {@link Command.Options.cooldownDelay} are both non-zero.
 *
 * @param command The command to parse cooldowns for.
 * @param cooldownLimit The cooldown limit to use.
 * @param cooldownDelay The cooldown delay to use.
 * @param cooldownScope The cooldown scope to use.
 * @param cooldownFilteredUsers The cooldown filtered users to use.
 * @param preconditionContainerArray The precondition container array to append the precondition to.
 */
declare function parseConstructorPreConditionsCooldown<P, O extends Command.Options>(command: Command<P, O>, cooldownLimit: number | undefined, cooldownDelay: number | undefined, cooldownScope: BucketScope | undefined, cooldownFilteredUsers: string[] | undefined, preconditionContainerArray: PreconditionContainerArray): void;

/**
 * Appends the `NSFW` precondition if {@link SubcommandMappingMethod.nsfw} is set to true.
 * @param nsfw Whether this command is NSFW or not.
 * @param preconditionContainerArray The precondition container array to append the precondition to.
 */
declare function parseConstructorPreConditionsNsfw(nsfw: boolean | undefined, preconditionContainerArray: PreconditionContainerArray): void;

/**
 * Appends the `RunIn` precondition based on the values passed, defaulting to `null`, which doesn't add a
 * precondition.
 * @param runIn The command's `runIn` option field from the constructor.
 * @param resolveConstructorPreConditionsRunType The function to resolve the run type from the constructor.
 * @param preconditionContainerArray The precondition container array to append the precondition to.
 */
declare function parseConstructorPreConditionsRunIn(runIn: CommandRunInUnion | CommandSpecificRunIn, resolveConstructorPreConditionsRunType: (types: CommandRunInUnion) => readonly ChannelType[] | null, preconditionContainerArray: PreconditionContainerArray): void;

/**
 * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a
 * non-zero bitfield.
 * @param requiredUserPermissions The required user permissions.
 * @param preconditionContainerArray The precondition container array to append the precondition to.
 */
declare function parseConstructorPreConditionsRequiredUserPermissions(requiredUserPermissions: PermissionResolvable | undefined, preconditionContainerArray: PreconditionContainerArray): void;

declare const index_parseConstructorPreConditionsCooldown: typeof parseConstructorPreConditionsCooldown;
declare const index_parseConstructorPreConditionsNsfw: typeof parseConstructorPreConditionsNsfw;
declare const index_parseConstructorPreConditionsRequiredClientPermissions: typeof parseConstructorPreConditionsRequiredClientPermissions;
declare const index_parseConstructorPreConditionsRequiredUserPermissions: typeof parseConstructorPreConditionsRequiredUserPermissions;
declare const index_parseConstructorPreConditionsRunIn: typeof parseConstructorPreConditionsRunIn;
declare namespace index$1 {
  export { index_parseConstructorPreConditionsCooldown as parseConstructorPreConditionsCooldown, index_parseConstructorPreConditionsNsfw as parseConstructorPreConditionsNsfw, index_parseConstructorPreConditionsRequiredClientPermissions as parseConstructorPreConditionsRequiredClientPermissions, index_parseConstructorPreConditionsRequiredUserPermissions as parseConstructorPreConditionsRequiredUserPermissions, index_parseConstructorPreConditionsRunIn as parseConstructorPreConditionsRunIn };
}

declare function resolveBoolean(parameter: string, customs?: {
    truths?: readonly string[];
    falses?: readonly string[];
}): Result<boolean, Identifiers.ArgumentBooleanError>;

declare function resolveChannel(parameter: string, messageOrInteraction: Message | CommandInteraction): Result<ChannelTypes, Identifiers.ArgumentChannelError>;

declare function resolveDate(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<Date, Identifiers.ArgumentDateError | Identifiers.ArgumentDateTooEarly | Identifiers.ArgumentDateTooFar>;

declare function resolveDMChannel(parameter: string, messageOrInteraction: Message | CommandInteraction): Result<DMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveEnum(parameter: string, options?: {
    enum?: string[];
    caseInsensitive?: boolean;
}): Result<string, Identifiers.ArgumentEnumEmptyError | Identifiers.ArgumentEnumError>;

declare function resolveFloat(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentFloatError | Identifiers.ArgumentFloatTooSmall | Identifiers.ArgumentFloatTooLarge>;

declare function resolveGuild(parameter: string): Promise<Result<Guild, Identifiers.ArgumentGuildError>>;

declare function resolveGuildCategoryChannel(parameter: string, guild: Guild): Result<CategoryChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildCategoryChannelError>;

declare function resolveGuildChannel(parameter: string, guild: Guild): Result<GuildBasedChannelTypes, Identifiers.ArgumentGuildChannelError>;

declare function resolveGuildNewsChannel(parameter: string, guild: Guild): Result<NewsChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildNewsChannelError>;

declare function resolveGuildNewsThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildNewsThreadChannelError>;

declare function resolveGuildPrivateThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPrivateThreadChannelError>;

declare function resolveGuildPublicThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPublicThreadChannelError>;

declare function resolveGuildStageVoiceChannel(parameter: string, guild: Guild): Result<StageChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildStageVoiceChannelError>;

declare function resolveGuildTextChannel(parameter: string, guild: Guild): Result<TextChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildTextChannelError>;

declare function resolveGuildThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError>;

declare function resolveGuildVoiceChannel(parameter: string, guild: Guild): Result<VoiceChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildVoiceChannelError>;

declare function resolveHyperlink(parameter: string): Result<URL$1, Identifiers.ArgumentHyperlinkError>;

declare function resolveInteger(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentIntegerError | Identifiers.ArgumentIntegerTooSmall | Identifiers.ArgumentIntegerTooLarge>;

declare function resolveMember(parameter: string, guild: Guild, performFuzzySearch?: boolean): Promise<Result<GuildMember, Identifiers.ArgumentMemberError>>;

/**
 * Options to resolve a message from a string, given a certain context.
 */
interface MessageResolverOptions {
    /**
     * Channel to resolve the message in.
     * @default message.channel
     */
    channel?: TextBasedChannelTypes;
    /**
     * Base {@link Message} or {@link AnyInteraction} to resolve the message from (e.g. pick the channel if not given).
     */
    messageOrInteraction: Message | AnyInteraction;
    /**
     * Whether to scan the entire guild cache for the message.
     * If channel is given with this option, this option is ignored.
     * @default false
     */
    scan?: boolean;
}
declare function resolveMessage(parameter: string, options: MessageResolverOptions): Promise<Result<Message, Identifiers.ArgumentMessageError>>;

declare function resolveNumber(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentNumberError | Identifiers.ArgumentNumberTooSmall | Identifiers.ArgumentNumberTooLarge>;

declare function resolvePartialDMChannel(parameter: string, message: Message): Result<DMChannel | PartialDMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveRole(parameter: string, guild: Guild): Promise<Result<Role, Identifiers.ArgumentRoleError>>;

declare function resolveString(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<string, Identifiers.ArgumentStringTooShort | Identifiers.ArgumentStringTooLong>;

declare function resolveUser(parameter: string): Promise<Result<User, Identifiers.ArgumentUserError>>;

declare const index_resolveBoolean: typeof resolveBoolean;
declare const index_resolveChannel: typeof resolveChannel;
declare const index_resolveDMChannel: typeof resolveDMChannel;
declare const index_resolveDate: typeof resolveDate;
declare const index_resolveEmoji: typeof resolveEmoji;
declare const index_resolveEnum: typeof resolveEnum;
declare const index_resolveFloat: typeof resolveFloat;
declare const index_resolveGuild: typeof resolveGuild;
declare const index_resolveGuildCategoryChannel: typeof resolveGuildCategoryChannel;
declare const index_resolveGuildChannel: typeof resolveGuildChannel;
declare const index_resolveGuildNewsChannel: typeof resolveGuildNewsChannel;
declare const index_resolveGuildNewsThreadChannel: typeof resolveGuildNewsThreadChannel;
declare const index_resolveGuildPrivateThreadChannel: typeof resolveGuildPrivateThreadChannel;
declare const index_resolveGuildPublicThreadChannel: typeof resolveGuildPublicThreadChannel;
declare const index_resolveGuildStageVoiceChannel: typeof resolveGuildStageVoiceChannel;
declare const index_resolveGuildTextChannel: typeof resolveGuildTextChannel;
declare const index_resolveGuildThreadChannel: typeof resolveGuildThreadChannel;
declare const index_resolveGuildVoiceChannel: typeof resolveGuildVoiceChannel;
declare const index_resolveHyperlink: typeof resolveHyperlink;
declare const index_resolveInteger: typeof resolveInteger;
declare const index_resolveMember: typeof resolveMember;
declare const index_resolveMessage: typeof resolveMessage;
declare const index_resolveNumber: typeof resolveNumber;
declare const index_resolvePartialDMChannel: typeof resolvePartialDMChannel;
declare const index_resolveRole: typeof resolveRole;
declare const index_resolveString: typeof resolveString;
declare const index_resolveUser: typeof resolveUser;
declare namespace index {
  export { index_resolveBoolean as resolveBoolean, index_resolveChannel as resolveChannel, index_resolveDMChannel as resolveDMChannel, index_resolveDate as resolveDate, index_resolveEmoji as resolveEmoji, index_resolveEnum as resolveEnum, index_resolveFloat as resolveFloat, index_resolveGuild as resolveGuild, index_resolveGuildCategoryChannel as resolveGuildCategoryChannel, index_resolveGuildChannel as resolveGuildChannel, index_resolveGuildNewsChannel as resolveGuildNewsChannel, index_resolveGuildNewsThreadChannel as resolveGuildNewsThreadChannel, index_resolveGuildPrivateThreadChannel as resolveGuildPrivateThreadChannel, index_resolveGuildPublicThreadChannel as resolveGuildPublicThreadChannel, index_resolveGuildStageVoiceChannel as resolveGuildStageVoiceChannel, index_resolveGuildTextChannel as resolveGuildTextChannel, index_resolveGuildThreadChannel as resolveGuildThreadChannel, index_resolveGuildVoiceChannel as resolveGuildVoiceChannel, index_resolveHyperlink as resolveHyperlink, index_resolveInteger as resolveInteger, index_resolveMember as resolveMember, index_resolveMessage as resolveMessage, index_resolveNumber as resolveNumber, index_resolvePartialDMChannel as resolvePartialDMChannel, index_resolveRole as resolveRole, index_resolveString as resolveString, index_resolveUser as resolveUser };
}

declare class ListenerLoaderStrategy extends LoaderStrategy<Listener> {
    onLoad(_store: ListenerStore, piece: Listener): void;
    onUnload(_store: ListenerStore, piece: Listener): void;
}

/**
 * The context for the `'enum'` argument.
 * @since 4.2.0 (🌿)
 */
interface EnumArgumentContext extends Argument.Context {
    readonly enum?: string[];
    readonly caseInsensitive?: boolean;
}
/**
 * The context for the `'boolean'` argument.
 * @since 4.2.0 (🌿)
 */
interface BooleanArgumentContext extends Argument.Context {
    /**
     * The words that resolve to `true`.
     * Any words added to this array will be merged with the words:
     * ```ts
     * ['1', 'true', '+', 't', 'yes', 'y']
     * ```
     */
    readonly truths?: string[];
    /**
     * The words that resolve to `false`.
     * Any words added to this array will be merged with the words:
     * ```ts
     * ['0', 'false', '-', 'f', 'no', 'n']
     * ```
     */
    readonly falses?: string[];
}
/**
 * The context for the `'member'` argument.
 * @since 4.2.0 (🌿)
 */
interface MemberArgumentContext extends Argument.Context {
    /**
     * Whether to perform a fuzzy search with the given argument.
     * This will leverage `FetchMembersOptions.query` to do the fuzzy searching.
     * @default true
     */
    readonly performFuzzySearch?: boolean;
}
/**
 * The context for the `'message'` argument.
 * @since 4.2.0 (🌿)
 */
type MessageArgumentContext = Omit<MessageResolverOptions, 'messageOrInteraction'> & Argument.Context;

declare class Logger implements ILogger {
    level: LogLevel;
    constructor(level: LogLevel);
    has(level: LogLevel): boolean;
    trace(...values: readonly unknown[]): void;
    debug(...values: readonly unknown[]): void;
    info(...values: readonly unknown[]): void;
    warn(...values: readonly unknown[]): void;
    error(...values: readonly unknown[]): void;
    fatal(...values: readonly unknown[]): void;
    write(level: LogLevel, ...values: readonly unknown[]): void;
    protected static readonly levels: Map<LogLevel, LogMethods>;
}
type LogMethods = 'trace' | 'debug' | 'info' | 'warn' | 'error';

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionAnd: IPreconditionCondition;

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 || V1 [|| V2 [|| V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionOr: IPreconditionCondition;

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: Command.Context) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new ClientPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class ClientPermissionsPrecondition implements PreconditionSingleResolvableDetails<'ClientPermissions'> {
    name: 'ClientPermissions';
    context: {
        permissions: PermissionsBitField;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: Command.Context) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new UserPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class UserPermissionsPrecondition implements PreconditionSingleResolvableDetails<'UserPermissions'> {
    name: 'UserPermissions';
    context: {
        permissions: PermissionsBitField;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

declare const ApplicationCommandRegistries: {
    acquire: typeof acquire;
    setDefaultBehaviorWhenNotIdentical: typeof setDefaultBehaviorWhenNotIdentical;
    setDefaultGuildIds: typeof setDefaultGuildIds;
    getDefaultGuildIds: typeof getDefaultGuildIds;
    getDefaultBehaviorWhenNotIdentical: typeof getDefaultBehaviorWhenNotIdentical;
    readonly registries: ReadonlyMap<string, ApplicationCommandRegistry>;
};

declare const CorePreconditions: {
    ClientPermissions: typeof CorePrecondition$d;
    Cooldown: typeof CorePrecondition$e;
    /** @deprecated Use {@link RunIn} instead. */
    DMOnly: typeof CorePrecondition$c;
    Enabled: typeof CorePrecondition$b;
    RunIn: typeof CorePrecondition$1;
    /** @deprecated Use {@link RunIn} instead. */
    GuildNewsOnly: typeof CorePrecondition$a;
    /** @deprecated Use {@link RunIn} instead. */
    GuildNewsThreadOnly: typeof CorePrecondition$9;
    /** @deprecated Use {@link RunIn} instead. */
    GuildOnly: typeof CorePrecondition$8;
    /** @deprecated Use {@link RunIn} instead. */
    GuildPrivateThreadOnly: typeof CorePrecondition$7;
    /** @deprecated Use {@link RunIn} instead. */
    GuildPublicThreadOnly: typeof CorePrecondition$6;
    /** @deprecated Use {@link RunIn} instead. */
    GuildTextOnly: typeof CorePrecondition$5;
    /** @deprecated Use {@link RunIn} instead. */
    GuildVoiceOnly: typeof CorePrecondition$3;
    /** @deprecated Use {@link RunIn} instead. */
    GuildThreadOnly: typeof CorePrecondition$4;
    NSFW: typeof CorePrecondition$2;
    UserPermissions: typeof CorePrecondition;
};
declare namespace CorePreconditions {
    type UserPermissionsPreconditionContext = PermissionPreconditionContext;
    type CooldownContext = CooldownPreconditionContext;
}
/**
 * The [@sapphire/framework](https://github.com/sapphiredev/framework) version that you are currently using.
 * An example use of this is showing it of in a bot information command.
 *
 * Note to Sapphire developers: This needs to explicitly be `string` so it is not typed as the string that gets replaced by esbuild
 */
declare const version: string;

export { AllFlowsPrecondition, ApplicationCommandRegistries, ApplicationCommandRegistry, type ApplicationCommandRegistryRegisterOptions, type ArgOptions, type ArgType, Args, type ArgsJson, type ArgsNextCallback, Argument, type ArgumentContext, ArgumentError, type ArgumentOptions, type ArgumentResult, ArgumentStore, type ArrayResultType, type AsyncArgumentResult, type AsyncPluginHooks, type AsyncPreconditionContainerReturn, type AsyncPreconditionResult, AutocompleteCommand, type AutocompleteCommandContext, type AutocompleteInteractionPayload, type AwaitableArgumentResult, type BooleanArgumentContext, BucketScope, ChatInputCommand, type ChatInputCommandAcceptedPayload, type ChatInputCommandContext, type ChatInputCommandDeniedPayload, type ChatInputCommandErrorPayload, type ChatInputCommandFinishPayload, type ChatInputCommandRunPayload, type ChatInputCommandSuccessPayload, type ClientLoggerOptions, ClientPermissionsPrecondition, Command, type CommandDoesNotHaveChatInputCommandHandlerPayload, type CommandDoesNotHaveContextMenuCommandHandlerPayload, type CommandDoesNotHaveMessageCommandHandler, type CommandJSON, type CommandOptions, type CommandOptionsRunType, CommandOptionsRunTypeEnum, CommandPreConditions, type CommandRunInUnion, type CommandSpecificRunIn, CommandStore, ContextMenuCommand, type ContextMenuCommandAcceptedPayload, type ContextMenuCommandContext, type ContextMenuCommandDeniedPayload, type ContextMenuCommandErrorPayload, type ContextMenuCommandFinishPayload, type ContextMenuCommandRunPayload, type ContextMenuCommandSuccessPayload, CooldownLevel, type CooldownOptions, CorePreconditions, type DetailedDescriptionCommand, type DetailedDescriptionCommandObject, type EmojiObject, type EnumArgumentContext, Events, type IArgument, type IChatInputCommandPayload, type IContextMenuCommandPayload, type IInteractionHandlerPayload, type ILogger, type IMessageCommandPayload, type IPieceError, type IPreconditionCondition, type IPreconditionContainer, Identifiers, InteractionHandler, type InteractionHandlerError, InteractionHandlerFilters, type InteractionHandlerJSON, type InteractionHandlerOptions, type InteractionHandlerParseError, type InteractionHandlerParseNone, type InteractionHandlerParseResult, type InteractionHandlerParseSome, type InteractionHandlerParseSuccess, InteractionHandlerStore, InteractionHandlerTypes, InternalRegistryAPIType, Listener, type ListenerErrorPayload, type ListenerJSON, ListenerLoaderStrategy, type ListenerOptions, ListenerStore, LogLevel, type LogMethods, Logger, type MemberArgumentContext, type MessageArgumentContext, MessageCommand, type MessageCommandAcceptedPayload, type MessageCommandContext, type MessageCommandDeniedPayload, type MessageCommandErrorPayload, type MessageCommandFinishPayload, type MessageCommandRunPayload, type MessageCommandSuccessPayload, type MessageCommandTypingErrorPayload, type MessageResolverOptions, Plugin, PluginHook, PluginManager, type PreChatInputCommandRunPayload, type PreContextMenuCommandRunPayload, type PreMessageCommandRunPayload, Precondition, type PreconditionArrayResolvable, type PreconditionArrayResolvableDetails, PreconditionConditionAnd, PreconditionConditionOr, PreconditionContainerArray, type PreconditionContainerResult, type PreconditionContainerReturn, PreconditionContainerSingle, type PreconditionContext, type PreconditionEntryResolvable, PreconditionError, type PreconditionKeys, type PreconditionOptions, index$1 as PreconditionResolvers, type PreconditionResult, PreconditionRunCondition, PreconditionRunMode, type PreconditionSingleResolvable, type PreconditionSingleResolvableDetails, PreconditionStore, type Preconditions, RegisterBehavior, type RepeatArgOptions, index as Resolvers, type ResultType, type RunInPreconditionCommandSpecificData, SapphireClient, type SapphireClientOptions, type SapphirePluginAsyncHook, type SapphirePluginHook, type SapphirePluginHookEntry, type SapphirePrefix, type SapphirePrefixHook, type SimplePreconditionKeys, type SimplePreconditionSingleResolvableDetails, type SyncPluginHooks, type UnknownChatInputCommandPayload, type UnknownContextMenuCommandPayload, type UnknownMessageCommandNamePayload, type UnknownMessageCommandPayload, UserError, UserPermissionsPrecondition, postInitialization, postLogin, preGenericsInitialization, preInitialization, preLogin, version };
