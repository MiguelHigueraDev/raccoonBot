{"version":3,"sources":["../../../../src/optional-listeners/message-command-listeners/CorePrefixedMessage.ts"],"names":[],"mappings":";;;;;AACA,SAAS,gBAAgB;AAEzB,SAAS,cAAc;AAEhB,IAAM,gBAAN,MAAM,sBAAqB,SAAwC;AAAA,EAClE,YAAY,SAAiC;AACnD,UAAM,SAAS,EAAE,OAAO,OAAO,gBAAgB,CAAC;AAAA,EACjD;AAAA,EAEO,IAAI,SAAkB,QAAyB;AACrD,UAAM,EAAE,QAAQ,OAAO,IAAI,KAAK;AAEhC,UAAM,gBAAgB,KAAK,iBAAiB,QAAQ,SAAS,MAAM;AACnE,UAAM,aAAa,QAAQ,QAAQ,MAAM,cAAc,MAAM,EAAE,KAAK;AAIpE,UAAM,aAAa,WAAW,QAAQ,GAAG;AACzC,UAAM,cAAc,eAAe,KAAK,aAAa,WAAW,MAAM,GAAG,UAAU;AACnF,QAAI,YAAY,WAAW,GAAG;AAC7B,aAAO,KAAK,OAAO,2BAA2B,EAAE,SAAS,QAAQ,cAAc,CAAC;AAChF;AAAA,IACD;AAGA,UAAM,UAAU,OAAO,IAAI,UAAU,EAAE,IAAI,OAAO,QAAQ,0BAA0B,YAAY,YAAY,IAAI,WAAW;AAC3H,QAAI,CAAC,SAAS;AACb,aAAO,KAAK,OAAO,uBAAuB,EAAE,SAAS,QAAQ,aAAa,cAAc,CAAC;AACzF;AAAA,IACD;AAGA,QAAI,CAAC,QAAQ,YAAY;AACxB,aAAO,KAAK,OAAO,yCAAyC,EAAE,SAAS,QAAQ,eAAe,QAAQ,CAAC;AACvG;AAAA,IACD;AAGA,UAAM,aAAa,eAAe,KAAK,KAAK,WAAW,UAAU,aAAa,CAAC,EAAE,KAAK;AACtF,WAAO,KAAK,OAAO,sBAAsB;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,EAAE,aAAa,eAAe,OAAO;AAAA,IAC/C,CAAC;AAAA,EACF;AAAA,EAEQ,iBAAiB,SAAiB,QAAiC;AAC1E,WAAO,OAAO,WAAW,WAAW,SAAS,OAAO,KAAK,OAAO,EAAG,CAAC;AAAA,EACrE;AACD;AA9C0E;AAAnE,IAAM,eAAN","sourcesContent":["import type { Message } from 'discord.js';\nimport { Listener } from '../../lib/structures/Listener';\nimport type { MessageCommand } from '../../lib/types/CommandTypes';\nimport { Events } from '../../lib/types/Events';\n\nexport class CoreListener extends Listener<typeof Events.PrefixedMessage> {\n\tpublic constructor(context: Listener.LoaderContext) {\n\t\tsuper(context, { event: Events.PrefixedMessage });\n\t}\n\n\tpublic run(message: Message, prefix: string | RegExp) {\n\t\tconst { client, stores } = this.container;\n\t\t// Retrieve the command name and validate:\n\t\tconst commandPrefix = this.getCommandPrefix(message.content, prefix);\n\t\tconst prefixLess = message.content.slice(commandPrefix.length).trim();\n\n\t\t// The character that separates the command name from the arguments, this will return -1 when '[p]command' is\n\t\t// passed, and a non -1 value when '[p]command arg' is passed instead.\n\t\tconst spaceIndex = prefixLess.indexOf(' ');\n\t\tconst commandName = spaceIndex === -1 ? prefixLess : prefixLess.slice(0, spaceIndex);\n\t\tif (commandName.length === 0) {\n\t\t\tclient.emit(Events.UnknownMessageCommandName, { message, prefix, commandPrefix });\n\t\t\treturn;\n\t\t}\n\n\t\t// Retrieve the command and validate:\n\t\tconst command = stores.get('commands').get(client.options.caseInsensitiveCommands ? commandName.toLowerCase() : commandName);\n\t\tif (!command) {\n\t\t\tclient.emit(Events.UnknownMessageCommand, { message, prefix, commandName, commandPrefix });\n\t\t\treturn;\n\t\t}\n\n\t\t// If the command exists but is missing a message handler, emit a different event (maybe an application command variant exists)\n\t\tif (!command.messageRun) {\n\t\t\tclient.emit(Events.CommandDoesNotHaveMessageCommandHandler, { message, prefix, commandPrefix, command });\n\t\t\treturn;\n\t\t}\n\n\t\t// Run the last stage before running the command:\n\t\tconst parameters = spaceIndex === -1 ? '' : prefixLess.substring(spaceIndex + 1).trim();\n\t\tclient.emit(Events.PreMessageCommandRun, {\n\t\t\tmessage,\n\t\t\tcommand: command as MessageCommand,\n\t\t\tparameters,\n\t\t\tcontext: { commandName, commandPrefix, prefix }\n\t\t});\n\t}\n\n\tprivate getCommandPrefix(content: string, prefix: string | RegExp): string {\n\t\treturn typeof prefix === 'string' ? prefix : prefix.exec(content)![0];\n\t}\n}\n"]}