{"version":3,"sources":["../../../../src/lib/precondition-resolvers/cooldown.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAiB;AAE1B,SAAS,aAAa,4BAA4B;AAClD,OAAgD;AAazC,SAAS,sCACf,SACA,eACA,eACA,eACA,uBACA,4BACC;AACD,QAAM,EAAE,gBAAgB,IAAI,UAAU,OAAO;AAK7C,QAAM,WAAW,iBAAiB,kBAAkB,SAAS,QAAQ,IAAI,KAAK;AAC9E,QAAM,QAAQ,kBAAkB,WAAW,IAAI,iBAAiB,SAAS;AACzE,QAAM,QAAQ,kBAAkB,WAAW,IAAI,iBAAiB,SAAS;AAEzE,MAAI,SAAS,OAAO;AACnB,UAAM,QAAQ,iBAAiB,iBAAiB,SAAS,YAAY;AACrE,UAAM,gBAAgB,yBAAyB,iBAAiB;AAChE,+BAA2B,OAAO;AAAA,MACjC,MAAM,qBAAqB;AAAA,MAC3B,SAAS,EAAE,OAAO,OAAO,OAAO,cAAc;AAAA,IAC/C,CAAC;AAAA,EACF;AACD;AAzBgB","sourcesContent":["import { container } from '@sapphire/pieces';\nimport type { Command } from '../structures/Command';\nimport { BucketScope, CommandPreConditions } from '../types/Enums';\nimport { type PreconditionContainerArray } from '../utils/preconditions/PreconditionContainerArray';\n\n/**\n * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and\n * {@link Command.Options.cooldownDelay} are both non-zero.\n *\n * @param command The command to parse cooldowns for.\n * @param cooldownLimit The cooldown limit to use.\n * @param cooldownDelay The cooldown delay to use.\n * @param cooldownScope The cooldown scope to use.\n * @param cooldownFilteredUsers The cooldown filtered users to use.\n * @param preconditionContainerArray The precondition container array to append the precondition to.\n */\nexport function parseConstructorPreConditionsCooldown<P, O extends Command.Options>(\n\tcommand: Command<P, O>,\n\tcooldownLimit: number | undefined,\n\tcooldownDelay: number | undefined,\n\tcooldownScope: BucketScope | undefined,\n\tcooldownFilteredUsers: string[] | undefined,\n\tpreconditionContainerArray: PreconditionContainerArray\n) {\n\tconst { defaultCooldown } = container.client.options;\n\n\t// We will check for whether the command is filtered from the defaults, but we will allow overridden values to\n\t// be set. If an overridden value is passed, it will have priority. Otherwise, it will default to 0 if filtered\n\t// (causing the precondition to not be registered) or the default value with a fallback to a single-use cooldown.\n\tconst filtered = defaultCooldown?.filteredCommands?.includes(command.name) ?? false;\n\tconst limit = cooldownLimit ?? (filtered ? 0 : defaultCooldown?.limit ?? 1);\n\tconst delay = cooldownDelay ?? (filtered ? 0 : defaultCooldown?.delay ?? 0);\n\n\tif (limit && delay) {\n\t\tconst scope = cooldownScope ?? defaultCooldown?.scope ?? BucketScope.User;\n\t\tconst filteredUsers = cooldownFilteredUsers ?? defaultCooldown?.filteredUsers;\n\t\tpreconditionContainerArray.append({\n\t\t\tname: CommandPreConditions.Cooldown,\n\t\t\tcontext: { scope, limit, delay, filteredUsers }\n\t\t});\n\t}\n}\n"]}