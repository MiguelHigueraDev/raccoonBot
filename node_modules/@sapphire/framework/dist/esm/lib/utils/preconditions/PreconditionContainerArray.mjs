import { __name } from '../../../chunk-G5GHKT7C.mjs';
import { Collection } from 'discord.js';
import { PreconditionContainerSingle } from './PreconditionContainerSingle.mjs';
import { PreconditionConditionAnd } from './conditions/PreconditionConditionAnd.mjs';
import { PreconditionConditionOr } from './conditions/PreconditionConditionOr.mjs';

var PreconditionRunMode = /* @__PURE__ */ ((PreconditionRunMode2) => {
  PreconditionRunMode2[PreconditionRunMode2["Sequential"] = 0] = "Sequential";
  PreconditionRunMode2[PreconditionRunMode2["Parallel"] = 1] = "Parallel";
  return PreconditionRunMode2;
})(PreconditionRunMode || {});
var PreconditionRunCondition = /* @__PURE__ */ ((PreconditionRunCondition2) => {
  PreconditionRunCondition2[PreconditionRunCondition2["And"] = 0] = "And";
  PreconditionRunCondition2[PreconditionRunCondition2["Or"] = 1] = "Or";
  return PreconditionRunCondition2;
})(PreconditionRunCondition || {});
function isSingle(entry) {
  return typeof entry === "string" || Reflect.has(entry, "name");
}
__name(isSingle, "isSingle");
var _PreconditionContainerArray = class _PreconditionContainerArray {
  constructor(data = [], parent = null) {
    this.entries = [];
    this.runCondition = parent?.runCondition === 0 /* And */ ? 1 /* Or */ : 0 /* And */;
    if (Array.isArray(data)) {
      const casted = data;
      this.mode = parent?.mode ?? 0 /* Sequential */;
      this.parse(casted);
    } else {
      const casted = data;
      this.mode = casted.mode;
      this.parse(casted.entries);
    }
  }
  /**
   * Adds a new entry to the array.
   * @since 1.0.0
   * @param entry The value to add to the entries.
   */
  add(entry) {
    this.entries.push(entry);
    return this;
  }
  append(entry) {
    this.entries.push(entry instanceof _PreconditionContainerArray ? entry : new PreconditionContainerSingle(entry));
    return this;
  }
  /**
   * Runs the container.
   * @since 1.0.0
   * @param message The message that ran this precondition.
   * @param command The command the message invoked.
   * @param context The context for the message command precondition.
   */
  messageRun(message, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.messageSequential(message, command, this.entries, context) : this.condition.messageParallel(message, command, this.entries, context);
  }
  /**
   * Runs the container.
   * @since 3.0.0
   * @param interaction The interaction that ran this precondition.
   * @param command The command the interaction invoked.
   * @param context The context for the chat input precondition.
   */
  chatInputRun(interaction, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.chatInputSequential(interaction, command, this.entries, context) : this.condition.chatInputParallel(interaction, command, this.entries, context);
  }
  /**
   * Runs the container.
   * @since 3.0.0
   * @param interaction The interaction that ran this precondition.
   * @param command The command the interaction invoked.
   * @param context  The context for the context menu precondition.
   */
  contextMenuRun(interaction, command, context = {}) {
    return this.mode === 0 /* Sequential */ ? this.condition.contextMenuSequential(interaction, command, this.entries, context) : this.condition.contextMenuParallel(interaction, command, this.entries, context);
  }
  /**
   * Parses the precondition entry resolvables, and adds them to the entries.
   * @since 1.0.0
   * @param entries The entries to parse.
   */
  parse(entries) {
    for (const entry of entries) {
      this.add(
        isSingle(entry) ? new PreconditionContainerSingle(entry) : new _PreconditionContainerArray(entry, this)
      );
    }
    return this;
  }
  /**
   * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.
   * @since 1.0.0
   */
  get condition() {
    return _PreconditionContainerArray.conditions.get(this.runCondition);
  }
};
__name(_PreconditionContainerArray, "PreconditionContainerArray");
/**
 * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then
 * inserting {@link IPreconditionCondition}s.
 * @since 1.0.0
 * @example
 * ```typescript
 * // Adding more kinds of conditions
 *
 * // Set the new condition:
 * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);
 *
 * // Augment Sapphire to add the new condition, in case of a JavaScript
 * // project, this can be moved to an `Augments.d.ts` (or any other name)
 * // file somewhere:
 * declare module '@sapphire/framework' {
 *   export enum PreconditionRunCondition {
 *     Random = 2
 *   }
 * }
 * ```
 */
_PreconditionContainerArray.conditions = new Collection([
  [0 /* And */, PreconditionConditionAnd],
  [1 /* Or */, PreconditionConditionOr]
]);
var PreconditionContainerArray = _PreconditionContainerArray;

export { PreconditionContainerArray, PreconditionRunCondition, PreconditionRunMode };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=PreconditionContainerArray.mjs.map