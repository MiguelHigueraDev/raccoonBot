{"version":3,"sources":["../../../../../../src/lib/utils/preconditions/conditions/PreconditionConditionAnd.ts"],"names":[],"mappings":";;;AAAA,SAAS,cAAc;AAOhB,IAAM,2BAAmD;AAAA,EAC/D,MAAM,kBAAkB,SAAS,SAAS,SAAS,SAAS;AAC3D,eAAW,SAAS,SAAS;AAC5B,YAAM,SAAS,MAAM,MAAM,WAAW,SAAS,SAAS,OAAO;AAC/D,UAAI,OAAO,MAAM;AAAG,eAAO;AAAA,IAC5B;AAEA,WAAO,OAAO,GAAG;AAAA,EAClB;AAAA,EACA,MAAM,gBAAgB,SAAS,SAAS,SAAS,SAAS;AACzD,UAAM,UAAU,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,UAAU,MAAM,WAAW,SAAS,SAAS,OAAO,CAAC,CAAC;AAGrG,WAAO,QAAQ,KAAK,CAAC,QAAQ,IAAI,MAAM,CAAC,KAAK,OAAO,GAAG;AAAA,EACxD;AAAA,EACA,MAAM,oBAAoB,aAAa,SAAS,SAAS,SAAS;AACjE,eAAW,SAAS,SAAS;AAC5B,YAAM,SAAS,MAAM,MAAM,aAAa,aAAa,SAAS,OAAO;AACrE,UAAI,OAAO,MAAM;AAAG,eAAO;AAAA,IAC5B;AAEA,WAAO,OAAO,GAAG;AAAA,EAClB;AAAA,EACA,MAAM,kBAAkB,aAAa,SAAS,SAAS,SAAS;AAC/D,UAAM,UAAU,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,UAAU,MAAM,aAAa,aAAa,SAAS,OAAO,CAAC,CAAC;AAG3G,WAAO,QAAQ,KAAK,CAAC,QAAQ,IAAI,MAAM,CAAC,KAAK,OAAO,GAAG;AAAA,EACxD;AAAA,EACA,MAAM,sBAAsB,aAAa,SAAS,SAAS,SAAS;AACnE,eAAW,SAAS,SAAS;AAC5B,YAAM,SAAS,MAAM,MAAM,eAAe,aAAa,SAAS,OAAO;AACvE,UAAI,OAAO,MAAM;AAAG,eAAO;AAAA,IAC5B;AAEA,WAAO,OAAO,GAAG;AAAA,EAClB;AAAA,EACA,MAAM,oBAAoB,aAAa,SAAS,SAAS,SAAS;AACjE,UAAM,UAAU,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,UAAU,MAAM,eAAe,aAAa,SAAS,OAAO,CAAC,CAAC;AAG7G,WAAO,QAAQ,KAAK,CAAC,QAAQ,IAAI,MAAM,CAAC,KAAK,OAAO,GAAG;AAAA,EACxD;AACD","sourcesContent":["import { Result } from '@sapphire/result';\nimport type { IPreconditionCondition } from './IPreconditionCondition';\n\n/**\n * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).\n * @since 1.0.0\n */\nexport const PreconditionConditionAnd: IPreconditionCondition = {\n\tasync messageSequential(message, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.messageRun(message, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync messageParallel(message, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.messageRun(message, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync chatInputSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.chatInputRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync chatInputParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.chatInputRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync contextMenuSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.contextMenuRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync contextMenuParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.contextMenuRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t}\n};\n"]}