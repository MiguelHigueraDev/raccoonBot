{"version":3,"sources":["../../../../../src/lib/utils/strategies/FlagUnorderedStrategy.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,wBAAwB;AACjC,SAAS,cAAc;AAmCvB,IAAM,QAAQ,6BAAM,OAAO,MAAb;AACd,IAAM,SAAS,6BAAM,MAAN;AAER,IAAM,yBAAN,MAAM,+BAA8B,iBAAiB;AAAA,EAIpD,YAAY,EAAE,OAAO,SAAS,WAAW,CAAC,MAAM,KAAK,QAAG,GAAG,aAAa,CAAC,KAAK,GAAG,EAAE,IAAyB,CAAC,GAAG;AACtH,UAAM,UAAU,UAAU;AAC1B,SAAK,QAAQ,SAAS,CAAC;AACvB,SAAK,UAAU,WAAW,CAAC;AAE3B,QAAI,KAAK,UAAU;AAAM,WAAK,cAAc;AAAA,aACnC,KAAK,MAAM,WAAW;AAAG,WAAK,YAAY;AAEnD,QAAI,KAAK,YAAY,MAAM;AAC1B,WAAK,gBAAgB;AAAA,IACtB,WAAW,KAAK,QAAQ,WAAW,GAAG;AACrC,WAAK,cAAc;AAAA,IACpB;AAAA,EACD;AAAA,EAEgB,UAAU,GAA2B;AACpD,UAAM,SAAS,MAAM,UAAU,CAAC;AAGhC,QAAI,OAAO,UAAU,CAAC,UAAU,KAAK,YAAY,KAAK,CAAC;AAAG,aAAO;AAGjE,WAAO,OAAO;AAAA,EACf;AAAA,EAEgB,YAAY,GAA0D;AACrF,UAAM,SAAS,MAAM,YAAY,CAAC;AAElC,QAAI,OAAO,UAAU,CAAC,WAAW,KAAK,cAAc,OAAO,CAAC,CAAC,CAAC;AAAG,aAAO;AAExE,WAAO,OAAO;AAAA,EACf;AAAA,EAEQ,YAAY,GAAW;AAC9B,WAAQ,KAAK,MAA4B,SAAS,CAAC;AAAA,EACpD;AAAA,EAEQ,cAAc,GAAW;AAChC,WAAQ,KAAK,QAA8B,SAAS,CAAC;AAAA,EACtD;AACD;AA5C4D;AAArD,IAAM,wBAAN","sourcesContent":["import { PrefixedStrategy } from '@sapphire/lexure';\nimport { Option } from '@sapphire/result';\n\n/**\n * The strategy options used in Sapphire.\n */\nexport interface FlagStrategyOptions {\n\t/**\n\t * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\tflags?: readonly string[] | boolean;\n\n\t/**\n\t * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\toptions?: readonly string[] | boolean;\n\n\t/**\n\t * The prefixes for both flags and options.\n\t * @default ['--', '-', '—']\n\t */\n\tprefixes?: string[];\n\n\t/**\n\t * The flag separators.\n\t * @default ['=', ':']\n\t */\n\tseparators?: string[];\n}\n\nconst never = () => Option.none;\nconst always = () => true;\n\nexport class FlagUnorderedStrategy extends PrefixedStrategy {\n\tpublic readonly flags: readonly string[] | true;\n\tpublic readonly options: readonly string[] | true;\n\n\tpublic constructor({ flags, options, prefixes = ['--', '-', '—'], separators = ['=', ':'] }: FlagStrategyOptions = {}) {\n\t\tsuper(prefixes, separators);\n\t\tthis.flags = flags || [];\n\t\tthis.options = options || [];\n\n\t\tif (this.flags === true) this.allowedFlag = always;\n\t\telse if (this.flags.length === 0) this.matchFlag = never;\n\n\t\tif (this.options === true) {\n\t\t\tthis.allowedOption = always;\n\t\t} else if (this.options.length === 0) {\n\t\t\tthis.matchOption = never;\n\t\t}\n\t}\n\n\tpublic override matchFlag(s: string): Option<string> {\n\t\tconst result = super.matchFlag(s);\n\n\t\t// The flag must be an allowed one.\n\t\tif (result.isSomeAnd((value) => this.allowedFlag(value))) return result;\n\n\t\t// If it did not match a flag, return null.\n\t\treturn Option.none;\n\t}\n\n\tpublic override matchOption(s: string): Option<readonly [key: string, value: string]> {\n\t\tconst result = super.matchOption(s);\n\n\t\tif (result.isSomeAnd((option) => this.allowedOption(option[0]))) return result;\n\n\t\treturn Option.none;\n\t}\n\n\tprivate allowedFlag(s: string) {\n\t\treturn (this.flags as readonly string[]).includes(s);\n\t}\n\n\tprivate allowedOption(s: string) {\n\t\treturn (this.options as readonly string[]).includes(s);\n\t}\n}\n"]}