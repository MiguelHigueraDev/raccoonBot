import { __name } from '../../../../../chunk-G5GHKT7C.mjs';

// src/lib/utils/application-commands/compute-differences/option/minMaxLength.ts
function* handleMinMaxLengthOptions({
  currentIndex,
  existingOption,
  expectedOption,
  keyPath
}) {
  if (existingOption.min_length === void 0 && expectedOption.min_length !== void 0) {
    yield {
      key: `${keyPath(currentIndex)}.min_length`,
      expected: "min_length present",
      original: "no min_length present"
    };
  } else if (existingOption.min_length !== void 0 && expectedOption.min_length === void 0) {
    yield {
      key: `${keyPath(currentIndex)}.min_length`,
      expected: "no min_length present",
      original: "min_length present"
    };
  } else if (existingOption.min_length !== expectedOption.min_length) {
    yield {
      key: `${keyPath(currentIndex)}.min_length`,
      original: String(existingOption.min_length),
      expected: String(expectedOption.min_length)
    };
  }
  if (existingOption.max_length === void 0 && expectedOption.max_length !== void 0) {
    yield {
      key: `${keyPath(currentIndex)}.max_length`,
      expected: "max_length present",
      original: "no max_length present"
    };
  } else if (existingOption.max_length !== void 0 && expectedOption.max_length === void 0) {
    yield {
      key: `${keyPath(currentIndex)}.max_length`,
      expected: "no max_length present",
      original: "max_length present"
    };
  } else if (existingOption.max_length !== expectedOption.max_length) {
    yield {
      key: `${keyPath(currentIndex)}.max_length`,
      original: String(existingOption.max_length),
      expected: String(expectedOption.max_length)
    };
  }
}
__name(handleMinMaxLengthOptions, "handleMinMaxLengthOptions");

export { handleMinMaxLengthOptions };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=minMaxLength.mjs.map