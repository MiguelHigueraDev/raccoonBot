import { __name } from '../../../../chunk-G5GHKT7C.mjs';
import { ApplicationCommandOptionType } from 'discord-api-types/v10';
import { optionTypeToPrettyName, subcommandTypes, hasMinMaxValueSupport, hasChoicesAndAutocompleteSupport, hasMinMaxLengthSupport, hasChannelTypesSupport } from './_shared.mjs';
import { checkDescription } from './description.mjs';
import { checkLocalizations } from './localizations.mjs';
import { checkName } from './name.mjs';
import { handleAutocomplete } from './option/autocomplete.mjs';
import { checkChannelTypes } from './option/channelTypes.mjs';
import { handleMinMaxLengthOptions } from './option/minMaxLength.mjs';
import { handleMinMaxValueOptions } from './option/minMaxValue.mjs';
import { checkOptionRequired } from './option/required.mjs';
import { checkOptionType } from './option/type.mjs';

function* reportOptionDifferences({
  option,
  existingOption,
  currentIndex,
  keyPath = /* @__PURE__ */ __name((index) => `options[${index}]`, "keyPath")
}) {
  if (!existingOption) {
    const expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
    yield {
      key: keyPath(currentIndex),
      expected: `${expectedType} with name ${option.name}`,
      original: "no option present"
    };
    return;
  }
  yield* checkOptionType({
    key: `${keyPath(currentIndex)}.type`,
    originalType: existingOption.type,
    expectedType: option.type
  });
  yield* checkName({
    key: `${keyPath(currentIndex)}.name`,
    oldName: existingOption.name,
    newName: option.name
  });
  const originalLocalizedNames = existingOption.name_localizations;
  const expectedLocalizedNames = option.name_localizations;
  yield* checkLocalizations({
    localeMapName: `${keyPath(currentIndex)}.nameLocalizations`,
    localePresentMessage: "localized names",
    localeMissingMessage: "no localized names",
    originalLocalizedDescriptions: originalLocalizedNames,
    expectedLocalizedDescriptions: expectedLocalizedNames
  });
  yield* checkDescription({
    key: `${keyPath(currentIndex)}.description`,
    oldDescription: existingOption.description,
    newDescription: option.description
  });
  const originalLocalizedDescriptions = existingOption.description_localizations;
  const expectedLocalizedDescriptions = option.description_localizations;
  yield* checkLocalizations({
    localeMapName: `${keyPath(currentIndex)}.descriptionLocalizations`,
    localePresentMessage: "localized descriptions",
    localeMissingMessage: "no localized descriptions",
    originalLocalizedDescriptions,
    expectedLocalizedDescriptions
  });
  yield* checkOptionRequired({
    key: `${keyPath(currentIndex)}.required`,
    oldRequired: existingOption.required,
    newRequired: option.required
  });
  if (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {
    const castedExisting = existingOption;
    const castedExpected = option;
    if (castedExisting.type === ApplicationCommandOptionType.SubcommandGroup && castedExpected.type === ApplicationCommandOptionType.SubcommandGroup) {
      for (const [subcommandIndex, subcommandOption] of castedExpected.options.entries()) {
        yield* reportOptionDifferences({
          currentIndex: subcommandIndex,
          option: subcommandOption,
          existingOption: castedExisting.options?.[subcommandIndex],
          keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
        });
      }
    } else if (castedExisting.type === ApplicationCommandOptionType.Subcommand && castedExpected.type === ApplicationCommandOptionType.Subcommand) {
      yield* handleSubcommandOptions({
        expectedOptions: castedExpected.options,
        existingOptions: castedExisting.options,
        currentIndex,
        keyPath
      });
    }
  }
  if (hasMinMaxValueSupport(option)) {
    const existingCasted = existingOption;
    yield* handleMinMaxValueOptions({
      currentIndex,
      existingOption: existingCasted,
      expectedOption: option,
      keyPath
    });
  }
  if (hasChoicesAndAutocompleteSupport(option)) {
    const existingCasted = existingOption;
    yield* handleAutocomplete({
      expectedOption: option,
      existingOption: existingCasted,
      currentIndex,
      keyPath
    });
  }
  if (hasMinMaxLengthSupport(option)) {
    const existingCasted = existingOption;
    yield* handleMinMaxLengthOptions({
      currentIndex,
      existingOption: existingCasted,
      expectedOption: option,
      keyPath
    });
  }
  if (hasChannelTypesSupport(option)) {
    const existingCasted = existingOption;
    yield* checkChannelTypes({
      currentIndex,
      existingChannelTypes: existingCasted.channel_types,
      keyPath,
      newChannelTypes: option.channel_types
    });
  }
}
__name(reportOptionDifferences, "reportOptionDifferences");
function* handleSubcommandOptions({
  expectedOptions,
  existingOptions,
  currentIndex,
  keyPath
}) {
  if (!existingOptions?.length && expectedOptions?.length) {
    yield {
      key: `${keyPath(currentIndex)}.options`,
      expected: "options present",
      original: "no options present"
    };
  } else if (existingOptions?.length && !expectedOptions?.length) {
    yield {
      key: `${keyPath(currentIndex)}.options`,
      expected: "no options present",
      original: "options present"
    };
  } else if (expectedOptions?.length) {
    let processedIndex = 0;
    for (const subcommandOption of expectedOptions) {
      const currentSubCommandOptionIndex = processedIndex++;
      const existingSubcommandOption = existingOptions[currentSubCommandOptionIndex];
      yield* reportOptionDifferences({
        currentIndex: currentSubCommandOptionIndex,
        option: subcommandOption,
        existingOption: existingSubcommandOption,
        keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
      });
    }
    if (processedIndex < existingOptions.length) {
      let option;
      while ((option = existingOptions[processedIndex]) !== void 0) {
        const expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
        yield {
          key: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,
          expected: "no option present",
          original: `${expectedType} with name ${option.name}`
        };
        processedIndex++;
      }
    }
  }
}
__name(handleSubcommandOptions, "handleSubcommandOptions");

export { reportOptionDifferences };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=option.mjs.map