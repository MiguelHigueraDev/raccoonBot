import { __name } from '../../../chunk-G5GHKT7C.mjs';
import { container } from '@sapphire/pieces';
import { ApplicationCommandType } from 'discord.js';
import { RegisterBehavior, InternalRegistryAPIType } from '../../types/Enums.mjs';
import { Events } from '../../types/Events.mjs';
import { ApplicationCommandRegistry } from './ApplicationCommandRegistry.mjs';
import { getNeededRegistryParameters } from './getNeededParameters.mjs';
import { emitPerRegistryError, emitBulkOverwriteError } from './registriesErrors.mjs';
import { bulkOverwriteDebug, bulkOverwriteWarn, bulkOverwriteInfo } from './registriesLog.mjs';

var defaultBehaviorWhenNotIdentical = RegisterBehavior.Overwrite;
var defaultGuildIds = void 0;
var registries = /* @__PURE__ */ new Map();
var allGuildIdsToFetchCommandsFor = /* @__PURE__ */ new Set();
function acquire(commandName) {
  const existing = registries.get(commandName);
  if (existing) {
    return existing;
  }
  const newRegistry = new ApplicationCommandRegistry(commandName);
  registries.set(commandName, newRegistry);
  return newRegistry;
}
__name(acquire, "acquire");
function setDefaultBehaviorWhenNotIdentical(behavior) {
  defaultBehaviorWhenNotIdentical = behavior ?? RegisterBehavior.Overwrite;
}
__name(setDefaultBehaviorWhenNotIdentical, "setDefaultBehaviorWhenNotIdentical");
function getDefaultBehaviorWhenNotIdentical() {
  return defaultBehaviorWhenNotIdentical;
}
__name(getDefaultBehaviorWhenNotIdentical, "getDefaultBehaviorWhenNotIdentical");
function setDefaultGuildIds(guildIds) {
  defaultGuildIds = guildIds ?? void 0;
}
__name(setDefaultGuildIds, "setDefaultGuildIds");
function getDefaultGuildIds() {
  return defaultGuildIds;
}
__name(getDefaultGuildIds, "getDefaultGuildIds");
async function handleRegistryAPICalls() {
  container.client.emit(Events.ApplicationCommandRegistriesInitialising);
  const commandStore = container.stores.get("commands");
  for (const command of commandStore.values()) {
    if (command.registerApplicationCommands) {
      try {
        await command.registerApplicationCommands(command.applicationCommandRegistry);
      } catch (error) {
        emitPerRegistryError(error, command);
      }
    }
  }
  if (getDefaultBehaviorWhenNotIdentical() === RegisterBehavior.BulkOverwrite) {
    await handleBulkOverwrite(commandStore, container.client.application.commands);
    return;
  }
  const params = await getNeededRegistryParameters(allGuildIdsToFetchCommandsFor);
  await handleAppendOrUpdate(commandStore, params);
}
__name(handleRegistryAPICalls, "handleRegistryAPICalls");
async function handleBulkOverwrite(commandStore, applicationCommands) {
  const now = Date.now();
  const foundGlobalCommands = [];
  const foundGuildCommands = {};
  for (const command of commandStore.values()) {
    const registry = command.applicationCommandRegistry;
    for (const call of registry["apiCalls"]) {
      if (call.registerOptions.guildIds?.length) {
        for (const guildId of call.registerOptions.guildIds) {
          foundGuildCommands[guildId] ??= [];
          foundGuildCommands[guildId].push({ piece: command, data: call.builtData });
        }
        continue;
      }
      foundGlobalCommands.push({ piece: command, data: call.builtData });
    }
  }
  try {
    bulkOverwriteDebug(`Overwriting global application commands, now at ${foundGlobalCommands.length} commands`);
    const result = await applicationCommands.set(foundGlobalCommands.map((x) => x.data));
    for (const [id, globalCommand] of result.entries()) {
      const piece = foundGlobalCommands.find((x) => x.data.name === globalCommand.name)?.piece;
      if (piece) {
        const registry = piece.applicationCommandRegistry;
        switch (globalCommand.type) {
          case ApplicationCommandType.ChatInput: {
            registry["handleIdAddition"](InternalRegistryAPIType.ChatInput, id);
            break;
          }
          case ApplicationCommandType.User:
          case ApplicationCommandType.Message: {
            registry["handleIdAddition"](InternalRegistryAPIType.ContextMenu, id);
            break;
          }
        }
        commandStore.aliases.set(id, piece);
      } else {
        bulkOverwriteWarn(
          `Registered global command "${globalCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
        );
      }
    }
    bulkOverwriteInfo(`Successfully overwrote global application commands. The application now has ${result.size} global commands`);
  } catch (error) {
    emitBulkOverwriteError(error, null);
  }
  for (const [guildId, guildCommands] of Object.entries(foundGuildCommands)) {
    try {
      bulkOverwriteDebug(`Overwriting guild application commands for guild ${guildId}, now at ${guildCommands.length} commands`);
      const result = await applicationCommands.set(
        guildCommands.map((x) => x.data),
        guildId
      );
      for (const [id, guildCommand] of result.entries()) {
        const piece = guildCommands.find((x) => x.data.name === guildCommand.name)?.piece;
        if (piece) {
          const registry = piece.applicationCommandRegistry;
          switch (guildCommand.type) {
            case ApplicationCommandType.ChatInput: {
              registry["handleIdAddition"](InternalRegistryAPIType.ChatInput, id, guildId);
              break;
            }
            case ApplicationCommandType.User:
            case ApplicationCommandType.Message: {
              registry["handleIdAddition"](InternalRegistryAPIType.ContextMenu, id, guildId);
              break;
            }
          }
          commandStore.aliases.set(id, piece);
        } else {
          bulkOverwriteWarn(
            `Registered guild command "${guildCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
          );
        }
      }
      bulkOverwriteInfo(
        `Successfully overwrote guild application commands for guild ${guildId}. The application now has ${result.size} guild commands for guild ${guildId}`
      );
    } catch (error) {
      emitBulkOverwriteError(error, guildId);
    }
  }
  container.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleBulkOverwrite, "handleBulkOverwrite");
async function handleAppendOrUpdate(commandStore, { applicationCommands, globalCommands, guildCommands }) {
  const now = Date.now();
  for (const registry of registries.values()) {
    await registry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    const piece = registry.command;
    if (piece) {
      for (const nameOrId of piece.applicationCommandRegistry.chatInputCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
      for (const nameOrId of piece.applicationCommandRegistry.contextMenuCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
    }
  }
  container.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleAppendOrUpdate, "handleAppendOrUpdate");

export { acquire, allGuildIdsToFetchCommandsFor, defaultBehaviorWhenNotIdentical, defaultGuildIds, getDefaultBehaviorWhenNotIdentical, getDefaultGuildIds, handleBulkOverwrite, handleRegistryAPICalls, registries, setDefaultBehaviorWhenNotIdentical, setDefaultGuildIds };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=ApplicationCommandRegistries.mjs.map