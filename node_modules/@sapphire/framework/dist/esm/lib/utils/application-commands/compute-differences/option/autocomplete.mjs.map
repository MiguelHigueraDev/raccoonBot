{"version":3,"sources":["../../../../../../../src/lib/utils/application-commands/compute-differences/option/autocomplete.ts"],"names":[],"mappings":";;;;;AAEA,SAAS,0BAA0B;AAE5B,UAAU,mBAAmB;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,GAKiC;AAEhC,MAAI,CAAC,eAAe,gBAAgB,eAAe,cAAc;AAChE,UAAM;AAAA,MACL,KAAK,GAAG,QAAQ,YAAY,CAAC;AAAA,MAC7B,UAAU;AAAA,MACV,UAAU;AAAA,IACX;AAAA,EACD,WAES,eAAe,gBAAgB,CAAC,eAAe,cAAc;AACrE,UAAM;AAAA,MACL,KAAK,GAAG,QAAQ,YAAY,CAAC;AAAA,MAC7B,UAAU;AAAA,MACV,UAAU;AAAA,IACX;AAAA,EACD;AAEA,MAAI,CAAC,eAAe,gBAAgB,CAAC,eAAe,cAAc;AAEjE,QAAI,CAAC,eAAe,SAAS,UAAU,eAAe,SAAS,QAAQ;AACtE,YAAM;AAAA,QACL,KAAK,GAAG,QAAQ,YAAY,CAAC;AAAA,QAC7B,UAAU;AAAA,QACV,UAAU;AAAA,MACX;AAAA,IACD,WAES,eAAe,SAAS,UAAU,CAAC,eAAe,SAAS,QAAQ;AAC3E,YAAM;AAAA,QACL,KAAK,GAAG,QAAQ,YAAY,CAAC;AAAA,QAC7B,UAAU;AAAA,QACV,UAAU;AAAA,MACX;AAAA,IACD,WAES,eAAe,SAAS,UAAU,eAAe,SAAS,QAAQ;AAC1E,UAAI,QAAQ;AACZ,iBAAW,UAAU,eAAe,SAAS;AAC5C,cAAM,qBAAqB;AAC3B,cAAM,iBAAiB,eAAe,QAAQ,kBAAkB;AAGhE,YAAI,mBAAmB,QAAW;AACjC,gBAAM;AAAA,YACL,KAAK,GAAG,QAAQ,YAAY,CAAC,YAAY,kBAAkB;AAAA,YAC3D,UAAU;AAAA,YACV,UAAU;AAAA,UACX;AAAA,QACD,OAAO;AACN,cAAI,OAAO,SAAS,eAAe,MAAM;AACxC,kBAAM;AAAA,cACL,KAAK,GAAG,QAAQ,YAAY,CAAC,YAAY,kBAAkB;AAAA,cAC3D,UAAU,eAAe;AAAA,cACzB,UAAU,OAAO;AAAA,YAClB;AAAA,UACD;AAGA,gBAAM,yBAAyB,eAAe;AAC9C,gBAAM,yBAAyB,OAAO;AAEtC,iBAAO,mBAAmB;AAAA,YACzB,eAAe,GAAG,QAAQ,YAAY,CAAC,YAAY,kBAAkB;AAAA,YACrE,sBAAsB;AAAA,YACtB,sBAAsB;AAAA,YACtB,+BAA+B;AAAA,YAC/B,+BAA+B;AAAA,UAChC,CAAC;AAED,cAAI,OAAO,UAAU,eAAe,OAAO;AAC1C,kBAAM;AAAA,cACL,KAAK,GAAG,QAAQ,YAAY,CAAC,YAAY,kBAAkB;AAAA,cAC3D,UAAU,OAAO,eAAe,KAAK;AAAA,cACrC,UAAU,OAAO,OAAO,KAAK;AAAA,YAC9B;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAGA,UAAI,QAAQ,eAAe,QAAQ,QAAQ;AAC1C,YAAI;AACJ,gBAAQ,SAAS,eAAe,QAAQ,KAAK,OAAO,QAAW;AAC9D,gBAAM;AAAA,YACL,KAAK,2BAA2B,QAAQ,YAAY,CAAC,YAAY,KAAK;AAAA,YACtE,UAAU;AAAA,YACV,UAAU,qBAAqB,OAAO,IAAI,eACzC,OAAO,OAAO,UAAU,WAAW,OAAO,QAAQ,IAAI,OAAO,KAAK,GACnE;AAAA,UACD;AAEA;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AA3GiB","sourcesContent":["import type { APIApplicationCommandOptionChoice } from 'discord-api-types/v10';\nimport type { APIApplicationCommandChoosableAndAutocompletableTypes, CommandDifference } from '../_shared';\nimport { checkLocalizations } from '../localizations';\n\nexport function* handleAutocomplete({\n\tcurrentIndex,\n\texistingOption,\n\texpectedOption,\n\tkeyPath\n}: {\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n\texpectedOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n\texistingOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n}): Generator<CommandDifference> {\n\t// 0. No autocomplete and now it should autocomplete\n\tif (!existingOption.autocomplete && expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete enabled',\n\t\t\toriginal: 'autocomplete disabled'\n\t\t};\n\t}\n\t// 1. Have autocomplete and now it shouldn't\n\telse if (existingOption.autocomplete && !expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete disabled',\n\t\t\toriginal: 'autocomplete enabled'\n\t\t};\n\t}\n\n\tif (!expectedOption.autocomplete && !existingOption.autocomplete) {\n\t\t// 0. No choices and now we have choices\n\t\tif (!existingOption.choices?.length && expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'choices present',\n\t\t\t\toriginal: 'no choices present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have choices and now we don't\n\t\telse if (existingOption.choices?.length && !expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'no choices present',\n\t\t\t\toriginal: 'choices present'\n\t\t\t};\n\t\t}\n\t\t// 2. Check every choice to see differences\n\t\telse if (expectedOption.choices?.length && existingOption.choices?.length) {\n\t\t\tlet index = 0;\n\t\t\tfor (const choice of expectedOption.choices) {\n\t\t\t\tconst currentChoiceIndex = index++;\n\t\t\t\tconst existingChoice = existingOption.choices[currentChoiceIndex];\n\n\t\t\t\t// If this choice never existed, return the difference\n\t\t\t\tif (existingChoice === undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,\n\t\t\t\t\t\toriginal: 'no choice present',\n\t\t\t\t\t\texpected: 'choice present'\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tif (choice.name !== existingChoice.name) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,\n\t\t\t\t\t\t\toriginal: existingChoice.name,\n\t\t\t\t\t\t\texpected: choice.name\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check localized names\n\t\t\t\t\tconst originalLocalizedNames = existingChoice.name_localizations;\n\t\t\t\t\tconst expectedLocalizedNames = choice.name_localizations;\n\n\t\t\t\t\tyield* checkLocalizations({\n\t\t\t\t\t\tlocaleMapName: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,\n\t\t\t\t\t\tlocalePresentMessage: 'localized names',\n\t\t\t\t\t\tlocaleMissingMessage: 'no localized names',\n\t\t\t\t\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\t\t\t\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t\t\t\t\t});\n\n\t\t\t\t\tif (choice.value !== existingChoice.value) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,\n\t\t\t\t\t\t\toriginal: String(existingChoice.value),\n\t\t\t\t\t\t\texpected: String(choice.value)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are more choices than the expected ones, return the difference\n\t\t\tif (index < existingOption.choices.length) {\n\t\t\t\tlet choice: APIApplicationCommandOptionChoice;\n\t\t\t\twhile ((choice = existingOption.choices[index]) !== undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,\n\t\t\t\t\t\texpected: 'no choice present',\n\t\t\t\t\t\toriginal: `choice with name \"${choice.name}\" and value ${\n\t\t\t\t\t\t\ttypeof choice.value === 'number' ? choice.value : `\"${choice.value}\"`\n\t\t\t\t\t\t} present`\n\t\t\t\t\t};\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}