import { __name } from '../../chunk-G5GHKT7C.mjs';
import { Store } from '@sapphire/pieces';
import { Result } from '@sapphire/result';
import { Events } from '../types/Events.mjs';
import { InteractionHandlerTypes, InteractionHandler } from './InteractionHandler.mjs';

var _InteractionHandlerStore = class _InteractionHandlerStore extends Store {
  constructor() {
    super(InteractionHandler, { name: "interaction-handlers" });
  }
  async run(interaction) {
    if (this.size === 0)
      return false;
    const promises = [];
    for (const handler of this.values()) {
      const filter = InteractionHandlerFilters.get(handler.interactionHandlerType);
      if (!filter?.(interaction))
        continue;
      const result = await Result.fromAsync(() => handler.parse(interaction));
      result.match({
        ok: (option) => {
          this.container.client.emit(Events.InteractionHandlerParseSuccess, option, { interaction, handler });
          option.match({
            // If the `parse` method returned a `Some` (whatever that `Some`'s value is, it should be handled)
            some: (value) => {
              this.container.client.emit(Events.InteractionHandlerParseSome, option, {
                interaction,
                handler,
                value
              });
              const promise = Result.fromAsync(() => handler.run(interaction, value)).then((res) => res.mapErr((error) => ({ handler, error })));
              promises.push(promise);
            },
            // Emit an event to the user to let them know parse was successful and `none` was returned.
            none: () => this.container.client.emit(Events.InteractionHandlerParseNone, option, { interaction, handler })
          });
        },
        err: (error) => {
          this.container.client.emit(Events.InteractionHandlerParseError, error, { interaction, handler });
        }
      });
    }
    if (promises.length === 0)
      return false;
    const results = await Promise.allSettled(promises);
    for (const result of results) {
      const res = result.value;
      res.inspectErr(
        (value) => this.container.client.emit(Events.InteractionHandlerError, value.error, { interaction, handler: value.handler })
      );
    }
    return true;
  }
};
__name(_InteractionHandlerStore, "InteractionHandlerStore");
var InteractionHandlerStore = _InteractionHandlerStore;
var InteractionHandlerFilters = /* @__PURE__ */ new Map([
  [InteractionHandlerTypes.Button, (interaction) => interaction.isButton()],
  [InteractionHandlerTypes.SelectMenu, (interaction) => interaction.isAnySelectMenu()],
  [InteractionHandlerTypes.ModalSubmit, (interaction) => interaction.isModalSubmit()],
  [InteractionHandlerTypes.MessageComponent, (interaction) => interaction.isMessageComponent()],
  [InteractionHandlerTypes.Autocomplete, (Interaction) => Interaction.isAutocomplete()]
]);

export { InteractionHandlerFilters, InteractionHandlerStore };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=InteractionHandlerStore.mjs.map