{"version":3,"sources":["../../../../src/lib/structures/Argument.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,kBAAkB;AAK3B,SAAS,YAAY;AAkGd,IAAe,YAAf,MAAe,kBACb,WAET;AAAA,EACQ,YAAY,SAAiC,UAAmB,CAAC,GAAc;AACrF,UAAM,SAAS,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,GAAG,OAA8B;AACvC,WAAO,KAAK,GAAG,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAM,SAAyE;AACrF,WAAO,KAAK,MAAM,EAAE,UAAU,MAAM,YAAY,KAAK,MAAM,GAAG,QAAQ,CAAC;AAAA,EACxE;AACD;AAtBA;AAHO,IAAe,WAAf","sourcesContent":["import { AliasPiece } from '@sapphire/pieces';\nimport type { Result } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport type { Message } from 'discord.js';\nimport type { ArgumentError } from '../errors/ArgumentError';\nimport { Args } from '../parsers/Args';\nimport type { MessageCommand } from '../types/CommandTypes';\n\n/**\n * Defines a synchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.\n */\nexport type ArgumentResult<T> = Result<T, ArgumentError<T>>;\n\n/**\n * Defines a synchronous or asynchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.\n */\nexport type AwaitableArgumentResult<T> = Awaitable<ArgumentResult<T>>;\n\n/**\n * Defines an asynchronous result of an {@link Argument}, check {@link Argument.Result} for the synchronous version.\n */\nexport type AsyncArgumentResult<T> = Promise<ArgumentResult<T>>;\n\nexport interface IArgument<T> {\n\t/**\n\t * The name of the argument, this is used to make the identification of an argument easier.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * The method which is called when invoking the argument.\n\t * @param parameter The string parameter to parse.\n\t * @param context The context for the method call, contains the message, command, and other options.\n\t */\n\trun(parameter: string, context: Argument.Context<T>): Argument.AwaitableResult<T>;\n}\n\n/**\n * The base argument class. This class is abstract and is to be extended by subclasses implementing the methods. In\n * Sapphire's workflow, arguments are called when using {@link Args}'s methods (usually used inside {@link Command}s by default).\n *\n * @example\n * ```typescript\n * // TypeScript:\n * import { Argument } from '@sapphire/framework';\n * import { URL } from 'node:url';\n *\n * // Define a class extending `Argument`, then export it.\n * // NOTE: You can use `export default` or `export =` too.\n * export class CoreArgument extends Argument<URL> {\n *   public constructor(context: Argument.LoaderContext) {\n *     super(context, { name: 'hyperlink', aliases: ['url'] });\n *   }\n *\n *   public run(argument: string, context: Argument.Context): Argument.Result<URL> {\n *     try {\n *       return this.ok(new URL(argument));\n *     } catch {\n *       return this.error({\n *         parameter: argument,\n *         context,\n *         identifier: 'ArgumentHyperlinkInvalidURL',\n *         message: 'The argument did not resolve to a valid URL.'\n *       });\n *     }\n *   }\n * }\n *\n * // Augment the ArgType structure so `args.pick('url')`, `args.repeat('url')`\n * // and others have a return type of `URL`.\n * declare module '@sapphire/framework' {\n *   export interface ArgType {\n *     url: URL;\n *   }\n * }\n * ```\n *\n * @example\n * ```javascript\n * // JavaScript:\n * const { Argument } = require('@sapphire/framework');\n *\n * // Define a class extending `Argument`, then export it.\n * module.exports = class CoreArgument extends Argument {\n *   constructor(context) {\n *     super(context, { name: 'hyperlink', aliases: ['url'] });\n *   }\n *\n *   run(argument, context) {\n *     try {\n *       return this.ok(new URL(argument));\n *     } catch {\n *       return this.error({\n *         parameter: argument,\n *         context,\n *         identifier: 'ArgumentHyperlinkInvalidURL',\n *         message: 'The argument did not resolve to a valid URL.'\n *       });\n *     }\n *   }\n * }\n * ```\n */\nexport abstract class Argument<T = unknown, Options extends Argument.Options = Argument.Options>\n\textends AliasPiece<Options, 'arguments'>\n\timplements IArgument<T>\n{\n\tpublic constructor(context: Argument.LoaderContext, options: Options = {} as Options) {\n\t\tsuper(context, options);\n\t}\n\n\tpublic abstract run(parameter: string, context: Argument.Context<T>): Argument.AwaitableResult<T>;\n\n\t/**\n\t * Wraps a value into a successful value.\n\t * @param value The value to wrap.\n\t */\n\tpublic ok(value: T): Argument.Result<T> {\n\t\treturn Args.ok(value);\n\t}\n\n\t/**\n\t * Constructs an {@link Err} result containing an {@link ArgumentError} with a custom type.\n\t * @param options The options to pass to the ArgumentError.\n\t */\n\tpublic error(options: Omit<ArgumentError.Options<T>, 'argument'>): Argument.Result<T> {\n\t\treturn Args.error({ argument: this, identifier: this.name, ...options });\n\t}\n}\n\nexport interface ArgumentOptions extends AliasPiece.Options {}\n\nexport interface ArgumentContext<T = unknown> extends Record<PropertyKey, unknown> {\n\targument: IArgument<T>;\n\targs: Args;\n\tmessage: Message;\n\tcommand: MessageCommand;\n\tcommandContext: MessageCommand.RunContext;\n\tminimum?: number;\n\tmaximum?: number;\n\tinclusive?: boolean;\n}\n\nexport namespace Argument {\n\texport type Options = ArgumentOptions;\n\texport type Context<T = unknown> = ArgumentContext<T>;\n\texport type LoaderContext = AliasPiece.LoaderContext<'arguments'>;\n\texport type Result<T> = ArgumentResult<T>;\n\texport type AwaitableResult<T> = AwaitableArgumentResult<T>;\n\texport type AsyncResult<T> = AsyncArgumentResult<T>;\n}\n"]}