{"version":3,"sources":["../../../../src/lib/structures/InteractionHandler.ts"],"names":["InteractionHandlerTypes"],"mappings":";;;;;AAAA,SAAS,aAAa;AACtB,SAAS,cAAc;AAIhB,IAAe,sBAAf,MAAe,4BAAoG,MAGxH;AAAA,EAOM,YAAY,SAA2C,SAAkB;AAC/E,UAAM,SAAS,OAAO;AAEtB,SAAK,yBAAyB,QAAQ;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+CO,MAAM,cAAuD;AACnE,WAAO,KAAK,KAAK;AAAA,EAClB;AAAA,EAIO,KAAQ,MAAsC;AACpD,WAAO,OAAO,KAAK,IAAI;AAAA,EACxB;AAAA,EAEO,OAAoB;AAC1B,WAAO,OAAO;AAAA,EACf;AAAA,EAEgB,SAAiC;AAChD,WAAO;AAAA,MACN,GAAG,MAAM,OAAO;AAAA,MAChB,wBAAwB,KAAK;AAAA,IAC9B;AAAA,EACD;AACD;AA9EE;AAHK,IAAe,qBAAf;AAyGA,IAAK,0BAAL,kBAAKA,6BAAL;AAEN,EAAAA,kDAAA;AACA,EAAAA,kDAAA;AACA,EAAAA,kDAAA;AAGA,EAAAA,kDAAA;AAEA,EAAAA,kDAAA;AATW,SAAAA;AAAA,GAAA","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Option } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport type { Interaction } from 'discord.js';\n\nexport abstract class InteractionHandler<Options extends InteractionHandler.Options = InteractionHandler.Options> extends Piece<\n\tOptions,\n\t'interaction-handlers'\n> {\n\t/**\n\t * The type for this handler\n\t * @since 3.0.0\n\t */\n\tpublic readonly interactionHandlerType: InteractionHandlerTypes;\n\n\tpublic constructor(context: InteractionHandler.LoaderContext, options: Options) {\n\t\tsuper(context, options);\n\n\t\tthis.interactionHandlerType = options.interactionHandlerType;\n\t}\n\n\tpublic abstract run(interaction: Interaction, parsedData?: unknown): unknown;\n\n\t/**\n\t * A custom function that will be called when checking if an interaction should be passed to this handler.\n\t * You can use this method to not only filter by ids, but also pre-parse the data from the id for use in the run method.\n\t *\n\t * By default, all interactions of the type you specified will run in a handler. You should override this method\n\t * to change that behavior.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Parsing a button handler\n\t * public override parse(interaction: ButtonInteraction) {\n\t *   if (interaction.customId.startsWith('my-awesome-clicky-button')) {\n\t * \t   // Returning a `some` here means that the run method should be called next!\n\t *     return this.some({ isMyBotAwesome: true, awesomenessLevel: 9001 });\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Getting data from a database based on the custom id\n\t * public override async parse(interaction: ButtonInteraction) {\n\t *   // This code is purely for demonstration purposes only!\n\t *   if (interaction.customId.startsWith('example-data')) {\n\t *     const [, userId, channelId] = interaction.customId.split('.');\n\t *\n\t * \t   const dataFromDatabase = await container.prisma.exampleData.findFirst({ where: { userId, channelId } });\n\t *\n\t *     // Returning a `some` here means that the run method should be called next!\n\t *     return this.some(dataFromDatabase);\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @returns An {@link Option} (or a {@link Promise Promised} {@link Option}) that indicates if this interaction should be\n\t * handled by this handler, and any extra data that should be passed to the {@link InteractionHandler.run run method}\n\t */\n\tpublic parse(_interaction: Interaction): Awaitable<Option<unknown>> {\n\t\treturn this.some();\n\t}\n\n\tpublic some(): Option.Some<never>;\n\tpublic some<T>(data: T): Option.Some<T>;\n\tpublic some<T>(data?: T): Option.Some<T | undefined> {\n\t\treturn Option.some(data);\n\t}\n\n\tpublic none(): Option.None {\n\t\treturn Option.none;\n\t}\n\n\tpublic override toJSON(): InteractionHandlerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tinteractionHandlerType: this.interactionHandlerType\n\t\t};\n\t}\n}\n\nexport interface InteractionHandlerOptions extends Piece.Options {\n\t/**\n\t * The type of interaction this handler is for. Must be one of {@link InteractionHandlerTypes}.\n\t */\n\treadonly interactionHandlerType: InteractionHandlerTypes;\n}\n\nexport interface InteractionHandlerJSON extends Piece.JSON {\n\tinteractionHandlerType: InteractionHandlerTypes;\n}\n\nexport type InteractionHandlerParseResult<Instance extends InteractionHandler> = Option.UnwrapSome<Awaited<ReturnType<Instance['parse']>>>;\n\nexport namespace InteractionHandler {\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'interaction-handlers'>;\n\texport type Options = InteractionHandlerOptions;\n\texport type JSON = InteractionHandlerJSON;\n\texport type ParseResult<Instance extends InteractionHandler> = InteractionHandlerParseResult<Instance>;\n}\n\nexport enum InteractionHandlerTypes {\n\t// Specifically focused types\n\tButton,\n\tSelectMenu,\n\tModalSubmit,\n\n\t// More free-falling handlers, for 1 shared handler between buttons and select menus (someone will have a use for this >,>)\n\tMessageComponent,\n\t// Optional autocompletes, you can use this or in-command\n\tAutocomplete\n}\n"]}