{"version":3,"sources":["../../../../src/lib/structures/InteractionHandlerStore.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,aAAa;AACtB,SAAS,cAA2B;AAEpC,SAAS,cAAc;AACvB,SAAS,oBAAoB,+BAA+D;AAErF,IAAM,2BAAN,MAAM,iCAAgC,MAAkD;AAAA,EACvF,cAAc;AACpB,UAAM,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAAA,EAC3D;AAAA,EAEA,MAAa,IAAI,aAA0B;AAE1C,QAAI,KAAK,SAAS;AAAG,aAAO;AAE5B,UAAM,WAAmH,CAAC;AAG1H,eAAW,WAAW,KAAK,OAAO,GAAG;AACpC,YAAM,SAAS,0BAA0B,IAAI,QAAQ,sBAAsB;AAI3E,UAAI,CAAC,SAAS,WAAW;AAAG;AAG5B,YAAM,SAAS,MAAM,OAAO,UAAU,MAAM,QAAQ,MAAM,WAAW,CAAC;AACtE,aAAO,MAAM;AAAA,QACZ,IAAI,CAAC,WAAW;AAEf,eAAK,UAAU,OAAO,KAAK,OAAO,gCAAgC,QAAQ,EAAE,aAAa,QAAQ,CAAC;AAElG,iBAAO,MAAM;AAAA;AAAA,YAEZ,MAAM,CAAC,UAAU;AAEhB,mBAAK,UAAU,OAAO,KAAK,OAAO,6BAA6B,QAAqC;AAAA,gBACnG;AAAA,gBACA;AAAA,gBACA;AAAA,cACD,CAAC;AAGD,oBAAM,UAAU,OAAO,UAAU,MAAM,QAAQ,IAAI,aAAa,KAAK,CAAC,EACpE,KAAK,CAAC,QAAQ,IAAI,OAAO,CAAC,WAAW,EAAE,SAAS,MAAM,EAAE,CAAC;AAE3D,uBAAS,KAAK,OAAO;AAAA,YACtB;AAAA;AAAA,YAEA,MAAM,MAAM,KAAK,UAAU,OAAO,KAAK,OAAO,6BAA6B,QAAuB,EAAE,aAAa,QAAQ,CAAC;AAAA,UAC3H,CAAC;AAAA,QACF;AAAA,QACA,KAAK,CAAC,UAAU;AAEf,eAAK,UAAU,OAAO,KAAK,OAAO,8BAA8B,OAAO,EAAE,aAAa,QAAQ,CAAC;AAAA,QAChG;AAAA,MACD,CAAC;AAAA,IACF;AAGA,QAAI,SAAS,WAAW;AAAG,aAAO;AAElC,UAAM,UAAU,MAAM,QAAQ,WAAW,QAAQ;AAEjD,eAAW,UAAU,SAAS;AAC7B,YAAM,MACL,OASC;AAEF,UAAI;AAAA,QAAW,CAAC,UACf,KAAK,UAAU,OAAO,KAAK,OAAO,yBAAyB,MAAM,OAAO,EAAE,aAAa,SAAS,MAAM,QAAQ,CAAC;AAAA,MAChH;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;AA9E+F;AAAxF,IAAM,0BAAN;AAgFA,IAAM,4BAA4B,oBAAI,IAAoE;AAAA,EAChH,CAAC,wBAAwB,QAAQ,CAAC,gBAAgB,YAAY,SAAS,CAAC;AAAA,EACxE,CAAC,wBAAwB,YAAY,CAAC,gBAAgB,YAAY,gBAAgB,CAAC;AAAA,EACnF,CAAC,wBAAwB,aAAa,CAAC,gBAAgB,YAAY,cAAc,CAAC;AAAA,EAElF,CAAC,wBAAwB,kBAAkB,CAAC,gBAAgB,YAAY,mBAAmB,CAAC;AAAA,EAC5F,CAAC,wBAAwB,cAAc,CAAC,gBAAgB,YAAY,eAAe,CAAC;AACrF,CAAC","sourcesContent":["import { Store } from '@sapphire/pieces';\nimport { Result, type Option } from '@sapphire/result';\nimport type { Interaction } from 'discord.js';\nimport { Events } from '../types/Events';\nimport { InteractionHandler, InteractionHandlerTypes, type InteractionHandlerOptions } from './InteractionHandler';\n\nexport class InteractionHandlerStore extends Store<InteractionHandler, 'interaction-handlers'> {\n\tpublic constructor() {\n\t\tsuper(InteractionHandler, { name: 'interaction-handlers' });\n\t}\n\n\tpublic async run(interaction: Interaction) {\n\t\t// Early-exit for optimization\n\t\tif (this.size === 0) return false;\n\n\t\tconst promises: Promise<Result<unknown, { handler: InteractionHandler<InteractionHandlerOptions>; error: unknown }>>[] = [];\n\n\t\t// Iterate through every registered handler\n\t\tfor (const handler of this.values()) {\n\t\t\tconst filter = InteractionHandlerFilters.get(handler.interactionHandlerType);\n\n\t\t\t// If the filter is missing (we don't support it or someone didn't register it manually while waiting for us to implement it),\n\t\t\t// or it doesn't match the expected handler type, skip the handler\n\t\t\tif (!filter?.(interaction)) continue;\n\n\t\t\t// Get the result of the `parse` method in the handler\n\t\t\tconst result = await Result.fromAsync(() => handler.parse(interaction));\n\t\t\tresult.match({\n\t\t\t\tok: (option) => {\n\t\t\t\t\t// Emit an event to the user to let them know `parse` was successful\n\t\t\t\t\tthis.container.client.emit(Events.InteractionHandlerParseSuccess, option, { interaction, handler });\n\n\t\t\t\t\toption.match({\n\t\t\t\t\t\t// If the `parse` method returned a `Some` (whatever that `Some`'s value is, it should be handled)\n\t\t\t\t\t\tsome: (value) => {\n\t\t\t\t\t\t\t// Emit an event to the user to let them know parse was successful and `some` was returned.\n\t\t\t\t\t\t\tthis.container.client.emit(Events.InteractionHandlerParseSome, option as Option.Some<typeof value>, {\n\t\t\t\t\t\t\t\tinteraction,\n\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Schedule the run of the handler method\n\t\t\t\t\t\t\tconst promise = Result.fromAsync(() => handler.run(interaction, value)) //\n\t\t\t\t\t\t\t\t.then((res) => res.mapErr((error) => ({ handler, error })));\n\n\t\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// Emit an event to the user to let them know parse was successful and `none` was returned.\n\t\t\t\t\t\tnone: () => this.container.client.emit(Events.InteractionHandlerParseNone, option as Option.None, { interaction, handler })\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terr: (error) => {\n\t\t\t\t\t// If the `parse` method threw an error (spoiler: please don't), skip the handler\n\t\t\t\t\tthis.container.client.emit(Events.InteractionHandlerParseError, error, { interaction, handler });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Yet another early exit\n\t\tif (promises.length === 0) return false;\n\n\t\tconst results = await Promise.allSettled(promises);\n\n\t\tfor (const result of results) {\n\t\t\tconst res = (\n\t\t\t\tresult as PromiseFulfilledResult<\n\t\t\t\t\tResult<\n\t\t\t\t\t\tunknown,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: Error;\n\t\t\t\t\t\t\thandler: InteractionHandler;\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t).value;\n\n\t\t\tres.inspectErr((value) =>\n\t\t\t\tthis.container.client.emit(Events.InteractionHandlerError, value.error, { interaction, handler: value.handler })\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nexport const InteractionHandlerFilters = new Map<InteractionHandlerTypes, (interaction: Interaction) => boolean>([\n\t[InteractionHandlerTypes.Button, (interaction) => interaction.isButton()],\n\t[InteractionHandlerTypes.SelectMenu, (interaction) => interaction.isAnySelectMenu()],\n\t[InteractionHandlerTypes.ModalSubmit, (interaction) => interaction.isModalSubmit()],\n\n\t[InteractionHandlerTypes.MessageComponent, (interaction) => interaction.isMessageComponent()],\n\t[InteractionHandlerTypes.Autocomplete, (Interaction) => Interaction.isAutocomplete()]\n]);\n"]}