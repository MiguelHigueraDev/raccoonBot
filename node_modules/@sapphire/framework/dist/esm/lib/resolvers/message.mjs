import { __name } from '../../chunk-G5GHKT7C.mjs';
import { SnowflakeRegex, MessageLinkRegex, ChannelMessageRegex } from '@sapphire/discord-utilities';
import { isStageChannel, isGuildBasedChannel, isTextBasedChannel, isAnyInteraction, isNewsChannel, isTextChannel } from '@sapphire/discord.js-utilities';
import { container } from '@sapphire/pieces';
import { Result } from '@sapphire/result';
import { PermissionFlagsBits } from 'discord.js';
import { Identifiers } from '../errors/Identifiers.mjs';

async function resolveMessage(parameter, options) {
  const message = await resolveById(parameter, options) ?? await resolveByLink(parameter, options) ?? await resolveByChannelAndMessage(parameter, options);
  if (message) {
    return Result.ok(message);
  }
  return Result.err(Identifiers.ArgumentMessageError);
}
__name(resolveMessage, "resolveMessage");
function resolveById(parameter, options) {
  if (!SnowflakeRegex.test(parameter) || isStageChannel(options.messageOrInteraction.channel)) {
    return null;
  }
  if (options.channel && !isStageChannel(options.channel)) {
    return options.channel.messages.fetch(parameter);
  }
  if (options.scan && isGuildBasedChannel(options.messageOrInteraction.channel)) {
    for (const channel of options.messageOrInteraction.channel.guild.channels.cache.values()) {
      if (!isTextBasedChannel(channel) || isStageChannel(channel)) {
        continue;
      }
      const message = channel.messages.cache.get(parameter);
      if (message) {
        return message;
      }
    }
  }
  return options.messageOrInteraction.channel?.messages.fetch(parameter) ?? null;
}
__name(resolveById, "resolveById");
async function resolveByLink(parameter, options) {
  if (!options.messageOrInteraction.guild) {
    return null;
  }
  const matches = MessageLinkRegex.exec(parameter);
  if (!matches) {
    return null;
  }
  const [, guildId, channelId, messageId] = matches;
  const guild = container.client.guilds.cache.get(guildId);
  if (guild !== options.messageOrInteraction.guild) {
    return null;
  }
  return getMessageFromChannel(
    channelId,
    messageId,
    isAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author
  );
}
__name(resolveByLink, "resolveByLink");
async function resolveByChannelAndMessage(parameter, options) {
  const result = ChannelMessageRegex.exec(parameter)?.groups;
  if (!result) {
    return null;
  }
  return getMessageFromChannel(
    result.channelId,
    result.messageId,
    isAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author
  );
}
__name(resolveByChannelAndMessage, "resolveByChannelAndMessage");
async function getMessageFromChannel(channelId, messageId, originalAuthor) {
  const channel = container.client.channels.cache.get(channelId);
  if (!channel) {
    return null;
  }
  if (!(isNewsChannel(channel) || isTextChannel(channel))) {
    return null;
  }
  if (!channel.viewable) {
    return null;
  }
  if (!channel.permissionsFor(originalAuthor)?.has(PermissionFlagsBits.ViewChannel)) {
    return null;
  }
  return channel.messages.fetch(messageId);
}
__name(getMessageFromChannel, "getMessageFromChannel");

export { resolveMessage };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=message.mjs.map