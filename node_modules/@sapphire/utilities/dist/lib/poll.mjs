import { __name } from '../chunk-G5GHKT7C.mjs';
import { sleep } from './sleep.mjs';

async function poll(cb, cbCondition, options = {}) {
  var _a, _b, _c;
  const signal = (_a = options.signal) != null ? _a : void 0;
  const maximumRetries = (_b = options.maximumRetries) != null ? _b : Infinity;
  if (typeof maximumRetries !== "number")
    throw new TypeError("Expected maximumRetries to be a number");
  if (!(maximumRetries >= 0))
    throw new RangeError("Expected maximumRetries to be a non-negative number");
  const waitBetweenRetries = (_c = options.waitBetweenRetries) != null ? _c : 0;
  if (typeof waitBetweenRetries !== "number")
    throw new TypeError("Expected waitBetweenRetries to be a number");
  if (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {
    throw new RangeError("Expected waitBetweenRetries to be a positive safe integer");
  }
  signal == null ? void 0 : signal.throwIfAborted();
  let result = await cb(signal);
  for (let retries = 0; retries < maximumRetries && !await cbCondition(result, signal); retries++) {
    signal == null ? void 0 : signal.throwIfAborted();
    if (waitBetweenRetries > 0) {
      if (options.verbose)
        console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);
      await sleep(waitBetweenRetries, void 0, { signal });
    }
    result = await cb(signal);
  }
  return result;
}
__name(poll, "poll");

export { poll };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=poll.mjs.map