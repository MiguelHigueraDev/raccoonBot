import { __name } from '../../chunk-G5GHKT7C.mjs';

// src/lib/debounce/debounce.ts
function debounce(func, options = {}) {
  var _a;
  let lastArgs;
  let result;
  let timerId;
  let lastCallTime;
  let lastInvokeTime = 0;
  const wait = (_a = options.wait) != null ? _a : 0;
  const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
  function invokeFunc(time) {
    const args = lastArgs;
    lastArgs = void 0;
    lastInvokeTime = time;
    result = func(...args);
    return result;
  }
  __name(invokeFunc, "invokeFunc");
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return result;
  }
  __name(leadingEdge, "leadingEdge");
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const result2 = wait - timeSinceLastCall;
    return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
  }
  __name(remainingWait, "remainingWait");
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || //
    timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
  }
  __name(shouldInvoke, "shouldInvoke");
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      trailingEdge(time);
      return;
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  __name(timerExpired, "timerExpired");
  function trailingEdge(time) {
    timerId = void 0;
    return invokeFunc(time);
  }
  __name(trailingEdge, "trailingEdge");
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = void 0;
    lastCallTime = void 0;
    timerId = void 0;
  }
  __name(cancel, "cancel");
  function flush() {
    return timerId === void 0 ? result : trailingEdge(Date.now());
  }
  __name(flush, "flush");
  function debounced(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    lastArgs = args;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxWait !== null) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  __name(debounced, "debounced");
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
__name(debounce, "debounce");

export { debounce };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=debounce.mjs.map