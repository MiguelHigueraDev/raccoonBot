'use strict';

var sleepSync_js = require('./sleepSync.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var _a;
var DOMException = (_a = globalThis.DOMException) != null ? _a : (
  // DOMException was only made a global in Node v17.0.0, but this library supports Node v16.0.0 and up
  AbortSignal.abort().reason.constructor
);
function pollSync(cb, cbCondition, options = {}) {
  var _a2, _b, _c;
  const timeout = (_a2 = options.timeout) != null ? _a2 : Infinity;
  if (typeof timeout !== "number")
    throw new TypeError("Expected timeout to be a number");
  if (!(timeout >= 0))
    throw new RangeError("Expected timeout to be a non-negative number");
  const maximumRetries = (_b = options.maximumRetries) != null ? _b : Infinity;
  if (typeof maximumRetries !== "number")
    throw new TypeError("Expected maximumRetries to be a number");
  if (!(maximumRetries >= 0))
    throw new RangeError("Expected maximumRetries to be a non-negative number");
  const waitBetweenRetries = (_c = options.waitBetweenRetries) != null ? _c : 0;
  if (typeof waitBetweenRetries !== "number")
    throw new TypeError("Expected waitBetweenRetries to be a number");
  if (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {
    throw new RangeError("Expected waitBetweenRetries to be a positive safe integer");
  }
  const end = Date.now() + timeout;
  let result = cb();
  for (let retries = 0; retries < maximumRetries && !cbCondition(result); retries++) {
    if (Date.now() + waitBetweenRetries > end)
      throw new DOMException("This operation was aborted", "AbortError");
    if (waitBetweenRetries > 0) {
      if (options.verbose)
        console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);
      sleepSync_js.sleepSync(waitBetweenRetries);
    }
    result = cb();
  }
  return result;
}
__name(pollSync, "pollSync");

exports.pollSync = pollSync;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=pollSync.js.map