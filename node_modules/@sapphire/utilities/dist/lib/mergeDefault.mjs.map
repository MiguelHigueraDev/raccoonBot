{"version":3,"sources":["../../src/lib/mergeDefault.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AAyClB,SAAS,aAA4D,MAAS,YAAqC;AAEzH,MAAI,CAAC;AAAY,WAAO,UAAU,IAAI;AAEtC,aAAW,CAAC,SAAS,SAAS,KAAK,OAAO,QAAQ,IAAI,GAAG;AACxD,UAAM,2BAA2B,QAAQ,IAAI,YAAY,OAAO;AAEhE,QAAI,OAAO,6BAA6B,aAAa;AACpD,cAAQ,IAAI,YAAY,SAAS,UAAU,SAAS,CAAC;AAAA,IACtD,WAAW,SAAS,wBAAwB,GAAG;AAC9C,cAAQ,IAAI,YAAY,SAAS,aAAc,gCAAa,CAAC,GAAqB,wBAAwB,CAAC;AAAA,IAC5G;AAAA,EACD;AAEA,SAAO;AACR;AAfgB","sourcesContent":["import { deepClone } from './deepClone';\nimport { isObject } from './isObject';\nimport type { DeepRequired, NonNullObject } from './types';\n\n/**\n * Deep merges 2 objects. Properties from the second parameter are applied to the first.\n * @remark `overwrites` is also mutated!\n * @remark If the value of a key in `overwrites` is `undefined` then the value of that same key in `base` is used instead!\n * @remark This is essentially `{ ...base, ...overwrites }` but recursively\n * @param base Base object\n * @param overwrites Overwrites to apply\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = {}; // will be { a: 0, b: 1 } after merge\n * mergeDefault(base, overwrites) // { a: 0, b: 1 }\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: 2, i: 3 };\n * mergeDefault(base, overwrites) // { a: 2, i: 3, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: null };\n * mergeDefault(base, overwrites) // { a: null, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: undefined };\n * mergeDefault(base, overwrites) // { a: 0, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: null };\n * const overwrites = { a: { b: 5 } };\n * mergeDefault(base, overwrites) // { a: { b: 5 } };\n * ```\n */\nexport function mergeDefault<A extends NonNullObject, B extends Partial<A>>(base: A, overwrites?: B): DeepRequired<A & B> {\n\t// If no overwrites are specified then deep clone the base\n\tif (!overwrites) return deepClone(base) as DeepRequired<A & B>;\n\n\tfor (const [baseKey, baseValue] of Object.entries(base)) {\n\t\tconst overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);\n\n\t\tif (typeof overwritesValueAtBaseKey === 'undefined') {\n\t\t\tReflect.set(overwrites, baseKey, deepClone(baseValue));\n\t\t} else if (isObject(overwritesValueAtBaseKey)) {\n\t\t\tReflect.set(overwrites, baseKey, mergeDefault((baseValue ?? {}) as NonNullObject, overwritesValueAtBaseKey));\n\t\t}\n\t}\n\n\treturn overwrites as DeepRequired<A & B>;\n}\n"]}