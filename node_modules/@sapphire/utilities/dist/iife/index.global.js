var SapphireUtilities = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

  // src/lib/arrayStrictEquals.ts
  function arrayStrictEquals(arr1, arr2) {
    if (arr1 === arr2)
      return true;
    if (arr1.length !== arr2.length)
      return false;
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i])
        return false;
    }
    return true;
  }
  __name(arrayStrictEquals, "arrayStrictEquals");

  // src/lib/cast.ts
  function cast(value) {
    return value;
  }
  __name(cast, "cast");

  // src/lib/chunk.ts
  function chunk(array, chunkSize) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!Number.isInteger(chunkSize))
      throw new TypeError("chunkSize must be an integer.");
    if (chunkSize < 1)
      throw new RangeError("chunkSize must be 1 or greater.");
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize)
      chunks.push(array.slice(i, i + chunkSize));
    return chunks;
  }
  __name(chunk, "chunk");

  // src/lib/classExtends.ts
  function classExtends(value, base) {
    let ctor = value;
    while (ctor !== null) {
      if (ctor === base)
        return true;
      ctor = Object.getPrototypeOf(ctor);
    }
    return false;
  }
  __name(classExtends, "classExtends");

  // src/lib/codeBlock.ts
  var zws = String.fromCharCode(8203);
  function codeBlock(...args) {
    const [language, content] = args.length === 1 ? ["", args[0]] : args;
    return `\`\`\`${language}
${String(content).replace(/```/, `\`${zws}\`\``).replace(/`$/g, `\`${zws}`)}
\`\`\``;
  }
  __name(codeBlock, "codeBlock");

  // src/lib/splitText.ts
  function splitText(str, length, char = " ") {
    const x = str.substring(0, length).lastIndexOf(char);
    const pos = x === -1 ? length : x;
    return str.substring(0, pos);
  }
  __name(splitText, "splitText");

  // src/lib/cutText.ts
  function cutText(str, length) {
    if (str.length < length)
      return str;
    const cut = splitText(str, length - 3);
    if (cut.length < length - 3)
      return `${cut}...`;
    return `${cut.slice(0, length - 3)}...`;
  }
  __name(cutText, "cutText");

  // src/lib/debounce/debounce.ts
  function debounce(func, options = {}) {
    var _a2;
    let lastArgs;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    const wait = (_a2 = options.wait) != null ? _a2 : 0;
    const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
    function invokeFunc(time) {
      const args = lastArgs;
      lastArgs = void 0;
      lastInvokeTime = time;
      result = func(...args);
      return result;
    }
    __name(invokeFunc, "invokeFunc");
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return result;
    }
    __name(leadingEdge, "leadingEdge");
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const result2 = wait - timeSinceLastCall;
      return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
    }
    __name(remainingWait, "remainingWait");
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || //
      timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
    }
    __name(shouldInvoke, "shouldInvoke");
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        trailingEdge(time);
        return;
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    __name(timerExpired, "timerExpired");
    function trailingEdge(time) {
      timerId = void 0;
      return invokeFunc(time);
    }
    __name(trailingEdge, "trailingEdge");
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = void 0;
      lastCallTime = void 0;
      timerId = void 0;
    }
    __name(cancel, "cancel");
    function flush() {
      return timerId === void 0 ? result : trailingEdge(Date.now());
    }
    __name(flush, "flush");
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxWait !== null) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    __name(debounced, "debounced");
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  __name(debounce, "debounce");

  // src/lib/isPrimitive.ts
  var primitiveTypes = ["string", "bigint", "number", "boolean"];
  function isPrimitive(input) {
    return primitiveTypes.includes(typeof input);
  }
  __name(isPrimitive, "isPrimitive");

  // src/lib/deepClone.ts
  var TypedArrayPrototype = Object.getPrototypeOf(Uint8Array);
  function deepClone(source) {
    if (source === null || isPrimitive(source)) {
      return source;
    }
    if (source instanceof Date) {
      const output = new source.constructor(source);
      return output;
    }
    if (source instanceof TypedArrayPrototype) {
      const output = source.constructor.from(source);
      return output;
    }
    if (Array.isArray(source)) {
      const output = new source.constructor(source.length);
      for (let i = 0; i < source.length; i++) {
        output[i] = deepClone(source[i]);
      }
      return output;
    }
    if (source instanceof Map) {
      const output = new source.constructor();
      for (const [key, value] of source.entries()) {
        output.set(key, deepClone(value));
      }
      return output;
    }
    if (source instanceof Set) {
      const output = new source.constructor();
      for (const value of source.values()) {
        output.add(deepClone(value));
      }
      return output;
    }
    if (typeof source === "object") {
      const output = new source.constructor();
      for (const [key, value] of Object.entries(source)) {
        Object.defineProperty(output, key, {
          configurable: true,
          enumerable: true,
          value: deepClone(value),
          writable: true
        });
      }
      return output;
    }
    return source;
  }
  __name(deepClone, "deepClone");

  // src/lib/isNullOrUndefined.ts
  function isNullOrUndefined(value) {
    return value === void 0 || value === null;
  }
  __name(isNullOrUndefined, "isNullOrUndefined");

  // src/lib/filterNullAndUndefined.ts
  function filterNullAndUndefined(value) {
    return !isNullOrUndefined(value);
  }
  __name(filterNullAndUndefined, "filterNullAndUndefined");

  // src/lib/isNullOrUndefinedOrEmpty.ts
  function isNullOrUndefinedOrEmpty(value) {
    return isNullOrUndefined(value) || value.length === 0;
  }
  __name(isNullOrUndefinedOrEmpty, "isNullOrUndefinedOrEmpty");

  // src/lib/filterNullAndUndefinedAndEmpty.ts
  function filterNullAndUndefinedAndEmpty(value) {
    return !isNullOrUndefinedOrEmpty(value);
  }
  __name(filterNullAndUndefinedAndEmpty, "filterNullAndUndefinedAndEmpty");

  // src/lib/isNullOrUndefinedOrZero.ts
  function isNullOrUndefinedOrZero(value) {
    return value === 0 || isNullOrUndefined(value);
  }
  __name(isNullOrUndefinedOrZero, "isNullOrUndefinedOrZero");

  // src/lib/filterNullAndUndefinedAndZero.ts
  function filterNullAndUndefinedAndZero(value) {
    return !isNullOrUndefinedOrZero(value);
  }
  __name(filterNullAndUndefinedAndZero, "filterNullAndUndefinedAndZero");

  // src/lib/getDeepObjectKeys.ts
  function getDeepObjectKeys(obj, options) {
    return [...getDeepObjectKeysGenerator(obj, options)];
  }
  __name(getDeepObjectKeys, "getDeepObjectKeys");
  function* getDeepObjectKeysGenerator(obj, { arrayKeysIndexStyle = "dotted" } = { arrayKeysIndexStyle: "dotted" }) {
    if (Array.isArray(obj)) {
      for (const [index, value] of obj.entries()) {
        yield* getDeepArrayKeysRecursive(value, index, { arrayKeysIndexStyle });
      }
    } else {
      for (const [key, value] of Object.entries(obj)) {
        yield* getDeepObjectKeysRecursive(value, `${key}`, { arrayKeysIndexStyle });
      }
    }
  }
  __name(getDeepObjectKeysGenerator, "getDeepObjectKeysGenerator");
  function* getDeepArrayKeysRecursive(value, index, { arrayKeysIndexStyle }) {
    const resolvedIndex = arrayKeysIndexStyle === "dotted" ? `${index}` : arrayKeysIndexStyle === "braces" ? `[${index}]` : `[${index}].`;
    yield* getDeepObjectKeysRecursive(value, resolvedIndex, { arrayKeysIndexStyle });
  }
  __name(getDeepArrayKeysRecursive, "getDeepArrayKeysRecursive");
  function* getDeepObjectKeysRecursive(obj, prefix, { arrayKeysIndexStyle }) {
    if (typeof obj !== "object" || obj === null) {
      yield prefix;
      return;
    }
    if (Array.isArray(obj)) {
      for (const [index, value] of obj.entries()) {
        const resolvedPrefixedIndex = arrayKeysIndexStyle === "dotted" ? `${prefix}.${index}` : `${prefix}[${index}]`;
        yield* getDeepObjectKeysRecursive(value, resolvedPrefixedIndex, { arrayKeysIndexStyle });
      }
    } else {
      const objectEntries2 = Object.entries(obj);
      if (isNullOrUndefinedOrEmpty(objectEntries2) && prefix) {
        yield prefix;
      } else {
        for (const [key, value] of objectEntries2) {
          yield* getDeepObjectKeysRecursive(value, arrayKeysIndexStyle === "braces" ? `${prefix}${key}` : `${prefix}.${key}`, {
            arrayKeysIndexStyle
          });
        }
      }
    }
  }
  __name(getDeepObjectKeysRecursive, "getDeepObjectKeysRecursive");

  // src/lib/hasAtLeastOneKeyInMap.ts
  function hasAtLeastOneKeyInMap(map, keys) {
    return keys.some((key) => map.has(key));
  }
  __name(hasAtLeastOneKeyInMap, "hasAtLeastOneKeyInMap");

  // src/lib/inlineCodeBlock.ts
  var zws2 = String.fromCharCode(8203);
  function inlineCodeBlock(content) {
    content = content.replace(/ /g, "\xA0");
    content = content.replace(/`/g, `\`${zws2}`);
    return `\`${content}\``;
  }
  __name(inlineCodeBlock, "inlineCodeBlock");

  // src/lib/isClass.ts
  function isClass(input) {
    return typeof input === "function" && typeof input.prototype === "object";
  }
  __name(isClass, "isClass");

  // src/lib/isFunction.ts
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");

  // src/lib/isNumber.ts
  function isNumber(input) {
    if (typeof input === "string")
      input = Number(input);
    return typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input);
  }
  __name(isNumber, "isNumber");

  // src/lib/isObject.ts
  function isObject(input, constructorType) {
    return typeof input === "object" && input ? input.constructor === (constructorType != null ? constructorType : Object) : false;
  }
  __name(isObject, "isObject");

  // src/lib/isThenable.ts
  function hasThen(input) {
    return Reflect.has(input, "then") && isFunction(input.then);
  }
  __name(hasThen, "hasThen");
  function hasCatch(input) {
    return Reflect.has(input, "catch") && isFunction(input.catch);
  }
  __name(hasCatch, "hasCatch");
  function isThenable(input) {
    if (typeof input !== "object" || input === null)
      return false;
    return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);
  }
  __name(isThenable, "isThenable");

  // src/lib/lazy.ts
  function lazy(cb) {
    let defaultValue;
    return () => defaultValue != null ? defaultValue : defaultValue = cb();
  }
  __name(lazy, "lazy");

  // src/lib/makeObject.ts
  function makeObject(path, value, obj = {}) {
    if (path.includes(".")) {
      const route = path.split(".");
      const lastKey = route.pop();
      let reference = obj;
      for (const key of route) {
        if (!reference[key])
          reference[key] = {};
        reference = reference[key];
      }
      reference[lastKey] = value;
    } else {
      obj[path] = value;
    }
    return obj;
  }
  __name(makeObject, "makeObject");

  // src/lib/mergeDefault.ts
  function mergeDefault(base, overwrites) {
    if (!overwrites)
      return deepClone(base);
    for (const [baseKey, baseValue] of Object.entries(base)) {
      const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);
      if (typeof overwritesValueAtBaseKey === "undefined") {
        Reflect.set(overwrites, baseKey, deepClone(baseValue));
      } else if (isObject(overwritesValueAtBaseKey)) {
        Reflect.set(overwrites, baseKey, mergeDefault(baseValue != null ? baseValue : {}, overwritesValueAtBaseKey));
      }
    }
    return overwrites;
  }
  __name(mergeDefault, "mergeDefault");

  // src/lib/mergeObjects.ts
  function mergeObjects(objTarget, objSource) {
    for (const [key, value] of Object.entries(objSource)) {
      const targetValue = Reflect.get(objTarget, key);
      if (isObject(value)) {
        Reflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value) : value);
      } else if (!isObject(targetValue)) {
        Reflect.set(objTarget, key, value);
      }
    }
    return objTarget;
  }
  __name(mergeObjects, "mergeObjects");

  // src/lib/noop.ts
  function noop() {
  }
  __name(noop, "noop");

  // src/lib/objectEntries.ts
  function objectEntries(obj) {
    return Object.entries(obj);
  }
  __name(objectEntries, "objectEntries");

  // src/lib/objectKeys.ts
  function objectKeys(obj) {
    return Object.keys(obj);
  }
  __name(objectKeys, "objectKeys");

  // src/lib/objectToTuples.ts
  function objectToTuples(obj, prefix = "") {
    const entries = [];
    for (const [key, value] of Object.entries(obj)) {
      if (isObject(value)) {
        entries.push(...objectToTuples(value, `${prefix}${key}.`));
      } else {
        entries.push([`${prefix}${key}`, value]);
      }
    }
    return entries;
  }
  __name(objectToTuples, "objectToTuples");

  // src/lib/objectValues.ts
  function objectValues(obj) {
    return Object.values(obj);
  }
  __name(objectValues, "objectValues");

  // src/lib/omitKeysFromObject.ts
  function omitKeysFromObject(source, ...keys) {
    const clone = deepClone(source);
    for (const key of keys) {
      Reflect.deleteProperty(clone, key);
    }
    return clone;
  }
  __name(omitKeysFromObject, "omitKeysFromObject");

  // src/lib/partition.ts
  function partition(array, predicate) {
    if (!Array.isArray(array))
      throw new TypeError("entries must be an array.");
    if (!isFunction(predicate))
      throw new TypeError("predicate must be an function that returns a boolean value.");
    const partitionOne = [];
    const partitionTwo = [];
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        partitionOne.push(array[i]);
      } else {
        partitionTwo.push(array[i]);
      }
    }
    return [partitionOne, partitionTwo];
  }
  __name(partition, "partition");

  // src/lib/pickRandom.ts
  function pickRandom(array, amount = 1) {
    const arr = [...array];
    if (typeof amount === "undefined" || amount === 1) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    if (!arr.length || !amount) {
      return [];
    }
    return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
  }
  __name(pickRandom, "pickRandom");

  // src/lib/sleep.ts
  function sleep(ms, value, options) {
    return new Promise((resolve, reject) => {
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted) {
          reject(signal.reason);
          return;
        }
        signal.addEventListener("abort", () => {
          clearTimeout(timer);
          reject(signal.reason);
        });
      }
      const timer = setTimeout(() => resolve(value), ms);
      if ((options == null ? void 0 : options.ref) === false && typeof timer === "object") {
        timer.unref();
      }
    });
  }
  __name(sleep, "sleep");

  // src/lib/poll.ts
  async function poll(cb, cbCondition, options = {}) {
    var _a2, _b, _c;
    const signal = (_a2 = options.signal) != null ? _a2 : void 0;
    const maximumRetries = (_b = options.maximumRetries) != null ? _b : Infinity;
    if (typeof maximumRetries !== "number")
      throw new TypeError("Expected maximumRetries to be a number");
    if (!(maximumRetries >= 0))
      throw new RangeError("Expected maximumRetries to be a non-negative number");
    const waitBetweenRetries = (_c = options.waitBetweenRetries) != null ? _c : 0;
    if (typeof waitBetweenRetries !== "number")
      throw new TypeError("Expected waitBetweenRetries to be a number");
    if (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {
      throw new RangeError("Expected waitBetweenRetries to be a positive safe integer");
    }
    signal == null ? void 0 : signal.throwIfAborted();
    let result = await cb(signal);
    for (let retries = 0; retries < maximumRetries && !await cbCondition(result, signal); retries++) {
      signal == null ? void 0 : signal.throwIfAborted();
      if (waitBetweenRetries > 0) {
        if (options.verbose)
          console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);
        await sleep(waitBetweenRetries, void 0, { signal });
      }
      result = await cb(signal);
    }
    return result;
  }
  __name(poll, "poll");

  // src/lib/sleepSync.ts
  function sleepSync(ms, value) {
    return value;
  }
  __name(sleepSync, "sleepSync");

  // src/lib/pollSync.ts
  var _a;
  var DOMException = (_a = globalThis.DOMException) != null ? _a : (
    // DOMException was only made a global in Node v17.0.0, but this library supports Node v16.0.0 and up
    AbortSignal.abort().reason.constructor
  );
  function pollSync(cb, cbCondition, options = {}) {
    var _a2, _b, _c;
    const timeout = (_a2 = options.timeout) != null ? _a2 : Infinity;
    if (typeof timeout !== "number")
      throw new TypeError("Expected timeout to be a number");
    if (!(timeout >= 0))
      throw new RangeError("Expected timeout to be a non-negative number");
    const maximumRetries = (_b = options.maximumRetries) != null ? _b : Infinity;
    if (typeof maximumRetries !== "number")
      throw new TypeError("Expected maximumRetries to be a number");
    if (!(maximumRetries >= 0))
      throw new RangeError("Expected maximumRetries to be a non-negative number");
    const waitBetweenRetries = (_c = options.waitBetweenRetries) != null ? _c : 0;
    if (typeof waitBetweenRetries !== "number")
      throw new TypeError("Expected waitBetweenRetries to be a number");
    if (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {
      throw new RangeError("Expected waitBetweenRetries to be a positive safe integer");
    }
    const end = Date.now() + timeout;
    let result = cb();
    for (let retries = 0; retries < maximumRetries && !cbCondition(result); retries++) {
      if (Date.now() + waitBetweenRetries > end)
        throw new DOMException("This operation was aborted", "AbortError");
      if (waitBetweenRetries > 0) {
        if (options.verbose)
          console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);
      }
      result = cb();
    }
    return result;
  }
  __name(pollSync, "pollSync");

  // src/lib/range.ts
  function range(min, max, step) {
    return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
  }
  __name(range, "range");

  // src/lib/regExpEsc.ts
  var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
  function regExpEsc(str) {
    return str.replace(REGEXPESC, "\\$&");
  }
  __name(regExpEsc, "regExpEsc");

  // src/lib/retry.ts
  async function retry(cb, retries) {
    if (retries < 0)
      throw new RangeError("Expected retries to be a number >= 0");
    if (retries === 0)
      return cb();
    let lastError;
    for (let i = 0; i < retries; ++i) {
      try {
        return await cb();
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError;
  }
  __name(retry, "retry");

  // src/lib/retrySync.ts
  function retrySync(cb, retries) {
    if (retries < 0)
      throw new RangeError("Expected retries to be a number >= 0");
    if (retries === 0)
      return cb();
    let lastError;
    for (let i = 0; i < retries; ++i) {
      try {
        return cb();
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError;
  }
  __name(retrySync, "retrySync");

  // src/lib/roundNumber.ts
  function roundNumber(num, scale = 0) {
    if (!num.toString().includes("e")) {
      return Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);
    }
    const arr = `${num}`.split("e");
    let sig = "";
    if (Number(arr[1]) + scale > 0) {
      sig = "+";
    }
    return Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);
  }
  __name(roundNumber, "roundNumber");

  // src/lib/throttle.ts
  function throttle(func, wait) {
    let prev = 0;
    let prevValue;
    return Object.assign(
      (...args) => {
        const now = Date.now();
        if (now - prev > wait) {
          prev = now;
          return prevValue = func(...args);
        }
        return prevValue;
      },
      {
        flush() {
          prev = 0;
        }
      }
    );
  }
  __name(throttle, "throttle");

  // src/lib/toTitleCase.ts
  var TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\S*/g;
  var baseVariants = {
    textchannel: "TextChannel",
    voicechannel: "VoiceChannel",
    categorychannel: "CategoryChannel",
    guildmember: "GuildMember"
  };
  function toTitleCase(str, options = {}) {
    const { additionalVariants = {}, caseSensitive } = options;
    const titleCaseVariants = {
      ...baseVariants,
      ...caseSensitive ? additionalVariants : Object.entries(additionalVariants).reduce(
        (variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }),
        {}
      )
    };
    return str.replace(
      TO_TITLE_CASE,
      (txt) => {
        var _a2;
        return (_a2 = titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()]) != null ? _a2 : txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
      }
    );
  }
  __name(toTitleCase, "toTitleCase");

  // src/lib/tryParseJSON.ts
  function tryParseJSON(value, reviver) {
    try {
      return JSON.parse(value, reviver);
    } catch (err) {
      return value;
    }
  }
  __name(tryParseJSON, "tryParseJSON");

  // src/lib/tryParseURL.ts
  function tryParseURL(value) {
    try {
      return new URL(value);
    } catch {
      return null;
    }
  }
  __name(tryParseURL, "tryParseURL");
  /**
   * Split a string by its latest space character in a range from the character 0 to the selected one.
   * @param str The text to split.
   * @param length The length of the desired string.
   * @param char The character to split with
   * @copyright 2019 Aura Román
   * @license Apache-2.0
   */
  /**
   * Split a text by its latest space character in a range from the character 0 to the selected one.
   * @param str The text to split.
   * @param length The length of the desired string.
   * @copyright 2019 Aura Román
   * @license Apache-2.0
   */

  exports.arrayStrictEquals = arrayStrictEquals;
  exports.cast = cast;
  exports.chunk = chunk;
  exports.classExtends = classExtends;
  exports.codeBlock = codeBlock;
  exports.cutText = cutText;
  exports.debounce = debounce;
  exports.deepClone = deepClone;
  exports.filterNullAndUndefined = filterNullAndUndefined;
  exports.filterNullAndUndefinedAndEmpty = filterNullAndUndefinedAndEmpty;
  exports.filterNullAndUndefinedAndZero = filterNullAndUndefinedAndZero;
  exports.filterNullish = filterNullAndUndefined;
  exports.filterNullishAndEmpty = filterNullAndUndefinedAndEmpty;
  exports.filterNullishAndZero = filterNullAndUndefinedAndZero;
  exports.filterNullishOrEmpty = filterNullAndUndefinedAndEmpty;
  exports.filterNullishOrZero = filterNullAndUndefinedAndZero;
  exports.getDeepObjectKeys = getDeepObjectKeys;
  exports.hasAtLeastOneKeyInMap = hasAtLeastOneKeyInMap;
  exports.inlineCodeBlock = inlineCodeBlock;
  exports.isClass = isClass;
  exports.isFunction = isFunction;
  exports.isNullOrUndefined = isNullOrUndefined;
  exports.isNullOrUndefinedOrEmpty = isNullOrUndefinedOrEmpty;
  exports.isNullOrUndefinedOrZero = isNullOrUndefinedOrZero;
  exports.isNullish = isNullOrUndefined;
  exports.isNullishOrEmpty = isNullOrUndefinedOrEmpty;
  exports.isNullishOrZero = isNullOrUndefinedOrZero;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPrimitive = isPrimitive;
  exports.isThenable = isThenable;
  exports.lazy = lazy;
  exports.makeObject = makeObject;
  exports.mergeDefault = mergeDefault;
  exports.mergeObjects = mergeObjects;
  exports.noop = noop;
  exports.objectEntries = objectEntries;
  exports.objectKeys = objectKeys;
  exports.objectToTuples = objectToTuples;
  exports.objectValues = objectValues;
  exports.omitKeysFromObject = omitKeysFromObject;
  exports.parseURL = tryParseURL;
  exports.partition = partition;
  exports.pickRandom = pickRandom;
  exports.poll = poll;
  exports.pollSync = pollSync;
  exports.range = range;
  exports.regExpEsc = regExpEsc;
  exports.retry = retry;
  exports.retrySync = retrySync;
  exports.roundNumber = roundNumber;
  exports.sleep = sleep;
  exports.sleepSync = sleepSync;
  exports.splitText = splitText;
  exports.throttle = throttle;
  exports.toTitleCase = toTitleCase;
  exports.tryParse = tryParseJSON;
  exports.tryParseJSON = tryParseJSON;
  exports.tryParseURL = tryParseURL;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.global.js.map