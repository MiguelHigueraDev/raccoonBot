{"version":3,"sources":["../../src/lib/arrayStrictEquals.ts","../../src/lib/cast.ts","../../src/lib/chunk.ts","../../src/lib/classExtends.ts","../../src/lib/codeBlock.ts","../../src/lib/splitText.ts","../../src/lib/cutText.ts","../../src/lib/debounce/debounce.ts","../../src/lib/isPrimitive.ts","../../src/lib/deepClone.ts","../../src/lib/isNullOrUndefined.ts","../../src/lib/filterNullAndUndefined.ts","../../src/lib/isNullOrUndefinedOrEmpty.ts","../../src/lib/filterNullAndUndefinedAndEmpty.ts","../../src/lib/isNullOrUndefinedOrZero.ts","../../src/lib/filterNullAndUndefinedAndZero.ts","../../src/lib/getDeepObjectKeys.ts","../../src/lib/hasAtLeastOneKeyInMap.ts","../../src/lib/inlineCodeBlock.ts","../../src/lib/isClass.ts","../../src/lib/isFunction.ts","../../src/lib/isNumber.ts","../../src/lib/isObject.ts","../../src/lib/isThenable.ts","../../src/lib/lazy.ts","../../src/lib/makeObject.ts","../../src/lib/mergeDefault.ts","../../src/lib/mergeObjects.ts","../../src/lib/noop.ts","../../src/lib/objectEntries.ts","../../src/lib/objectKeys.ts","../../src/lib/objectToTuples.ts","../../src/lib/objectValues.ts","../../src/lib/omitKeysFromObject.ts","../../src/lib/partition.ts","../../src/lib/pickRandom.ts","../../src/lib/sleep.ts","../../src/lib/poll.ts","../../src/lib/sleepSync.ts","../../src/lib/pollSync.ts","../../src/lib/range.ts","../../src/lib/regExpEsc.ts","../../src/lib/retry.ts","../../src/lib/retrySync.ts","../../src/lib/roundNumber.ts","../../src/lib/throttle.ts","../../src/lib/toTitleCase.ts","../../src/lib/tryParseJSON.ts","../../src/lib/tryParseURL.ts"],"names":["_a","result","objectEntries","zws"],"mappings":"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","sourcesContent":["/**\n * Compare if both arrays are strictly equal\n * @param arr1 The array to compare to\n * @param arr2 The array to compare with\n */\nexport function arrayStrictEquals<T extends readonly unknown[]>(arr1: T, arr2: T): boolean {\n\tif (arr1 === arr2) return true;\n\tif (arr1.length !== arr2.length) return false;\n\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i]) return false;\n\t}\n\treturn true;\n}\n","/**\n * Casts any value to `T`\n *\n * Note that this function is not type-safe, and may cause runtime errors if used incorrectly.\n * Also note that this function is effectively useless in a JavaScript project, it only serves a purpose for TypeScript projects.\n *\n * @param value The value to cast to another type\n * @returns The value but as type `T`\n */\nexport function cast<T>(value: unknown): T {\n\treturn value as T;\n}\n","/**\n * Splits up an array into chunks\n * @param array The array to chunk up\n * @param chunkSize The size of each individual chunk\n */\nexport function chunk<T>(array: readonly T[], chunkSize: number): T[][] {\n\tif (!Array.isArray(array)) throw new TypeError('entries must be an array.');\n\tif (!Number.isInteger(chunkSize)) throw new TypeError('chunkSize must be an integer.');\n\tif (chunkSize < 1) throw new RangeError('chunkSize must be 1 or greater.');\n\tconst chunks: T[][] = [];\n\tfor (let i = 0; i < array.length; i += chunkSize) chunks.push(array.slice(i, i + chunkSize));\n\treturn chunks;\n}\n","import type { Ctor } from './types';\n\n/**\n * Checks whether or not the value class extends the base class.\n * @param value The constructor to be checked against.\n * @param base The base constructor.\n */\nexport function classExtends<T extends Ctor>(value: Ctor, base: T): value is T {\n\tlet ctor: Ctor | null = value;\n\twhile (ctor !== null) {\n\t\tif (ctor === base) return true;\n\t\tctor = Object.getPrototypeOf(ctor);\n\t}\n\n\treturn false;\n}\n","const zws = String.fromCharCode(8203);\n\n/**\n * Wraps the content inside a codeblock with no language\n *\n * @remark If the provided content includes 3 backticks (```) then those backticks will be escaped\n * by adding a [Zero Width Space](https://en.wikipedia.org/wiki/Zero-width_space) between the first and second backtick\n *\n * @remark If the provided content ends with a backtick then a [Zero Width Space](https://en.wikipedia.org/wiki/Zero-width_space) will be added\n * to the end of the content\n *\n * @param content - The content to wrap\n */\nexport function codeBlock<C extends string>(content: C): `\\`\\`\\`\\n${C}\\n\\`\\`\\``;\n\n/**\n * Wraps the content inside a codeblock with the specified language\n *\n * @remark If the provided content includes 3 backticks (```) then those backticks will be escaped\n * by adding a [Zero Width Space](https://en.wikipedia.org/wiki/Zero-width_space) between the first and second backtick\n *\n * @remark If the provided content ends with a backtick then a [Zero Width Space](https://en.wikipedia.org/wiki/Zero-width_space) will be added\n * to the end of the content\n *\n * @param language The codeblock language\n * @param content The expression to be wrapped in the codeblock\n */\nexport function codeBlock<L extends string, C extends string>(language: L, content: C): `\\`\\`\\`${L}\\n${C}\\n\\`\\`\\``;\nexport function codeBlock(...args: [string, string?]): string {\n\tconst [language, content] = args.length === 1 ? ['', args[0]] : args;\n\treturn `\\`\\`\\`${language}\\n${String(content).replace(/```/, `\\`${zws}\\`\\``).replace(/`$/g, `\\`${zws}`)}\\n\\`\\`\\``;\n}\n","/**\n * Split a string by its latest space character in a range from the character 0 to the selected one.\n * @param str The text to split.\n * @param length The length of the desired string.\n * @param char The character to split with\n * @copyright 2019 Aura Román\n * @license Apache-2.0\n */\nexport function splitText(str: string, length: number, char = ' ') {\n\tconst x = str.substring(0, length).lastIndexOf(char);\n\tconst pos = x === -1 ? length : x;\n\treturn str.substring(0, pos);\n}\n","import { splitText } from './splitText';\n\n/**\n * Split a text by its latest space character in a range from the character 0 to the selected one.\n * @param str The text to split.\n * @param length The length of the desired string.\n * @copyright 2019 Aura Román\n * @license Apache-2.0\n */\nexport function cutText(str: string, length: number) {\n\tif (str.length < length) return str;\n\tconst cut = splitText(str, length - 3);\n\tif (cut.length < length - 3) return `${cut}...`;\n\treturn `${cut.slice(0, length - 3)}...`;\n}\n","/**\n * lodash (Custom Build) https://lodash.com/\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors https://jquery.org/\n * Released under MIT license https://lodash.com/license\n * Based on Underscore.js 1.8.3 http://underscorejs.org/LICENSE\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\nexport interface DebounceSettings {\n\t/**\n\t * The number of milliseconds to delay.\n\t * @default 0\n\t */\n\twait?: number;\n\n\t/**\n\t * The maximum time `func` is allowed to be delayed before it's invoked\n\t * @default null\n\t */\n\tmaxWait?: number | null;\n}\n\nexport interface DebouncedFunc<FnArgumentsType extends any[], FnReturnType> {\n\t/**\n\t * Call the original function, but applying the debounce rules.\n\t *\n\t * If the debounced function can be run immediately, this calls it and returns its return\n\t * value.\n\t *\n\t * Otherwise, it returns the return value of the last invocation, or undefined if the debounced\n\t * function was not invoked yet.\n\t */\n\t(...args: FnArgumentsType): FnReturnType | undefined;\n\n\t/**\n\t * Throw away any pending invocation of the debounced function.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * If there is a pending invocation of the debounced function, invoke it immediately and return\n\t * its return value.\n\t *\n\t * Otherwise, return the value from the last invocation, or undefined if the debounced function\n\t * was never invoked.\n\t */\n\tflush(): FnReturnType | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\n * the last time the debounced function was invoked. The debounced function comes with a cancel method to\n * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\n * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\n * calls to the debounced function return the result of the last func invocation.\n *\n * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\n * if the the debounced function is invoked more than once during the wait timeout.\n *\n * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.\n *\n * @param func The function to debounce.\n * @param wait The number of milliseconds to delay.\n * @param options The options object.\n * @return Returns the new debounced function.\n */\nexport function debounce<FnArgumentsType extends any[], FnReturnType>(\n\tfunc: (...args: FnArgumentsType) => FnReturnType,\n\toptions: DebounceSettings = {}\n): DebouncedFunc<FnArgumentsType, FnReturnType> {\n\tlet lastArgs: FnArgumentsType | undefined;\n\tlet result: FnReturnType | undefined;\n\tlet timerId: NodeJS.Timeout | undefined;\n\tlet lastCallTime: number | undefined;\n\tlet lastInvokeTime = 0;\n\n\tconst wait = options.wait ?? 0;\n\tconst maxWait = typeof options.maxWait === 'number' ? Math.max(options.maxWait, wait) : null;\n\n\tfunction invokeFunc(time: number) {\n\t\tconst args = lastArgs;\n\n\t\tlastArgs = undefined;\n\t\tlastInvokeTime = time;\n\t\tresult = func(...args!);\n\t\treturn result;\n\t}\n\n\tfunction leadingEdge(time: number) {\n\t\t// Reset any `maxWait` timer.\n\t\tlastInvokeTime = time;\n\t\t// Start the timer for the trailing edge.\n\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t// Invoke the leading edge.\n\t\treturn result;\n\t}\n\n\tfunction remainingWait(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\t\tconst result = wait - timeSinceLastCall;\n\n\t\treturn maxWait === null ? result : Math.min(result, maxWait - timeSinceLastInvoke);\n\t}\n\n\tfunction shouldInvoke(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\n\t\t// Either this is the first call, activity has stopped and we're at the\n\t\t// trailing edge, the system time has gone backwards and we're treating\n\t\t// it as the trailing edge, or we've hit the `maxWait` limit.\n\t\treturn (\n\t\t\tlastCallTime === undefined || //\n\t\t\ttimeSinceLastCall >= wait ||\n\t\t\ttimeSinceLastCall < 0 ||\n\t\t\t(maxWait !== null && timeSinceLastInvoke >= maxWait)\n\t\t);\n\t}\n\n\tfunction timerExpired() {\n\t\tconst time = Date.now();\n\t\tif (shouldInvoke(time)) {\n\t\t\ttrailingEdge(time);\n\t\t\treturn;\n\t\t}\n\t\t// Restart the timer.\n\t\ttimerId = setTimeout(timerExpired, remainingWait(time));\n\t}\n\n\tfunction trailingEdge(time: number) {\n\t\ttimerId = undefined;\n\t\treturn invokeFunc(time);\n\t}\n\n\tfunction cancel() {\n\t\tif (timerId !== undefined) {\n\t\t\tclearTimeout(timerId);\n\t\t}\n\n\t\tlastInvokeTime = 0;\n\t\tlastArgs = undefined;\n\t\tlastCallTime = undefined;\n\t\ttimerId = undefined;\n\t}\n\n\tfunction flush() {\n\t\treturn timerId === undefined ? result : trailingEdge(Date.now());\n\t}\n\n\tfunction debounced(...args: FnArgumentsType) {\n\t\tconst time = Date.now();\n\t\tconst isInvoking = shouldInvoke(time);\n\n\t\tlastArgs = args;\n\t\tlastCallTime = time;\n\n\t\tif (isInvoking) {\n\t\t\tif (timerId === undefined) {\n\t\t\t\treturn leadingEdge(lastCallTime);\n\t\t\t}\n\t\t\tif (maxWait !== null) {\n\t\t\t\t// Handle invocations in a tight loop.\n\t\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t\t\treturn invokeFunc(lastCallTime);\n\t\t\t}\n\t\t}\n\n\t\tif (timerId === undefined) {\n\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tdebounced.cancel = cancel;\n\tdebounced.flush = flush;\n\n\treturn debounced;\n}\n","const primitiveTypes = ['string', 'bigint', 'number', 'boolean'];\n\n/**\n * Check whether a value is a primitive\n * @param input The input to check\n */\nexport function isPrimitive(input: unknown): input is string | bigint | number | boolean {\n\treturn primitiveTypes.includes(typeof input);\n}\n","import { isPrimitive } from './isPrimitive';\nimport type { Constructor } from './types';\n\n/**\n * A constant reference to the prototype of a `TypedArray` to avoid recomputing the expensive\n * `Object.getPrototypeOf` call.\n *\n * We can safely reference `NodeJS.TypedArray` while preserving browser compatibility,\n * because this is TypeScript-only code and this constant is also not included\n * in the `.d.ts` file as it is not exported.\n */\nconst TypedArrayPrototype = Object.getPrototypeOf(Uint8Array) as Constructor<NodeJS.TypedArray>;\n\n/**\n * Deep clone an object\n * @param source The object to clone\n */\nexport function deepClone<T>(source: T): T {\n\t// Check if it's a primitive (string, number, boolean, bigint)\n\tif (source === null || isPrimitive(source)) {\n\t\treturn source;\n\t}\n\n\tif (source instanceof Date) {\n\t\tconst output = new (source.constructor as DateConstructor)(source);\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof TypedArrayPrototype) {\n\t\tconst output = (source.constructor as Uint8ArrayConstructor).from(source as Uint8Array);\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (Array.isArray(source)) {\n\t\tconst output = new (source.constructor as ArrayConstructor)(source.length) as unknown as T & T extends (infer S)[] ? S[] : never;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\toutput[i] = deepClone(source[i]);\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof Map) {\n\t\tconst output = new (source.constructor as MapConstructor)() as unknown as T & T extends Map<infer K, infer V> ? Map<K, V> : never;\n\n\t\tfor (const [key, value] of source.entries()) {\n\t\t\toutput.set(key, deepClone(value));\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof Set) {\n\t\tconst output = new (source.constructor as SetConstructor)() as unknown as T & T extends Set<infer K> ? Set<K> : never;\n\n\t\tfor (const value of source.values()) {\n\t\t\toutput.add(deepClone(value));\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (typeof source === 'object') {\n\t\tconst output = new ((source as T & (object | Record<PropertyKey, unknown>)).constructor as ObjectConstructor)() as unknown as Record<\n\t\t\tPropertyKey,\n\t\t\tunknown\n\t\t>;\n\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tObject.defineProperty(output, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: deepClone(value),\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\treturn source;\n}\n","import type { Nullish } from './types';\n\n/**\n * Checks whether or not a value is `null` or `undefined`\n * @param value The value to check\n */\nexport function isNullOrUndefined(value: unknown): value is Nullish {\n\treturn value === undefined || value === null;\n}\n\nexport { isNullOrUndefined as isNullish };\n","import { isNullish } from './isNullOrUndefined';\nimport type { Nullish } from './types';\n\n/**\n * Checks whether a value is not `null` nor `undefined`.\n * This can be used in {@link Array.filter} to remove `null` and `undefined` from the array type\n * @param value The value to verify that is neither `null` nor `undefined`\n * @returns A boolean that is `true` if the value is neither `null` nor `undefined`, false otherwise.\n * @example\n * ```typescript\n * // TypeScript Type: (string | undefined | null)[]\n * const someArray = ['one', 'two', undefined, null, 'five'];\n *\n * // TypeScript Type: string[]\n * const filteredArray = someArray.filter(filterNullAndUndefined);\n * // Result: ['one', 'two', 'five']\n * ```\n */\nexport function filterNullAndUndefined<TValue>(value: TValue | Nullish): value is TValue {\n\treturn !isNullish(value);\n}\n\nexport { filterNullAndUndefined as filterNullish };\n","import { isNullish } from './isNullOrUndefined';\nimport type { Nullish } from './types';\n\n/**\n * Checks whether or not a value is `null`, `undefined` or `''`, `[]`\n * @param value The value to check\n */\nexport function isNullOrUndefinedOrEmpty(value: unknown): value is Nullish | '' {\n\treturn isNullish(value) || (value as string | unknown[]).length === 0;\n}\n\nexport { isNullOrUndefinedOrEmpty as isNullishOrEmpty };\n","import { isNullOrUndefinedOrEmpty } from './isNullOrUndefinedOrEmpty';\nimport type { Nullish } from './types';\n\n/**\n * Checks whether a value is not `null` nor `undefined` nor `''` (empty string).\n * This can be used in {@link Array.filter} to remove `null`, `undefined` from the array type\n * @param value The value to verify that is neither `null`, `undefined` nor `''` (empty string)\n * @returns A boolean that is `true` if the value is neither `null`, `undefined` nor `''` (empty string), false otherwise.\n * @example\n * ```typescript\n * // TypeScript Type: (string | undefined | null)[]\n * const someArray = ['one', 'two', undefined, null, ''];\n *\n * // TypeScript Type: string[]\n * const filteredArray = someArray.filter(filterNullAndUndefinedAndEmpty);\n * // Result: ['one', 'two']\n * ```\n */\nexport function filterNullAndUndefinedAndEmpty<TValue>(value: TValue | Nullish | ''): value is TValue {\n\treturn !isNullOrUndefinedOrEmpty(value);\n}\n\nexport { filterNullAndUndefinedAndEmpty as filterNullishAndEmpty };\n\nexport {\n\t/**\n\t * @deprecated Will be removed in the next major version, switch to either `filterNullishAndEmpty` or {@link filterNullAndUndefinedAndEmpty}.\n\t */\n\tfilterNullAndUndefinedAndEmpty as filterNullishOrEmpty\n};\n","import { isNullish } from './isNullOrUndefined';\nimport type { Nullish } from './types';\n\n/**\n * Checks whether or not a value is `null`, `undefined` or `0`\n * @param value The value to check\n */\nexport function isNullOrUndefinedOrZero(value: unknown): value is Nullish | 0 {\n\treturn value === 0 || isNullish(value);\n}\n\nexport { isNullOrUndefinedOrZero as isNullishOrZero };\n","import { isNullOrUndefinedOrZero } from './isNullOrUndefinedOrZero';\nimport type { Nullish } from './types';\n\n/**\n * Checks whether a value is not `null` nor `undefined` nor `0`.\n * This can be used in {@link Array.filter} to remove `null`, `undefined` from the array type\n * @param value The value to verify that is neither `null`, `undefined` nor `0`\n * @returns A boolean that is `true` if the value is neither `null`, `undefined` nor `0`, false otherwise.\n * @example\n * ```typescript\n * // TypeScript Type: (string | number | undefined | null)[]\n * const someArray = ['one', 'two', undefined, null, 0, 1];\n *\n * // TypeScript Type: (string | number)[]\n * const filteredArray = someArray.filter(filterNullAndUndefinedAndZero);\n * // Result: ['one', 'two', 1]\n * ```\n */\nexport function filterNullAndUndefinedAndZero<TValue>(value: TValue | Nullish | 0): value is TValue {\n\treturn !isNullOrUndefinedOrZero(value);\n}\n\nexport { filterNullAndUndefinedAndZero as filterNullishAndZero };\n\nexport {\n\t/**\n\t * @deprecated Will be removed in the next major version, switch to either `filterNullishAndZero` or {@link filterNullAndUndefinedAndZero}.\n\t */\n\tfilterNullAndUndefinedAndZero as filterNullishOrZero\n};\n","import { isNullOrUndefinedOrEmpty } from './isNullOrUndefinedOrEmpty';\nimport type { AnyObject } from './types';\n\n/**\n * Flattens an object to a list of its keys, traversing deeply into nested objects and arrays of objects.\n *\n * @note By default Nested array values are flattened to `arrayKey.${index}.subKey`.\n * This can be changed to `arrayKey[${index}].subKey` by setting `options.arrayKeysIndexStyle` to `'braces-with-dot'`.\n * Or it can also be changed to `arrayKey[${index}]subKey` by setting `options.arrayKeysIndexStyle` to `'braces'`.\n *\n * @param obj The object of which to deeply retrieve its keys\n * @param options The options with which to customize the output of this function\n * @returns An array of strings holding the keys of the object\n */\nexport function getDeepObjectKeys<T>(obj: AnyObject<T>, options?: GetDeepObjectKeysOptions): string[] {\n\treturn [...getDeepObjectKeysGenerator(obj, options)];\n}\n\nfunction* getDeepObjectKeysGenerator<T>(\n\tobj: AnyObject<T>,\n\t{ arrayKeysIndexStyle = 'dotted' }: GetDeepObjectKeysOptions = { arrayKeysIndexStyle: 'dotted' }\n): Generator<string> {\n\tif (Array.isArray(obj)) {\n\t\tfor (const [index, value] of obj.entries()) {\n\t\t\tyield* getDeepArrayKeysRecursive(value, index, { arrayKeysIndexStyle });\n\t\t}\n\t} else {\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tyield* getDeepObjectKeysRecursive(value, `${key}`, { arrayKeysIndexStyle });\n\t\t}\n\t}\n}\n\nfunction* getDeepArrayKeysRecursive(value: unknown, index: number, { arrayKeysIndexStyle }: GetDeepObjectKeysOptions): Generator<string> {\n\tconst resolvedIndex = arrayKeysIndexStyle === 'dotted' ? `${index}` : arrayKeysIndexStyle === 'braces' ? `[${index}]` : `[${index}].`;\n\tyield* getDeepObjectKeysRecursive(value, resolvedIndex, { arrayKeysIndexStyle });\n}\n\nfunction* getDeepObjectKeysRecursive(obj: unknown, prefix: string, { arrayKeysIndexStyle }: GetDeepObjectKeysOptions): Generator<string> {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\tyield prefix;\n\t\treturn;\n\t}\n\n\tif (Array.isArray(obj)) {\n\t\tfor (const [index, value] of obj.entries()) {\n\t\t\tconst resolvedPrefixedIndex = arrayKeysIndexStyle === 'dotted' ? `${prefix}.${index}` : `${prefix}[${index}]`;\n\n\t\t\tyield* getDeepObjectKeysRecursive(value, resolvedPrefixedIndex, { arrayKeysIndexStyle });\n\t\t}\n\t} else {\n\t\tconst objectEntries = Object.entries(obj);\n\t\tif (isNullOrUndefinedOrEmpty(objectEntries) && prefix) {\n\t\t\tyield prefix;\n\t\t} else {\n\t\t\tfor (const [key, value] of objectEntries) {\n\t\t\t\tyield* getDeepObjectKeysRecursive(value, arrayKeysIndexStyle === 'braces' ? `${prefix}${key}` : `${prefix}.${key}`, {\n\t\t\t\t\tarrayKeysIndexStyle\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The options for {@link getDeepObjectKeys}\n */\nexport interface GetDeepObjectKeysOptions {\n\t/**\n\t * Whether to use `.${index}.` (`'dotted'`), `[${index}].`, (`'braces-with-dot'`) or `[${index}]` (`'braces'`) to separate array keys\n\t * @default 'dotted'\n\t */\n\tarrayKeysIndexStyle?: 'dotted' | 'braces-with-dot' | 'braces';\n}\n","/**\n * Checks whether any of the {@link keys} are in the {@link map}\n * @param map The map to check\n * @param keys The keys to find in the map\n * @returns `true` if at least one of the {@link keys} is in the {@link map}, `false` otherwise.\n */\nexport function hasAtLeastOneKeyInMap<T>(map: ReadonlyMap<T, any>, keys: readonly T[]): boolean {\n\treturn keys.some((key) => map.has(key));\n}\n","const zws = String.fromCharCode(8203);\n\n/**\n * Wraps text in a markdown inline codeblock\n * @param content The expression to be wrapped in the codeblock\n */\nexport function inlineCodeBlock<C extends string>(content: C): `\\`${C}\\`` {\n\t// Replace spaces with non-breaking spaces\n\tcontent = content.replace(/ /g, '\\u00A0') as C;\n\n\t// Replace backticks with zero-width-space escaped backticks\n\tcontent = content.replace(/`/g, `\\`${zws}`) as C;\n\n\t// Return the input wrapped in backticks\n\treturn `\\`${content}\\``;\n}\n","import type { Ctor } from './types';\n\n/**\n * Verify if the input is a class constructor.\n * @param input The function to verify\n */\nexport function isClass(input: unknown): input is Ctor {\n\treturn typeof input === 'function' && typeof input.prototype === 'object';\n}\n","/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(input: unknown): input is Function {\n\treturn typeof input === 'function';\n}\n","/**\n * Verify if a number is a finite number.\n * @param input The number to verify\n */\nexport function isNumber(input: unknown): input is number {\n\tif (typeof input === 'string') input = Number(input);\n\treturn typeof input === 'number' && !Number.isNaN(input) && Number.isFinite(input);\n}\n","import type { Constructor, NonNullObject } from './types';\n\n/**\n * Verify if the input is an object literal (or class).\n * @param input The object to verify\n * @param constructorType The type of the constructor of the object. Use this if you want a `class` of your choosing to pass the check as well.\n */\nexport function isObject(input: unknown, constructorType?: ObjectConstructor): input is NonNullObject;\nexport function isObject<T extends Constructor<unknown>>(input: unknown, constructorType: T): input is InstanceType<T>;\nexport function isObject<T extends Constructor<unknown> = ObjectConstructor>(input: unknown, constructorType?: T): input is NonNullObject {\n\treturn typeof input === 'object' && input ? input.constructor === (constructorType ?? Object) : false;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport { isFunction } from './isFunction';\n\nexport interface Thenable {\n\tthen: Function;\n\tcatch: Function;\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n\treturn Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n\treturn Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n\tif (typeof input !== 'object' || input === null) return false;\n\treturn input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n","/**\n * Lazily creates a constant or load a module and caches it internally\n * @param cb The callback to lazily run\n * @returns The value returned by the callback, or the cached value if it was already initialised once.\n */\nexport function lazy<T>(cb: () => T) {\n\tlet defaultValue: T;\n\n\treturn () => (defaultValue ??= cb());\n}\n","/**\n * Turn a dotted path into a json object.\n * @param path The dotted path\n * @param value The value\n * @param obj The object to edit\n */\nexport function makeObject(path: string, value: unknown, obj: Record<string, unknown> = {}): Record<string, unknown> {\n\tif (path.includes('.')) {\n\t\tconst route = path.split('.');\n\t\tconst lastKey = route.pop() as string;\n\t\tlet reference = obj;\n\t\tfor (const key of route) {\n\t\t\tif (!reference[key]) reference[key] = {};\n\t\t\treference = reference[key] as Record<string, unknown>;\n\t\t}\n\t\treference[lastKey] = value;\n\t} else {\n\t\tobj[path] = value;\n\t}\n\treturn obj;\n}\n","import { deepClone } from './deepClone';\nimport { isObject } from './isObject';\nimport type { DeepRequired, NonNullObject } from './types';\n\n/**\n * Deep merges 2 objects. Properties from the second parameter are applied to the first.\n * @remark `overwrites` is also mutated!\n * @remark If the value of a key in `overwrites` is `undefined` then the value of that same key in `base` is used instead!\n * @remark This is essentially `{ ...base, ...overwrites }` but recursively\n * @param base Base object\n * @param overwrites Overwrites to apply\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = {}; // will be { a: 0, b: 1 } after merge\n * mergeDefault(base, overwrites) // { a: 0, b: 1 }\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: 2, i: 3 };\n * mergeDefault(base, overwrites) // { a: 2, i: 3, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: null };\n * mergeDefault(base, overwrites) // { a: null, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: undefined };\n * mergeDefault(base, overwrites) // { a: 0, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: null };\n * const overwrites = { a: { b: 5 } };\n * mergeDefault(base, overwrites) // { a: { b: 5 } };\n * ```\n */\nexport function mergeDefault<A extends NonNullObject, B extends Partial<A>>(base: A, overwrites?: B): DeepRequired<A & B> {\n\t// If no overwrites are specified then deep clone the base\n\tif (!overwrites) return deepClone(base) as DeepRequired<A & B>;\n\n\tfor (const [baseKey, baseValue] of Object.entries(base)) {\n\t\tconst overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);\n\n\t\tif (typeof overwritesValueAtBaseKey === 'undefined') {\n\t\t\tReflect.set(overwrites, baseKey, deepClone(baseValue));\n\t\t} else if (isObject(overwritesValueAtBaseKey)) {\n\t\t\tReflect.set(overwrites, baseKey, mergeDefault((baseValue ?? {}) as NonNullObject, overwritesValueAtBaseKey));\n\t\t}\n\t}\n\n\treturn overwrites as DeepRequired<A & B>;\n}\n","import { isObject } from './isObject';\n\n/**\n * Merges two objects\n * @param objTarget The object to be merged\n * @param objSource The object to merge\n */\nexport function mergeObjects<A extends object, B extends object>(objTarget: A, objSource: Readonly<B>): A & B {\n\tfor (const [key, value] of Object.entries(objSource)) {\n\t\tconst targetValue = Reflect.get(objTarget, key);\n\t\tif (isObject(value)) {\n\t\t\tReflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value as object) : value);\n\t\t} else if (!isObject(targetValue)) {\n\t\t\tReflect.set(objTarget, key, value);\n\t\t}\n\t}\n\n\treturn objTarget as A & B;\n}\n","// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n","import type { NonNullObject } from './types';\n\nexport function objectEntries<T extends NonNullObject>(obj: T): T extends ArrayLike<any> ? [`${number}`, T[number]][] : [keyof T, T[keyof T]][] {\n\treturn Object.entries(obj) as T extends ArrayLike<infer Values> ? Values[] : [keyof T, T[keyof T]][];\n}\n","import type { NonNullObject } from './types';\n\nexport function objectKeys<T extends NonNullObject>(obj: T): T extends ArrayLike<any> ? `${number}`[] : (keyof T)[] {\n\treturn Object.keys(obj) as T extends ArrayLike<infer Values> ? Values[] : (keyof T)[];\n}\n","import { isObject } from './isObject';\nimport type { AnyObject } from './types';\n\n/**\n * Convert an object to a tuple\n * @param obj The object to convert\n * @param prefix The prefix for the key\n */\nexport function objectToTuples<T>(obj: AnyObject<T>, prefix = ''): [keyof T, T[keyof T]][] {\n\tconst entries: [keyof T, T[keyof T]][] = [];\n\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tif (isObject(value)) {\n\t\t\tentries.push(...objectToTuples(value, `${prefix}${key}.`));\n\t\t} else {\n\t\t\tentries.push([`${prefix}${key}` as keyof T, value as T[keyof T]]);\n\t\t}\n\t}\n\n\treturn entries;\n}\n","import type { NonNullObject } from './types';\n\nexport function objectValues<T extends NonNullObject>(obj: T): T extends ArrayLike<any> ? T[number][] : T[keyof T][] {\n\treturn Object.values(obj) as T extends ArrayLike<infer Values> ? Values[] : T[keyof T][];\n}\n","import { deepClone } from './deepClone';\n\n/**\n * Clones the source object using {@link deepClone} then deletes the specified keys with {@link Reflect.deleteProperty}\n *\n * @template Object - The object type.\n * @template ObjectKeys - The keys of the object type.\n *\n * @param source - The input object.\n * @param keys - The keys to omit from the object.\n * @returns A new object without the specified keys.\n */\nexport function omitKeysFromObject<Object extends object, ObjectKeys extends keyof Object>(\n\tsource: Object,\n\t...keys: readonly ObjectKeys[]\n): Omit<Object, ObjectKeys> {\n\tconst clone = deepClone(source);\n\n\tfor (const key of keys) {\n\t\tReflect.deleteProperty(clone, key);\n\t}\n\n\treturn clone;\n}\n","import { isFunction } from './isFunction';\n\n/**\n * Partitions `array` into a tuple of two arrays,\n * where one array contains all elements that satisfies `predicate`,\n * and the other contains all elements that do not satisfy `predicate`.\n * @param array The array to partition. This array is not mutated.\n * @param predicate The predicate function to determine in which partition the item should be placed.\n * The function should return true for items that should be placed in the first partition, and false for those that should be placed in the second partition.\n * @returns A tuple of two arrays.\n */\nexport function partition<T>(array: T[], predicate: (value: T, index: number) => boolean) {\n\tif (!Array.isArray(array)) throw new TypeError('entries must be an array.');\n\tif (!isFunction(predicate)) throw new TypeError('predicate must be an function that returns a boolean value.');\n\n\tconst partitionOne: T[] = [];\n\tconst partitionTwo: T[] = [];\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (predicate(array[i], i)) {\n\t\t\tpartitionOne.push(array[i]);\n\t\t} else {\n\t\t\tpartitionTwo.push(array[i]);\n\t\t}\n\t}\n\n\treturn [partitionOne, partitionTwo];\n}\n","/**\n * Picks a random element from an array\n * @param array The array to pick a random element from\n * @param amount Amount of values to obtain randomly (default: 1)\n */\nexport function pickRandom<T>(array: readonly T[], amount?: 1): T;\nexport function pickRandom<T>(array: readonly T[], amount: number): T[];\nexport function pickRandom<T>(array: readonly T[], amount = 1): T | T[] {\n\tconst arr = [...array];\n\n\tif (typeof amount === 'undefined' || amount === 1) {\n\t\treturn arr[Math.floor(Math.random() * arr.length)];\n\t}\n\n\tif (!arr.length || !amount) {\n\t\treturn [];\n\t}\n\n\treturn Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);\n}\n","export interface SleepOptions {\n\t/**\n\t * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * Set to `false` to indicate that the scheduled `Timeout`\n\t * should not require the Node.js event loop to remain active.\n\t * @default true\n\t */\n\tref?: boolean | undefined;\n}\n\n/**\n * Sleeps for the specified number of milliseconds.\n * For a synchronous variant, see [sleepSync](./sleepSync.d.ts).\n * @param ms The number of milliseconds to sleep.\n * @param value A value with which the promise is fulfilled.\n * @see {@link sleepSync} for a synchronous version.\n */\nexport function sleep<T = undefined>(ms: number, value?: T, options?: SleepOptions): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst signal = options?.signal;\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(signal.reason);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\treject(signal.reason);\n\t\t\t});\n\t\t}\n\n\t\tconst timer: NodeJS.Timeout | number = setTimeout(() => resolve(value!), ms);\n\t\tif (options?.ref === false && typeof timer === 'object') {\n\t\t\ttimer.unref();\n\t\t}\n\t});\n}\n","import { sleep } from './sleep';\nimport type { Awaitable } from './types';\n\n/** The options for the {@link poll} function */\nexport interface PollOptions {\n\t/**\n\t * An optional AbortSignal to abort the polling.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * The amount of attempts to try, if any.\n\t * @default Infinite\n\t */\n\tmaximumRetries?: number | null | undefined;\n\n\t/**\n\t * The amount of time to wait between each poll.\n\t * @default 0\n\t */\n\twaitBetweenRetries?: number | null | undefined;\n\n\t/**\n\t * Whether to log to the console on each polling interval, allowing the tracing of the amount of required attempts.\n\t * @default false\n\t */\n\tverbose?: boolean | undefined;\n}\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For a synchronous variant, see [pollSync](./pollSync.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `cb` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport async function poll<T>(\n\tcb: (signal: AbortSignal | undefined) => Awaitable<T>,\n\tcbCondition: (value: Awaited<T>, signal: AbortSignal | undefined) => Awaitable<boolean>,\n\toptions: PollOptions = {}\n): Promise<Awaitable<T>> {\n\tconst signal = options.signal ?? undefined;\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tsignal?.throwIfAborted();\n\tlet result = await cb(signal);\n\tfor (let retries = 0; retries < maximumRetries && !(await cbCondition(result, signal)); retries++) {\n\t\tsignal?.throwIfAborted();\n\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tawait sleep(waitBetweenRetries, undefined, { signal });\n\t\t}\n\n\t\tresult = await cb(signal);\n\t}\n\n\treturn result;\n}\n","/**\n * Sleeps for the specified number of milliseconds synchronously.\n * We should probably note that unlike {@link sleep} (which uses CPU tick times),\n * sleepSync uses wall clock times, so the precision is near-absolute by comparison.\n * That, and that synchronous means that nothing else in the thread will run for the length of the timer.\n *\n * For an asynchronous variant, see [sleep](./sleep.d.ts).\n * @param ms The number of milliseconds to sleep.\n * @param value A value to return.\n * @see {@link sleep} for an asynchronous version.\n */\nexport function sleepSync<T = undefined>(ms: number, value?: T): T {\n\tconst end = Date.now() + ms;\n\twhile (Date.now() < end) continue;\n\treturn value!;\n}\n","import type { PollOptions } from './poll';\nimport { sleepSync } from './sleepSync';\n\n/** The options for the {@link pollSync} function */\nexport interface SyncPollOptions extends Omit<PollOptions, 'signal'> {\n\t/**\n\t * The amount of milliseconds before throwing an AbortError.\n\t * @default Infinite\n\t */\n\ttimeout?: number | null | undefined;\n}\n\nconst DOMException: typeof globalThis.DOMException =\n\tglobalThis.DOMException ??\n\t// DOMException was only made a global in Node v17.0.0, but this library supports Node v16.0.0 and up\n\tAbortSignal.abort().reason.constructor;\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For an asynchronous variant, see [poll](./poll.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `fn` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport function pollSync<T>(cb: () => T, cbCondition: (value: T) => boolean, options: SyncPollOptions = {}): T {\n\tconst timeout = options.timeout ?? Infinity;\n\tif (typeof timeout !== 'number') throw new TypeError('Expected timeout to be a number');\n\tif (!(timeout >= 0)) throw new RangeError('Expected timeout to be a non-negative number');\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tconst end = Date.now() + timeout;\n\tlet result = cb();\n\tfor (let retries = 0; retries < maximumRetries && !cbCondition(result); retries++) {\n\t\tif (Date.now() + waitBetweenRetries > end) throw new DOMException('This operation was aborted', 'AbortError');\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tsleepSync(waitBetweenRetries);\n\t\t}\n\n\t\tresult = cb();\n\t}\n\n\treturn result;\n}\n","/**\n * Get an array of numbers with the selected range\n * @param min The minimum value\n * @param max The maximum value\n * @param step The step value\n */\nexport function range(min: number, max: number, step: number): number[] {\n\treturn new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);\n}\n","const REGEXPESC = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\n/**\n * Cleans a string from regex injection\n * @param str The string to clean\n */\nexport function regExpEsc(str: string): string {\n\treturn str.replace(REGEXPESC, '\\\\$&');\n}\n","import type { Awaitable } from './types';\n\n/**\n * Asynchronously calls the callback function until it either succeeds or it runs out of retries.\n * For a synchronous variant, see [retrySync](./retrySync.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport async function retry<T>(cb: () => Awaitable<T>, retries: number): Promise<T> {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn await cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n","/**\n * Synchronously calls the callback function until it either succeeds or it runs out of retries.\n * For an asynchronous variant, see [retry](./retry.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport function retrySync<T>(cb: () => T, retries: number): T {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n","/**\n * Properly rounds up or down a number.\n * Also supports strings using an exponent to indicate large or small numbers.\n * @param num The number to round off\n * @param scale The amount of decimals to retain\n */\nexport function roundNumber(num: number | string, scale = 0) {\n\tif (!num.toString().includes('e')) {\n\t\treturn Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);\n\t}\n\tconst arr = `${num}`.split('e');\n\tlet sig = '';\n\n\tif (Number(arr[1]) + scale > 0) {\n\t\tsig = '+';\n\t}\n\n\treturn Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);\n}\n","export type ThrottleFn<T extends (...args: any[]) => any> = T & { flush: () => void };\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `flush` method to\n * reset the last time the throttled function was invoked.\n *\n * @param func The function to throttle.\n * @param wait The number of milliseconds to throttle invocations to.\n *\n * @returns Returns the new throttled function.\n */\nexport function throttle<T extends (...args: any[]) => any>(func: T, wait: number): ThrottleFn<T> {\n\tlet prev = 0;\n\tlet prevValue: ReturnType<T>;\n\n\treturn Object.assign(\n\t\t(...args: Parameters<T>) => {\n\t\t\tconst now = Date.now();\n\t\t\tif (now - prev > wait) {\n\t\t\t\tprev = now;\n\t\t\t\treturn (prevValue = func(...args));\n\t\t\t}\n\n\t\t\treturn prevValue;\n\t\t},\n\t\t{\n\t\t\tflush() {\n\t\t\t\tprev = 0;\n\t\t\t}\n\t\t}\n\t) as ThrottleFn<T>;\n}\n","const TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\\S*/g;\n\n/**\n * The variants that will not strictly follow the `toTitleCase` algorithm\n * and will instead return the value matched with the key.\n *\n * This table lists how certain terms are converted.\n * Any terms not included are converted to regular `Titlecase`.\n * |       Term       |   Converted To   |\n * |:---------------- |:---------------- |\n * | textchannel      | TextChannel      |\n * | voicechannel     | VoiceChannel     |\n * | categorychannel  | CategoryChannel  |\n * | guildmember      | GuildMember      |\n */\nexport const baseVariants: Record<string, string> = {\n\ttextchannel: 'TextChannel',\n\tvoicechannel: 'VoiceChannel',\n\tcategorychannel: 'CategoryChannel',\n\tguildmember: 'GuildMember'\n};\n\n/**\n * Converts a string to Title Case\n *\n * @description This is designed to also ensure common Discord PascalCased strings\n * are put in their TitleCase {@link baseVariants}.\n *\n * You can also provide your own variants to merge with the {@link baseVariants} for\n * your own functionality use.\n *\n * @param str The string to title case\n * @param options The options to use when converting the string\n */\nexport function toTitleCase(str: string, options: ToTitleCaseOptions = {}): string {\n\tconst { additionalVariants = {}, caseSensitive } = options;\n\tconst titleCaseVariants = {\n\t\t...baseVariants,\n\t\t...(caseSensitive\n\t\t\t? additionalVariants\n\t\t\t: Object.entries(additionalVariants).reduce<Record<string, string>>(\n\t\t\t\t\t(variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }),\n\t\t\t\t\t{}\n\t\t\t\t))\n\t};\n\n\treturn str.replace(\n\t\tTO_TITLE_CASE,\n\t\t(txt) => titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()] ?? txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase()\n\t);\n}\n\n/**\n * The options to use when converting a string to title case\n */\nexport interface ToTitleCaseOptions {\n\t/**\n\t * The optional additional variants to use when converting the string\n\t */\n\tadditionalVariants?: Record<string, string>;\n\n\t/**\n\t * Whether to convert the string to title case in a case sensitive manner.\n\t */\n\tcaseSensitive?: boolean;\n}\n","/**\n * Try parse a stringified JSON string.\n * @param value The string to parse as JSON.\n * @param reviver A function that transforms the results. This function is recursively called for each member of the object.\n */\nexport function tryParseJSON(\n\tvalue: string,\n\treviver?: (this: object, key: string, value: unknown) => unknown\n): object | string | number | boolean | null {\n\ttry {\n\t\treturn JSON.parse(value, reviver);\n\t} catch (err) {\n\t\treturn value;\n\t}\n}\n\nexport {\n\t/**\n\t * @deprecated Will be removed in the next major version, switch to {@link tryParseJSON}.\n\t */\n\ttryParseJSON as tryParse\n};\n","/**\n * Tries parse a string to a {@link URL} object\n * @param value The possible URL to parse\n * @returns an URL object if it was a valid URL or `null` if it was not.\n */\nexport function tryParseURL(value: string): URL | null {\n\ttry {\n\t\treturn new URL(value);\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport {\n\t/**\n\t * @deprecated Will be removed in the next major version, switch to {@link tryParseURL}.\n\t */\n\ttryParseURL as parseURL\n};\n"]}