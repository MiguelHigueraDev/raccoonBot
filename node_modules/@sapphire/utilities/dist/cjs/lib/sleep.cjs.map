{"version":3,"sources":["../../../src/lib/sleep.ts"],"names":[],"mappings":";;;;AAqBO,SAAS,MAAqB,IAAY,OAAW,SAAoC;AAC/F,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,UAAM,SAAS,mCAAS;AACxB,QAAI,QAAQ;AACX,UAAI,OAAO,SAAS;AACnB,eAAO,OAAO,MAAM;AACpB;AAAA,MACD;AAEA,aAAO,iBAAiB,SAAS,MAAM;AACtC,qBAAa,KAAK;AAClB,eAAO,OAAO,MAAM;AAAA,MACrB,CAAC;AAAA,IACF;AAEA,UAAM,QAAiC,WAAW,MAAM,QAAQ,KAAM,GAAG,EAAE;AAC3E,SAAI,mCAAS,SAAQ,SAAS,OAAO,UAAU,UAAU;AACxD,YAAM,MAAM;AAAA,IACb;AAAA,EACD,CAAC;AACF;AApBgB","sourcesContent":["export interface SleepOptions {\n\t/**\n\t * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * Set to `false` to indicate that the scheduled `Timeout`\n\t * should not require the Node.js event loop to remain active.\n\t * @default true\n\t */\n\tref?: boolean | undefined;\n}\n\n/**\n * Sleeps for the specified number of milliseconds.\n * For a synchronous variant, see [sleepSync](./sleepSync.d.ts).\n * @param ms The number of milliseconds to sleep.\n * @param value A value with which the promise is fulfilled.\n * @see {@link sleepSync} for a synchronous version.\n */\nexport function sleep<T = undefined>(ms: number, value?: T, options?: SleepOptions): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst signal = options?.signal;\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(signal.reason);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\treject(signal.reason);\n\t\t\t});\n\t\t}\n\n\t\tconst timer: NodeJS.Timeout | number = setTimeout(() => resolve(value!), ms);\n\t\tif (options?.ref === false && typeof timer === 'object') {\n\t\t\ttimer.unref();\n\t\t}\n\t});\n}\n"]}