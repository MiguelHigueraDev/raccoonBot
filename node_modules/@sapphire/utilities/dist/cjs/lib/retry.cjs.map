{"version":3,"sources":["../../../src/lib/retry.ts"],"names":[],"mappings":";;;;AASA,eAAsB,MAAS,IAAwB,SAA6B;AACnF,MAAI,UAAU;AAAG,UAAM,IAAI,WAAW,sCAAsC;AAC5E,MAAI,YAAY;AAAG,WAAO,GAAG;AAE7B,MAAI;AACJ,WAAS,IAAI,GAAG,IAAI,SAAS,EAAE,GAAG;AACjC,QAAI;AACH,aAAO,MAAM,GAAG;AAAA,IACjB,SAAS,OAAO;AACf,kBAAY;AAAA,IACb;AAAA,EACD;AAEA,QAAM;AACP;AAdsB","sourcesContent":["import type { Awaitable } from './types';\n\n/**\n * Asynchronously calls the callback function until it either succeeds or it runs out of retries.\n * For a synchronous variant, see [retrySync](./retrySync.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport async function retry<T>(cb: () => Awaitable<T>, retries: number): Promise<T> {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn await cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n"]}