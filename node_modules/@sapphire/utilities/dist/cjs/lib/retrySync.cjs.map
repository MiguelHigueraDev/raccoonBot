{"version":3,"sources":["../../../src/lib/retrySync.ts"],"names":[],"mappings":";;;;AAOO,SAAS,UAAa,IAAa,SAAoB;AAC7D,MAAI,UAAU;AAAG,UAAM,IAAI,WAAW,sCAAsC;AAC5E,MAAI,YAAY;AAAG,WAAO,GAAG;AAE7B,MAAI;AACJ,WAAS,IAAI,GAAG,IAAI,SAAS,EAAE,GAAG;AACjC,QAAI;AACH,aAAO,GAAG;AAAA,IACX,SAAS,OAAO;AACf,kBAAY;AAAA,IACb;AAAA,EACD;AAEA,QAAM;AACP;AAdgB","sourcesContent":["/**\n * Synchronously calls the callback function until it either succeeds or it runs out of retries.\n * For an asynchronous variant, see [retry](./retry.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport function retrySync<T>(cb: () => T, retries: number): T {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n"]}