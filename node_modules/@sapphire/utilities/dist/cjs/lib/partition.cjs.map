{"version":3,"sources":["../../../src/lib/partition.ts"],"names":[],"mappings":";;;;AAAA,SAAS,kBAAkB;AAWpB,SAAS,UAAa,OAAY,WAAiD;AACzF,MAAI,CAAC,MAAM,QAAQ,KAAK;AAAG,UAAM,IAAI,UAAU,2BAA2B;AAC1E,MAAI,CAAC,WAAW,SAAS;AAAG,UAAM,IAAI,UAAU,6DAA6D;AAE7G,QAAM,eAAoB,CAAC;AAC3B,QAAM,eAAoB,CAAC;AAE3B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,QAAI,UAAU,MAAM,CAAC,GAAG,CAAC,GAAG;AAC3B,mBAAa,KAAK,MAAM,CAAC,CAAC;AAAA,IAC3B,OAAO;AACN,mBAAa,KAAK,MAAM,CAAC,CAAC;AAAA,IAC3B;AAAA,EACD;AAEA,SAAO,CAAC,cAAc,YAAY;AACnC;AAhBgB","sourcesContent":["import { isFunction } from './isFunction';\n\n/**\n * Partitions `array` into a tuple of two arrays,\n * where one array contains all elements that satisfies `predicate`,\n * and the other contains all elements that do not satisfy `predicate`.\n * @param array The array to partition. This array is not mutated.\n * @param predicate The predicate function to determine in which partition the item should be placed.\n * The function should return true for items that should be placed in the first partition, and false for those that should be placed in the second partition.\n * @returns A tuple of two arrays.\n */\nexport function partition<T>(array: T[], predicate: (value: T, index: number) => boolean) {\n\tif (!Array.isArray(array)) throw new TypeError('entries must be an array.');\n\tif (!isFunction(predicate)) throw new TypeError('predicate must be an function that returns a boolean value.');\n\n\tconst partitionOne: T[] = [];\n\tconst partitionTwo: T[] = [];\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (predicate(array[i], i)) {\n\t\t\tpartitionOne.push(array[i]);\n\t\t} else {\n\t\t\tpartitionTwo.push(array[i]);\n\t\t}\n\t}\n\n\treturn [partitionOne, partitionTwo];\n}\n"]}