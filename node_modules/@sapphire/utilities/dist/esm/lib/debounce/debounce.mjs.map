{"version":3,"sources":["../../../../src/lib/debounce/debounce.ts"],"names":["result"],"mappings":";;;;;AAmEO,SAAS,SACf,MACA,UAA4B,CAAC,GACkB;AAtEhD;AAuEC,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,iBAAiB;AAErB,QAAM,QAAO,aAAQ,SAAR,YAAgB;AAC7B,QAAM,UAAU,OAAO,QAAQ,YAAY,WAAW,KAAK,IAAI,QAAQ,SAAS,IAAI,IAAI;AAExF,WAAS,WAAW,MAAc;AACjC,UAAM,OAAO;AAEb,eAAW;AACX,qBAAiB;AACjB,aAAS,KAAK,GAAG,IAAK;AACtB,WAAO;AAAA,EACR;AAPS;AAST,WAAS,YAAY,MAAc;AAElC,qBAAiB;AAEjB,cAAU,WAAW,cAAc,IAAI;AAEvC,WAAO;AAAA,EACR;AAPS;AAST,WAAS,cAAc,MAAc;AACpC,UAAM,oBAAoB,OAAO;AACjC,UAAM,sBAAsB,OAAO;AACnC,UAAMA,UAAS,OAAO;AAEtB,WAAO,YAAY,OAAOA,UAAS,KAAK,IAAIA,SAAQ,UAAU,mBAAmB;AAAA,EAClF;AANS;AAQT,WAAS,aAAa,MAAc;AACnC,UAAM,oBAAoB,OAAO;AACjC,UAAM,sBAAsB,OAAO;AAKnC,WACC,iBAAiB;AAAA,IACjB,qBAAqB,QACrB,oBAAoB,KACnB,YAAY,QAAQ,uBAAuB;AAAA,EAE9C;AAbS;AAeT,WAAS,eAAe;AACvB,UAAM,OAAO,KAAK,IAAI;AACtB,QAAI,aAAa,IAAI,GAAG;AACvB,mBAAa,IAAI;AACjB;AAAA,IACD;AAEA,cAAU,WAAW,cAAc,cAAc,IAAI,CAAC;AAAA,EACvD;AARS;AAUT,WAAS,aAAa,MAAc;AACnC,cAAU;AACV,WAAO,WAAW,IAAI;AAAA,EACvB;AAHS;AAKT,WAAS,SAAS;AACjB,QAAI,YAAY,QAAW;AAC1B,mBAAa,OAAO;AAAA,IACrB;AAEA,qBAAiB;AACjB,eAAW;AACX,mBAAe;AACf,cAAU;AAAA,EACX;AATS;AAWT,WAAS,QAAQ;AAChB,WAAO,YAAY,SAAY,SAAS,aAAa,KAAK,IAAI,CAAC;AAAA,EAChE;AAFS;AAIT,WAAS,aAAa,MAAuB;AAC5C,UAAM,OAAO,KAAK,IAAI;AACtB,UAAM,aAAa,aAAa,IAAI;AAEpC,eAAW;AACX,mBAAe;AAEf,QAAI,YAAY;AACf,UAAI,YAAY,QAAW;AAC1B,eAAO,YAAY,YAAY;AAAA,MAChC;AACA,UAAI,YAAY,MAAM;AAErB,kBAAU,WAAW,cAAc,IAAI;AACvC,eAAO,WAAW,YAAY;AAAA,MAC/B;AAAA,IACD;AAEA,QAAI,YAAY,QAAW;AAC1B,gBAAU,WAAW,cAAc,IAAI;AAAA,IACxC;AAEA,WAAO;AAAA,EACR;AAvBS;AAyBT,YAAU,SAAS;AACnB,YAAU,QAAQ;AAElB,SAAO;AACR;AAjHgB","sourcesContent":["/**\n * lodash (Custom Build) https://lodash.com/\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors https://jquery.org/\n * Released under MIT license https://lodash.com/license\n * Based on Underscore.js 1.8.3 http://underscorejs.org/LICENSE\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\nexport interface DebounceSettings {\n\t/**\n\t * The number of milliseconds to delay.\n\t * @default 0\n\t */\n\twait?: number;\n\n\t/**\n\t * The maximum time `func` is allowed to be delayed before it's invoked\n\t * @default null\n\t */\n\tmaxWait?: number | null;\n}\n\nexport interface DebouncedFunc<FnArgumentsType extends any[], FnReturnType> {\n\t/**\n\t * Call the original function, but applying the debounce rules.\n\t *\n\t * If the debounced function can be run immediately, this calls it and returns its return\n\t * value.\n\t *\n\t * Otherwise, it returns the return value of the last invocation, or undefined if the debounced\n\t * function was not invoked yet.\n\t */\n\t(...args: FnArgumentsType): FnReturnType | undefined;\n\n\t/**\n\t * Throw away any pending invocation of the debounced function.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * If there is a pending invocation of the debounced function, invoke it immediately and return\n\t * its return value.\n\t *\n\t * Otherwise, return the value from the last invocation, or undefined if the debounced function\n\t * was never invoked.\n\t */\n\tflush(): FnReturnType | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\n * the last time the debounced function was invoked. The debounced function comes with a cancel method to\n * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\n * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\n * calls to the debounced function return the result of the last func invocation.\n *\n * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\n * if the the debounced function is invoked more than once during the wait timeout.\n *\n * See David Corbachoâ€™s article for details over the differences between _.debounce and _.throttle.\n *\n * @param func The function to debounce.\n * @param wait The number of milliseconds to delay.\n * @param options The options object.\n * @return Returns the new debounced function.\n */\nexport function debounce<FnArgumentsType extends any[], FnReturnType>(\n\tfunc: (...args: FnArgumentsType) => FnReturnType,\n\toptions: DebounceSettings = {}\n): DebouncedFunc<FnArgumentsType, FnReturnType> {\n\tlet lastArgs: FnArgumentsType | undefined;\n\tlet result: FnReturnType | undefined;\n\tlet timerId: NodeJS.Timeout | undefined;\n\tlet lastCallTime: number | undefined;\n\tlet lastInvokeTime = 0;\n\n\tconst wait = options.wait ?? 0;\n\tconst maxWait = typeof options.maxWait === 'number' ? Math.max(options.maxWait, wait) : null;\n\n\tfunction invokeFunc(time: number) {\n\t\tconst args = lastArgs;\n\n\t\tlastArgs = undefined;\n\t\tlastInvokeTime = time;\n\t\tresult = func(...args!);\n\t\treturn result;\n\t}\n\n\tfunction leadingEdge(time: number) {\n\t\t// Reset any `maxWait` timer.\n\t\tlastInvokeTime = time;\n\t\t// Start the timer for the trailing edge.\n\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t// Invoke the leading edge.\n\t\treturn result;\n\t}\n\n\tfunction remainingWait(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\t\tconst result = wait - timeSinceLastCall;\n\n\t\treturn maxWait === null ? result : Math.min(result, maxWait - timeSinceLastInvoke);\n\t}\n\n\tfunction shouldInvoke(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\n\t\t// Either this is the first call, activity has stopped and we're at the\n\t\t// trailing edge, the system time has gone backwards and we're treating\n\t\t// it as the trailing edge, or we've hit the `maxWait` limit.\n\t\treturn (\n\t\t\tlastCallTime === undefined || //\n\t\t\ttimeSinceLastCall >= wait ||\n\t\t\ttimeSinceLastCall < 0 ||\n\t\t\t(maxWait !== null && timeSinceLastInvoke >= maxWait)\n\t\t);\n\t}\n\n\tfunction timerExpired() {\n\t\tconst time = Date.now();\n\t\tif (shouldInvoke(time)) {\n\t\t\ttrailingEdge(time);\n\t\t\treturn;\n\t\t}\n\t\t// Restart the timer.\n\t\ttimerId = setTimeout(timerExpired, remainingWait(time));\n\t}\n\n\tfunction trailingEdge(time: number) {\n\t\ttimerId = undefined;\n\t\treturn invokeFunc(time);\n\t}\n\n\tfunction cancel() {\n\t\tif (timerId !== undefined) {\n\t\t\tclearTimeout(timerId);\n\t\t}\n\n\t\tlastInvokeTime = 0;\n\t\tlastArgs = undefined;\n\t\tlastCallTime = undefined;\n\t\ttimerId = undefined;\n\t}\n\n\tfunction flush() {\n\t\treturn timerId === undefined ? result : trailingEdge(Date.now());\n\t}\n\n\tfunction debounced(...args: FnArgumentsType) {\n\t\tconst time = Date.now();\n\t\tconst isInvoking = shouldInvoke(time);\n\n\t\tlastArgs = args;\n\t\tlastCallTime = time;\n\n\t\tif (isInvoking) {\n\t\t\tif (timerId === undefined) {\n\t\t\t\treturn leadingEdge(lastCallTime);\n\t\t\t}\n\t\t\tif (maxWait !== null) {\n\t\t\t\t// Handle invocations in a tight loop.\n\t\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t\t\treturn invokeFunc(lastCallTime);\n\t\t\t}\n\t\t}\n\n\t\tif (timerId === undefined) {\n\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tdebounced.cancel = cancel;\n\tdebounced.flush = flush;\n\n\treturn debounced;\n}\n"]}