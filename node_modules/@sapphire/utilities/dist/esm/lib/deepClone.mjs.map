{"version":3,"sources":["../../../src/lib/deepClone.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,mBAAmB;AAW5B,IAAM,sBAAsB,OAAO,eAAe,UAAU;AAMrD,SAAS,UAAa,QAAc;AAE1C,MAAI,WAAW,QAAQ,YAAY,MAAM,GAAG;AAC3C,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,MAAM;AAC3B,UAAM,SAAS,IAAK,OAAO,YAAgC,MAAM;AAEjE,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,qBAAqB;AAC1C,UAAM,SAAU,OAAO,YAAsC,KAAK,MAAoB;AAEtF,WAAO;AAAA,EACR;AAEA,MAAI,MAAM,QAAQ,MAAM,GAAG;AAC1B,UAAM,SAAS,IAAK,OAAO,YAAiC,OAAO,MAAM;AAEzE,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,aAAO,CAAC,IAAI,UAAU,OAAO,CAAC,CAAC;AAAA,IAChC;AAEA,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,KAAK;AAC1B,UAAM,SAAS,IAAK,OAAO,YAA+B;AAE1D,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG;AAC5C,aAAO,IAAI,KAAK,UAAU,KAAK,CAAC;AAAA,IACjC;AAEA,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,KAAK;AAC1B,UAAM,SAAS,IAAK,OAAO,YAA+B;AAE1D,eAAW,SAAS,OAAO,OAAO,GAAG;AACpC,aAAO,IAAI,UAAU,KAAK,CAAC;AAAA,IAC5B;AAEA,WAAO;AAAA,EACR;AAEA,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,SAAS,IAAM,OAAuD,YAAkC;AAK9G,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAClD,aAAO,eAAe,QAAQ,KAAK;AAAA,QAClC,cAAc;AAAA,QACd,YAAY;AAAA,QACZ,OAAO,UAAU,KAAK;AAAA,QACtB,UAAU;AAAA,MACX,CAAC;AAAA,IACF;AAEA,WAAO;AAAA,EACR;AAEA,SAAO;AACR;AAnEgB","sourcesContent":["import { isPrimitive } from './isPrimitive';\nimport type { Constructor } from './types';\n\n/**\n * A constant reference to the prototype of a `TypedArray` to avoid recomputing the expensive\n * `Object.getPrototypeOf` call.\n *\n * We can safely reference `NodeJS.TypedArray` while preserving browser compatibility,\n * because this is TypeScript-only code and this constant is also not included\n * in the `.d.ts` file as it is not exported.\n */\nconst TypedArrayPrototype = Object.getPrototypeOf(Uint8Array) as Constructor<NodeJS.TypedArray>;\n\n/**\n * Deep clone an object\n * @param source The object to clone\n */\nexport function deepClone<T>(source: T): T {\n\t// Check if it's a primitive (string, number, boolean, bigint)\n\tif (source === null || isPrimitive(source)) {\n\t\treturn source;\n\t}\n\n\tif (source instanceof Date) {\n\t\tconst output = new (source.constructor as DateConstructor)(source);\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof TypedArrayPrototype) {\n\t\tconst output = (source.constructor as Uint8ArrayConstructor).from(source as Uint8Array);\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (Array.isArray(source)) {\n\t\tconst output = new (source.constructor as ArrayConstructor)(source.length) as unknown as T & T extends (infer S)[] ? S[] : never;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\toutput[i] = deepClone(source[i]);\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof Map) {\n\t\tconst output = new (source.constructor as MapConstructor)() as unknown as T & T extends Map<infer K, infer V> ? Map<K, V> : never;\n\n\t\tfor (const [key, value] of source.entries()) {\n\t\t\toutput.set(key, deepClone(value));\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (source instanceof Set) {\n\t\tconst output = new (source.constructor as SetConstructor)() as unknown as T & T extends Set<infer K> ? Set<K> : never;\n\n\t\tfor (const value of source.values()) {\n\t\t\toutput.add(deepClone(value));\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\tif (typeof source === 'object') {\n\t\tconst output = new ((source as T & (object | Record<PropertyKey, unknown>)).constructor as ObjectConstructor)() as unknown as Record<\n\t\t\tPropertyKey,\n\t\t\tunknown\n\t\t>;\n\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tObject.defineProperty(output, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: deepClone(value),\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\n\t\treturn output as unknown as T;\n\t}\n\n\treturn source;\n}\n"]}