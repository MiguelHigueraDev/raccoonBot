{"version":3,"sources":["../../../src/lib/poll.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,aAAa;AAwCtB,eAAsB,KACrB,IACA,aACA,UAAuB,CAAC,GACA;AA5CzB;AA6CC,QAAM,UAAS,aAAQ,WAAR,YAAkB;AAEjC,QAAM,kBAAiB,aAAQ,mBAAR,YAA0B;AACjD,MAAI,OAAO,mBAAmB;AAAU,UAAM,IAAI,UAAU,wCAAwC;AACpG,MAAI,EAAE,kBAAkB;AAAI,UAAM,IAAI,WAAW,qDAAqD;AAEtG,QAAM,sBAAqB,aAAQ,uBAAR,YAA8B;AACzD,MAAI,OAAO,uBAAuB;AAAU,UAAM,IAAI,UAAU,4CAA4C;AAC5G,MAAI,CAAC,OAAO,cAAc,kBAAkB,KAAK,qBAAqB,GAAG;AACxE,UAAM,IAAI,WAAW,2DAA2D;AAAA,EACjF;AAEA,mCAAQ;AACR,MAAI,SAAS,MAAM,GAAG,MAAM;AAC5B,WAAS,UAAU,GAAG,UAAU,kBAAkB,CAAE,MAAM,YAAY,QAAQ,MAAM,GAAI,WAAW;AAClG,qCAAQ;AAER,QAAI,qBAAqB,GAAG;AAC3B,UAAI,QAAQ;AAAS,gBAAQ,IAAI,WAAW,kBAAkB,4BAA4B;AAC1F,YAAM,MAAM,oBAAoB,QAAW,EAAE,OAAO,CAAC;AAAA,IACtD;AAEA,aAAS,MAAM,GAAG,MAAM;AAAA,EACzB;AAEA,SAAO;AACR;AA/BsB","sourcesContent":["import { sleep } from './sleep';\nimport type { Awaitable } from './types';\n\n/** The options for the {@link poll} function */\nexport interface PollOptions {\n\t/**\n\t * An optional AbortSignal to abort the polling.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * The amount of attempts to try, if any.\n\t * @default Infinite\n\t */\n\tmaximumRetries?: number | null | undefined;\n\n\t/**\n\t * The amount of time to wait between each poll.\n\t * @default 0\n\t */\n\twaitBetweenRetries?: number | null | undefined;\n\n\t/**\n\t * Whether to log to the console on each polling interval, allowing the tracing of the amount of required attempts.\n\t * @default false\n\t */\n\tverbose?: boolean | undefined;\n}\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For a synchronous variant, see [pollSync](./pollSync.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `cb` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport async function poll<T>(\n\tcb: (signal: AbortSignal | undefined) => Awaitable<T>,\n\tcbCondition: (value: Awaited<T>, signal: AbortSignal | undefined) => Awaitable<boolean>,\n\toptions: PollOptions = {}\n): Promise<Awaitable<T>> {\n\tconst signal = options.signal ?? undefined;\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tsignal?.throwIfAborted();\n\tlet result = await cb(signal);\n\tfor (let retries = 0; retries < maximumRetries && !(await cbCondition(result, signal)); retries++) {\n\t\tsignal?.throwIfAborted();\n\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tawait sleep(waitBetweenRetries, undefined, { signal });\n\t\t}\n\n\t\tresult = await cb(signal);\n\t}\n\n\treturn result;\n}\n"]}