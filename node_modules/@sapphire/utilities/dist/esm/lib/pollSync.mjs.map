{"version":3,"sources":["../../../src/lib/pollSync.ts"],"names":["_a"],"mappings":";;;;;AACA,SAAS,iBAAiB;AAD1B;AAYA,IAAM,gBACL,gBAAW,iBAAX;AAAA;AAAA,EAEA,YAAY,MAAM,EAAE,OAAO;AAAA;AAarB,SAAS,SAAY,IAAa,aAAoC,UAA2B,CAAC,GAAM;AA5B/G,MAAAA,KAAA;AA6BC,QAAM,WAAUA,MAAA,QAAQ,YAAR,OAAAA,MAAmB;AACnC,MAAI,OAAO,YAAY;AAAU,UAAM,IAAI,UAAU,iCAAiC;AACtF,MAAI,EAAE,WAAW;AAAI,UAAM,IAAI,WAAW,8CAA8C;AAExF,QAAM,kBAAiB,aAAQ,mBAAR,YAA0B;AACjD,MAAI,OAAO,mBAAmB;AAAU,UAAM,IAAI,UAAU,wCAAwC;AACpG,MAAI,EAAE,kBAAkB;AAAI,UAAM,IAAI,WAAW,qDAAqD;AAEtG,QAAM,sBAAqB,aAAQ,uBAAR,YAA8B;AACzD,MAAI,OAAO,uBAAuB;AAAU,UAAM,IAAI,UAAU,4CAA4C;AAC5G,MAAI,CAAC,OAAO,cAAc,kBAAkB,KAAK,qBAAqB,GAAG;AACxE,UAAM,IAAI,WAAW,2DAA2D;AAAA,EACjF;AAEA,QAAM,MAAM,KAAK,IAAI,IAAI;AACzB,MAAI,SAAS,GAAG;AAChB,WAAS,UAAU,GAAG,UAAU,kBAAkB,CAAC,YAAY,MAAM,GAAG,WAAW;AAClF,QAAI,KAAK,IAAI,IAAI,qBAAqB;AAAK,YAAM,IAAI,aAAa,8BAA8B,YAAY;AAC5G,QAAI,qBAAqB,GAAG;AAC3B,UAAI,QAAQ;AAAS,gBAAQ,IAAI,WAAW,kBAAkB,4BAA4B;AAC1F,gBAAU,kBAAkB;AAAA,IAC7B;AAEA,aAAS,GAAG;AAAA,EACb;AAEA,SAAO;AACR;AA5BgB","sourcesContent":["import type { PollOptions } from './poll';\nimport { sleepSync } from './sleepSync';\n\n/** The options for the {@link pollSync} function */\nexport interface SyncPollOptions extends Omit<PollOptions, 'signal'> {\n\t/**\n\t * The amount of milliseconds before throwing an AbortError.\n\t * @default Infinite\n\t */\n\ttimeout?: number | null | undefined;\n}\n\nconst DOMException: typeof globalThis.DOMException =\n\tglobalThis.DOMException ??\n\t// DOMException was only made a global in Node v17.0.0, but this library supports Node v16.0.0 and up\n\tAbortSignal.abort().reason.constructor;\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For an asynchronous variant, see [poll](./poll.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `fn` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport function pollSync<T>(cb: () => T, cbCondition: (value: T) => boolean, options: SyncPollOptions = {}): T {\n\tconst timeout = options.timeout ?? Infinity;\n\tif (typeof timeout !== 'number') throw new TypeError('Expected timeout to be a number');\n\tif (!(timeout >= 0)) throw new RangeError('Expected timeout to be a non-negative number');\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tconst end = Date.now() + timeout;\n\tlet result = cb();\n\tfor (let retries = 0; retries < maximumRetries && !cbCondition(result); retries++) {\n\t\tif (Date.now() + waitBetweenRetries > end) throw new DOMException('This operation was aborted', 'AbortError');\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tsleepSync(waitBetweenRetries);\n\t\t}\n\n\t\tresult = cb();\n\t}\n\n\treturn result;\n}\n"]}