var SapphireLexure = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../result/dist/esm/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");
  __name2(isFunction, "isFunction");
  var _a;
  var _ResultError = (_a = class extends Error {
    constructor(message, value) {
      super(message);
      __publicField2(this, "value");
      this.value = value;
    }
    get name() {
      return this.constructor.name;
    }
  }, __name(_a, "_ResultError"), _a);
  __name2(_ResultError, "ResultError");
  var ResultError = _ResultError;
  var _a2;
  var _ResultOk = (_a2 = class {
    constructor(value) {
      __publicField2(this, "value");
      this.value = value;
    }
    isOk() {
      return true;
    }
    isOkAnd(cb) {
      return cb(this.value);
    }
    isErr() {
      return false;
    }
    isErrAnd() {
      return false;
    }
    ok() {
      return createSome(this.value);
    }
    err() {
      return createNone;
    }
    map(cb) {
      return createOk(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapErr() {
      return this;
    }
    mapErrInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    inspectErr() {
      return this;
    }
    inspectErrAsync() {
      return Promise.resolve(this);
    }
    *iter() {
      yield this.value;
    }
    expect() {
      return this.value;
    }
    expectErr(message) {
      throw new ResultError(message, this.value);
    }
    unwrap() {
      return this.value;
    }
    unwrapErr() {
      throw new ResultError("Unwrap failed", this.value);
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    unwrapRaw() {
      return this.value;
    }
    and(result) {
      return result;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    contains(value) {
      return this.value === value;
    }
    containsErr() {
      return false;
    }
    transpose() {
      return this.value.match({
        some: (value) => createSome(createOk(value)),
        none: () => createNone
      });
    }
    flatten() {
      return this.value;
    }
    intoOkOrErr() {
      return this.value;
    }
    async intoPromise() {
      return createOk(await this.value);
    }
    eq(other) {
      return other.isOkAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.ok(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  }, __name(_a2, "_ResultOk"), _a2);
  __name2(_ResultOk, "ResultOk");
  var ResultOk = _ResultOk;
  function createOk(x) {
    return new ResultOk(x);
  }
  __name(createOk, "createOk");
  __name2(createOk, "createOk");
  var _a3;
  var _OptionSome = (_a3 = class {
    constructor(value) {
      __publicField2(this, "value");
      this.value = value;
    }
    isSome() {
      return true;
    }
    isSomeAnd(cb) {
      return cb(this.value);
    }
    isNone() {
      return false;
    }
    expect() {
      return this.value;
    }
    unwrap() {
      return this.value;
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    map(cb) {
      return createSome(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapNoneInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    okOr() {
      return createOk(this.value);
    }
    okOrElse() {
      return createOk(this.value);
    }
    *iter() {
      yield this.value;
    }
    and(option) {
      return option;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    xor(option) {
      return option.isSome() ? createNone : this;
    }
    filter(predicate) {
      return predicate(this.value) ? this : createNone;
    }
    contains(value) {
      return this.value === value;
    }
    zip(other) {
      return other.map((o) => [this.value, o]);
    }
    zipWith(other, f) {
      return other.map((o) => f(this.value, o));
    }
    unzip() {
      const [s, o] = this.value;
      return [createSome(s), createSome(o)];
    }
    transpose() {
      return this.value.match({
        ok: (v) => createOk(createSome(v)),
        err: (e) => createErr(e)
      });
    }
    flatten() {
      return this.value;
    }
    async intoPromise() {
      return createSome(await this.value);
    }
    eq(other) {
      return other.isSomeAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.some(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  }, __name(_a3, "_OptionSome"), _a3);
  __name2(_OptionSome, "OptionSome");
  var OptionSome = _OptionSome;
  function createSome(value) {
    return new OptionSome(value);
  }
  __name(createSome, "createSome");
  __name2(createSome, "createSome");
  var _a4;
  var _ResultErr = (_a4 = class {
    constructor(error) {
      __publicField2(this, "error");
      this.error = error;
    }
    isOk() {
      return false;
    }
    isOkAnd() {
      return false;
    }
    isErr() {
      return true;
    }
    isErrAnd(cb) {
      return cb(this.error);
    }
    ok() {
      return createNone;
    }
    err() {
      return createSome(this.error);
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(op) {
      return op(this.error);
    }
    mapErr(cb) {
      return createErr(cb(this.error));
    }
    mapErrInto(cb) {
      return cb(this.error);
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    inspectErr(cb) {
      cb(this.error);
      return this;
    }
    async inspectErrAsync(cb) {
      await cb(this.error);
      return this;
    }
    *iter() {
    }
    expect(message) {
      throw new ResultError(message, this.error);
    }
    expectErr() {
      return this.error;
    }
    unwrap() {
      throw new ResultError("Unwrap failed", this.error);
    }
    unwrapErr() {
      return this.error;
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(op) {
      return op(this.error);
    }
    unwrapRaw() {
      throw this.error;
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(result) {
      return result;
    }
    orElse(cb) {
      return cb(this.error);
    }
    contains() {
      return false;
    }
    containsErr(error) {
      return this.error === error;
    }
    transpose() {
      return createSome(this);
    }
    flatten() {
      return this;
    }
    intoOkOrErr() {
      return this.error;
    }
    async intoPromise() {
      return createErr(await this.error);
    }
    eq(other) {
      return other.isErrAnd((error) => this.error === error);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.err(this.error);
    }
    *[Symbol.iterator]() {
    }
  }, __name(_a4, "_ResultErr"), _a4);
  __name2(_ResultErr, "ResultErr");
  var ResultErr = _ResultErr;
  function createErr(x) {
    return new ResultErr(x);
  }
  __name(createErr, "createErr");
  __name2(createErr, "createErr");
  var _a5;
  var _OptionError = (_a5 = class extends Error {
    get name() {
      return this.constructor.name;
    }
  }, __name(_a5, "_OptionError"), _a5);
  __name2(_OptionError, "OptionError");
  var OptionError = _OptionError;
  var _a6;
  var _OptionNone = (_a6 = class {
    isSome() {
      return false;
    }
    isSomeAnd() {
      return false;
    }
    isNone() {
      return true;
    }
    expect(message) {
      throw new OptionError(message);
    }
    unwrap() {
      throw new OptionError("Unwrap failed");
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(cb) {
      return cb();
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(defaultValue) {
      return defaultValue();
    }
    mapNoneInto(cb) {
      return cb();
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    okOr(error) {
      return createErr(error);
    }
    okOrElse(cb) {
      return createErr(cb());
    }
    *iter() {
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(option) {
      return option;
    }
    orElse(cb) {
      return cb();
    }
    xor(option) {
      return option.isSome() ? option : this;
    }
    filter() {
      return this;
    }
    contains() {
      return false;
    }
    zip() {
      return this;
    }
    zipWith() {
      return this;
    }
    unzip() {
      return [this, this];
    }
    transpose() {
      return createOk(this);
    }
    flatten() {
      return this;
    }
    intoPromise() {
      return Promise.resolve(createNone);
    }
    eq(other) {
      return other.isNone();
    }
    ne(other) {
      return other.isSome();
    }
    match(branches) {
      return branches.none();
    }
    *[Symbol.iterator]() {
    }
  }, __name(_a6, "_OptionNone"), _a6);
  __name2(_OptionNone, "OptionNone");
  var OptionNone = _OptionNone;
  var createNone = new OptionNone();
  var Option;
  ((Option2) => {
    function resolve(value) {
      if (value === null || value === void 0)
        return Option2.none;
      if (is(value))
        return value;
      return (0, Option2.some)(value);
    }
    __name(resolve, "resolve");
    __name2(resolve, "resolve");
    function is(value) {
      return value instanceof OptionNone || value instanceof OptionSome;
    }
    __name(is, "is");
    Option2.is = is;
    __name2(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch {
        return Option2.none;
      }
    }
    __name(from, "from");
    Option2.from = from;
    __name2(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch {
        return Option2.none;
      }
    }
    __name(fromAsync, "fromAsync");
    Option2.fromAsync = fromAsync;
    __name2(fromAsync, "fromAsync");
    function all(options) {
      const values = [];
      for (const option of options) {
        if (option.isNone()) {
          return option;
        }
        values.push(option.unwrap());
      }
      return (0, Option2.some)(values);
    }
    __name(all, "all");
    Option2.all = all;
    __name2(all, "all");
    function any(options) {
      for (const result of options) {
        if (result.isSome()) {
          return result;
        }
      }
      return Option2.none;
    }
    __name(any, "any");
    Option2.any = any;
    __name2(any, "any");
    Option2.none = createNone;
    Option2.some = createSome;
  })(Option || (Option = {}));
  var Result;
  ((Result2) => {
    function resolve(value) {
      if (is(value))
        return value;
      return (0, Result2.ok)(value);
    }
    __name(resolve, "resolve");
    __name2(resolve, "resolve");
    function is(value) {
      return value instanceof ResultOk || value instanceof ResultErr;
    }
    __name(is, "is");
    Result2.is = is;
    __name2(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch (error) {
        return (0, Result2.err)(error);
      }
    }
    __name(from, "from");
    Result2.from = from;
    __name2(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch (error) {
        return (0, Result2.err)(error);
      }
    }
    __name(fromAsync, "fromAsync");
    Result2.fromAsync = fromAsync;
    __name2(fromAsync, "fromAsync");
    function all(results) {
      const values = [];
      for (const result of results) {
        if (result.isErr()) {
          return result;
        }
        values.push(result.unwrap());
      }
      return (0, Result2.ok)(values);
    }
    __name(all, "all");
    Result2.all = all;
    __name2(all, "all");
    function any(results) {
      const errors = [];
      for (const result of results) {
        if (result.isOk()) {
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return (0, Result2.err)(errors);
    }
    __name(any, "any");
    Result2.any = any;
    __name2(any, "any");
    Result2.err = createErr;
    Result2.ok = createOk;
  })(Result || (Result = {}));

  // src/lib/ArgumentStream.ts
  var _ArgumentStream = class _ArgumentStream {
    constructor(results) {
      __publicField(this, "results");
      __publicField(this, "state");
      this.results = results;
      this.state = { used: /* @__PURE__ */ new Set(), position: 0 };
    }
    /**
     * Whether or not all ordered parameters were used.
     */
    get finished() {
      return this.used === this.length;
    }
    /**
     * The amount of ordered parameters.
     */
    get length() {
      return this.results.ordered.length;
    }
    /**
     * The remaining amount of ordered parameters.
     */
    get remaining() {
      return this.length - this.used;
    }
    /**
     * The amount of ordered parameters that have been used.
     */
    get used() {
      return this.state.used.size;
    }
    /**
     * Retrieves the value of the next unused ordered token.
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(args.single());
     * // Ok { value: '1' }
     *
     * console.log(args.single());
     * // Ok { value: '2' }
     *
     * console.log(args.single());
     * // Ok { value: '3' }
     *
     * console.log(args.single());
     * // None
     * ```
     *
     * @returns The value, if any.
     */
    single() {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      this.state.used.add(this.state.position);
      return Option.some(this.results.ordered[this.state.position++].value);
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This does not support asynchronous results, refer to {@link singleMapAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number) ? Option.none : Option.some(number);
     * };
     *
     * // Assume args are '1 2 3':
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 1 }
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 2 }
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 3 }
     *
     * console.log(args.singleMap(parse));
     * // None
     * ```
     *
     * @typeparam T The output type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    singleMap(predicate, useAnyways = false) {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This is an asynchronous variant of {@link singleMap}.
     *
     * @typeparam T The output type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    async singleMapAsync(predicate, useAnyways = false) {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Finds and retrieves the next unused parameter and transforms it.
     *
     * @note This is a variant of {@link findMap} that returns the errors on failure.
     * @note This does not support asynchronous results, refer to {@link singleParseAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number)
     *     ? Result.err(`Could not parse ${value} to a number`)
     *     : Result.ok(number);
     * };
     *
     * // Assume args are '1 2 3':
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 1 }
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 2 }
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 3 }
     *
     * console.log(args.singleParse(parse));
     * // Err { error: null }
     * ```
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.
     * @returns The transformed value, if any.
     */
    singleParse(predicate, useAnyways = false) {
      if (this.finished)
        return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This is an asynchronous variant of {@link singleParse}.
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    async singleParseAsync(predicate, useAnyways = false) {
      if (this.finished)
        return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
     * `Option.none` otherwise.
     *
     * @note This does not support asynchronous results, refer to {@link findAsync}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
     * with that element value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    find(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
     * `Option.none` otherwise.
     *
     * @note This is an asynchronous variant of {@link find}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
     * with that element value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
     * `Option.none` otherwise.
     *
     * @note This does not support asynchronous results, refer to {@link findMapAsync}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @typeparam T The output type.
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
     * value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    findMap(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
     * `Option.none` otherwise.
     *
     * @note This is an asynchronous variant of {@link findMap}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @typeparam T The output type.
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
     * value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findMapAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    /**
     * Finds and retrieves the first unused parameter that could be transformed.
     *
     * @note This is a variant of {@link findMap} that returns the errors on failure.
     * @note This does not support asynchronous results, refer to {@link findParseAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number)
     *     ? Result.err(`Could not parse ${value} to a number`)
     *     : Result.ok(number);
     * };
     *
     * // Suppose args are from 'ba 1 cc'.
     *
     * console.log(args.findParse(parse));
     * // Ok { value: 1 }
     *
     * console.log(args.findParse(parse));
     * // Err {
     * //   error: [
     * //     'Could not parse ba to a number',
     * //     'Could not parse cc to a number'
     * //   ]
     * // }
     * ```
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
     * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
     * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    findParse(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    /**
     * Finds and retrieves the first unused parameter that could be transformed.
     *
     * @note This is a variant of {@link findMapAsync} that returns the errors on failure.
     * @note This is an asynchronous variant of {@link findParse}.
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
     * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
     * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findParseAsync(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    /**
     * Retrieves multiple unused parameters.
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(join(args.many().unwrap()));
     * // '1 2 3'
     * ```
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(join(args.many(2).unwrap()));
     * // '1 2'
     * ```
     *
     * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The unused parameters within the range.
     */
    many(limit = Infinity, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        this.state.used.add(i);
        parameters.push(this.results.ordered[i]);
        if (parameters.length >= limit)
          break;
      }
      return parameters.length ? Option.some(parameters) : Option.none;
    }
    filter(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    async filterAsync(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    filterMap(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    async filterMapAsync(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    /**
     * Checks whether any of the flags were given.
     *
     * @example
     * ```typescript
     * // Assume args are '--f --g':
     *
     * console.log(args.flag('f'));
     * // true
     *
     * console.log(args.flag('g', 'h'));
     * // true
     *
     * console.log(args.flag('h'));
     * // false
     * ```
     *
     * @param keys The names of the flags to check.
     * @returns Whether or not any of the flags were given.
     */
    flag(...keys) {
      return keys.some((key) => this.results.flags.has(key));
    }
    /**
     * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.
     *
     * @example
     * ```typescript
     * // Assume args are '--a=1 --b=2 --c=3'.
     * console.log(args.option('a'));
     * // Some { value: '1' }
     *
     * console.log(args.option('b', 'c'));
     * // Some { value: '3' }
     *
     * console.log(args.option('d'));
     * // None {}
     * ```
     *
     * @param keys The names of the options to check.
     * @returns The last value of the option, if any.
     */
    option(...keys) {
      return this.options(...keys).map((values) => values.at(-1));
    }
    /**
     * Gets all values from all options.
     *
     * @example
     * ```typescript
     * // Assume args are '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.option('a'));
     * // Some { value: ['1', '1'] }
     *
     * console.log(args.option('b', 'c'));
     * // Some { value: ['2', '3'] }
     *
     * console.log(args.option('d'));
     * // None {}
     * ```
     *
     * @param keys The names of the options to check.
     * @returns The values from all the options concatenated, if any.
     */
    options(...keys) {
      const entries = [];
      for (const key of keys) {
        const values = this.results.options.get(key);
        if (values)
          entries.push(...values);
      }
      return entries.length ? Option.some(entries) : Option.none;
    }
    save() {
      return {
        used: new Set(this.state.used),
        position: this.state.position
      };
    }
    restore(state) {
      this.state = state;
    }
    reset() {
      this.restore({ used: /* @__PURE__ */ new Set(), position: 0 });
    }
  };
  __name(_ArgumentStream, "ArgumentStream");
  var ArgumentStream = _ArgumentStream;

  // src/lib/lexer/streams/parameters/BaseParameter.ts
  var _BaseParameter = class _BaseParameter {
    constructor(separators) {
      __publicField(this, "separators");
      this.separators = separators;
    }
    get leading() {
      return this.separators.join("");
    }
  };
  __name(_BaseParameter, "BaseParameter");
  var BaseParameter = _BaseParameter;

  // src/lib/lexer/streams/parameters/QuotedParameter.ts
  var _QuotedParameter = class _QuotedParameter extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      __publicField(this, "open");
      __publicField(this, "close");
      this.value = part.value;
      this.open = part.open;
      this.close = part.close;
    }
    get raw() {
      return `${this.open}${this.value}${this.close}`;
    }
  };
  __name(_QuotedParameter, "QuotedParameter");
  var QuotedParameter = _QuotedParameter;

  // src/lib/lexer/streams/parameters/WordParameter.ts
  var _WordParameter = class _WordParameter extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      this.value = part.value;
    }
    get raw() {
      return this.value;
    }
  };
  __name(_WordParameter, "WordParameter");
  var WordParameter = _WordParameter;

  // src/lib/lexer/streams/raw/TokenStream.ts
  var _TokenStream = class _TokenStream {
    constructor(lexer, input) {
      __publicField(this, "input");
      __publicField(this, "quotes");
      __publicField(this, "separator");
      __publicField(this, "position", 0);
      this.quotes = lexer.quotes;
      this.separator = lexer.separator;
      this.input = input;
    }
    get finished() {
      return this.position >= this.input.length;
    }
    *[Symbol.iterator]() {
      while (!this.finished) {
        yield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();
      }
    }
    getPossibleSeparator() {
      if (this.input.startsWith(this.separator, this.position)) {
        this.position += this.separator.length;
        return { type: 2 /* Separator */, value: this.separator };
      }
      return null;
    }
    getPossibleQuotedArgument() {
      for (const [open, close] of this.quotes) {
        if (!this.input.startsWith(open, this.position))
          continue;
        const end = this.input.indexOf(close, this.position + open.length);
        if (end === -1)
          continue;
        const value = this.input.slice(this.position + open.length, end);
        this.position = end + close.length;
        return { type: 1 /* Quoted */, value, open, close };
      }
      return null;
    }
    getParameter() {
      const index = this.input.indexOf(this.separator, this.position);
      const value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);
      this.position += value.length;
      return { type: 0 /* Parameter */, value };
    }
  };
  __name(_TokenStream, "TokenStream");
  var TokenStream = _TokenStream;
  var TokenType = /* @__PURE__ */ ((TokenType2) => {
    TokenType2[TokenType2["Parameter"] = 0] = "Parameter";
    TokenType2[TokenType2["Quoted"] = 1] = "Quoted";
    TokenType2[TokenType2["Separator"] = 2] = "Separator";
    return TokenType2;
  })(TokenType || {});

  // src/lib/lexer/streams/ParameterStream.ts
  var _ParameterStream = class _ParameterStream {
    constructor(stream) {
      __publicField(this, "stream");
      __publicField(this, "separators", []);
      this.stream = stream;
    }
    *[Symbol.iterator]() {
      for (const part of this.stream) {
        if (part.type === 2 /* Separator */) {
          this.separators.push(part.value);
          continue;
        }
        yield part.type === 1 /* Quoted */ ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);
        this.separators = [];
      }
      return this.separators;
    }
  };
  __name(_ParameterStream, "ParameterStream");
  var ParameterStream = _ParameterStream;

  // src/lib/lexer/Lexer.ts
  var _Lexer = class _Lexer {
    constructor(options = {}) {
      __publicField(this, "quotes");
      __publicField(this, "separator");
      this.quotes = options.quotes ?? [];
      this.separator = options.separator ?? " ";
    }
    run(input) {
      return new ParameterStream(this.raw(input));
    }
    raw(input) {
      return new TokenStream(this, input);
    }
  };
  __name(_Lexer, "Lexer");
  var Lexer = _Lexer;

  // src/lib/parser/ParserResult.ts
  var _ParserResult = class _ParserResult {
    constructor(parser) {
      __publicField(this, "ordered", []);
      __publicField(this, "flags", /* @__PURE__ */ new Set());
      __publicField(this, "options", /* @__PURE__ */ new Map());
      __publicField(this, "strategy");
      this.strategy = parser.strategy;
    }
    parse(parameters) {
      for (const parameter of parameters) {
        this.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);
      }
      return this;
    }
    parsePossibleFlag(parameter) {
      return this.strategy.matchFlag(parameter.value).inspect((value) => this.flags.add(value)).isSome();
    }
    parsePossibleOptions(parameter) {
      return this.strategy.matchOption(parameter.value).inspect(([key, value]) => {
        const existing = this.options.get(key);
        if (existing)
          existing.push(value);
        else
          this.options.set(key, [value]);
      }).isSome();
    }
    parseOrdered(parameter) {
      this.ordered.push(parameter);
      return true;
    }
  };
  __name(_ParserResult, "ParserResult");
  var ParserResult = _ParserResult;

  // src/lib/parser/strategies/EmptyStrategy.ts
  var _EmptyStrategy = class _EmptyStrategy {
    matchFlag() {
      return Option.none;
    }
    matchOption() {
      return Option.none;
    }
  };
  __name(_EmptyStrategy, "EmptyStrategy");
  var EmptyStrategy = _EmptyStrategy;

  // src/lib/parser/Parser.ts
  var _Parser = class _Parser {
    constructor(strategy) {
      __publicField(this, "strategy");
      this.strategy = strategy ?? new EmptyStrategy();
    }
    setUnorderedStrategy(strategy) {
      this.strategy = strategy;
      return this;
    }
    run(input) {
      return new ParserResult(this).parse(input);
    }
  };
  __name(_Parser, "Parser");
  var Parser = _Parser;

  // src/lib/parser/strategies/PrefixedStrategy.ts
  var _PrefixedStrategy = class _PrefixedStrategy {
    constructor(prefixes, separators) {
      __publicField(this, "prefixes");
      __publicField(this, "separators");
      this.prefixes = prefixes;
      this.separators = separators;
    }
    matchFlag(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix)
        return Option.none;
      if (this.separators.some((x) => input.includes(x, prefix.length)))
        return Option.none;
      return Option.some(input.slice(prefix.length));
    }
    matchOption(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix)
        return Option.none;
      for (const separator of this.separators) {
        const index = input.indexOf(separator, prefix.length + 1);
        if (index === -1)
          continue;
        if (index + separator.length === input.length)
          return Option.none;
        const key = input.slice(prefix.length, index);
        const value = input.slice(index + separator.length);
        return Option.some([key, value]);
      }
      return Option.none;
    }
  };
  __name(_PrefixedStrategy, "PrefixedStrategy");
  var PrefixedStrategy = _PrefixedStrategy;

  // src/lib/util/util.ts
  function join(parameters) {
    if (parameters.length === 0)
      return "";
    if (parameters.length === 1)
      return parameters[0].value;
    let output = parameters[0].value;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.value;
    }
    return output;
  }
  __name(join, "join");
  function joinRaw(parameters) {
    if (parameters.length === 0)
      return "";
    if (parameters.length === 1)
      return parameters[0].raw;
    let output = parameters[0].raw;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.raw;
    }
    return output;
  }
  __name(joinRaw, "joinRaw");

  exports.ArgumentStream = ArgumentStream;
  exports.BaseParameter = BaseParameter;
  exports.EmptyStrategy = EmptyStrategy;
  exports.Lexer = Lexer;
  exports.ParameterStream = ParameterStream;
  exports.Parser = Parser;
  exports.ParserResult = ParserResult;
  exports.PrefixedStrategy = PrefixedStrategy;
  exports.QuotedParameter = QuotedParameter;
  exports.TokenStream = TokenStream;
  exports.TokenType = TokenType;
  exports.WordParameter = WordParameter;
  exports.join = join;
  exports.joinRaw = joinRaw;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.global.js.map