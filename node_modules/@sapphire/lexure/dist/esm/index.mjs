import { Option, Result } from '@sapphire/result';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ArgumentStream = class _ArgumentStream {
  constructor(results) {
    __publicField(this, "results");
    __publicField(this, "state");
    this.results = results;
    this.state = { used: /* @__PURE__ */ new Set(), position: 0 };
  }
  /**
   * Whether or not all ordered parameters were used.
   */
  get finished() {
    return this.used === this.length;
  }
  /**
   * The amount of ordered parameters.
   */
  get length() {
    return this.results.ordered.length;
  }
  /**
   * The remaining amount of ordered parameters.
   */
  get remaining() {
    return this.length - this.used;
  }
  /**
   * The amount of ordered parameters that have been used.
   */
  get used() {
    return this.state.used.size;
  }
  /**
   * Retrieves the value of the next unused ordered token.
   *
   * @example
   * ```typescript
   * // Assume args are '1 2 3':
   *
   * console.log(args.single());
   * // Ok { value: '1' }
   *
   * console.log(args.single());
   * // Ok { value: '2' }
   *
   * console.log(args.single());
   * // Ok { value: '3' }
   *
   * console.log(args.single());
   * // None
   * ```
   *
   * @returns The value, if any.
   */
  single() {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    this.state.used.add(this.state.position);
    return Option.some(this.results.ordered[this.state.position++].value);
  }
  /**
   * Retrieves the value of the next unused ordered token, but only if it could be transformed.
   *
   * @note This does not support asynchronous results, refer to {@link singleMapAsync}.
   *
   * @example
   * ```typescript
   * const parse = (value) => {
   *   const number = Number(value);
   *   return Number.isNaN(number) ? Option.none : Option.some(number);
   * };
   *
   * // Assume args are '1 2 3':
   *
   * console.log(args.singleMap(parse));
   * // Some { value: 1 }
   *
   * console.log(args.singleMap(parse));
   * // Some { value: 2 }
   *
   * console.log(args.singleMap(parse));
   * // Some { value: 3 }
   *
   * console.log(args.singleMap(parse));
   * // None
   * ```
   *
   * @typeparam T The output type.
   * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
   * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
   * @returns The mapped value, if any.
   */
  singleMap(predicate, useAnyways = false) {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = predicate(this.results.ordered[this.state.position].value);
    if (result.isSome() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  /**
   * Retrieves the value of the next unused ordered token, but only if it could be transformed.
   *
   * @note This is an asynchronous variant of {@link singleMap}.
   *
   * @typeparam T The output type.
   * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
   * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
   * @returns The mapped value, if any.
   */
  async singleMapAsync(predicate, useAnyways = false) {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = await predicate(this.results.ordered[this.state.position].value);
    if (result.isSome() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  /**
   * Finds and retrieves the next unused parameter and transforms it.
   *
   * @note This is a variant of {@link findMap} that returns the errors on failure.
   * @note This does not support asynchronous results, refer to {@link singleParseAsync}.
   *
   * @example
   * ```typescript
   * const parse = (value) => {
   *   const number = Number(value);
   *   return Number.isNaN(number)
   *     ? Result.err(`Could not parse ${value} to a number`)
   *     : Result.ok(number);
   * };
   *
   * // Assume args are '1 2 3':
   *
   * console.log(args.singleParse(parse));
   * // Ok { value: 1 }
   *
   * console.log(args.singleParse(parse));
   * // Ok { value: 2 }
   *
   * console.log(args.singleParse(parse));
   * // Ok { value: 3 }
   *
   * console.log(args.singleParse(parse));
   * // Err { error: null }
   * ```
   *
   * @typeparam T The output type.
   * @typeparam E The error type.
   * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.
   * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.
   * @returns The transformed value, if any.
   */
  singleParse(predicate, useAnyways = false) {
    if (this.finished)
      return Result.err(null);
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = predicate(this.results.ordered[this.state.position].value);
    if (result.isOk() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  /**
   * Retrieves the value of the next unused ordered token, but only if it could be transformed.
   *
   * @note This is an asynchronous variant of {@link singleParse}.
   *
   * @typeparam T The output type.
   * @typeparam E The error type.
   * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
   * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
   * @returns The mapped value, if any.
   */
  async singleParseAsync(predicate, useAnyways = false) {
    if (this.finished)
      return Result.err(null);
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = await predicate(this.results.ordered[this.state.position].value);
    if (result.isOk() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  /**
   * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
   * `Option.none` otherwise.
   *
   * @note This does not support asynchronous results, refer to {@link findAsync}.
   *
   * @example
   * ```typescript
   * // Suppose args are from 'ba aa cc'.
   *
   * console.log(args.find((value) => value.startsWith('a')));
   * // Some { value: 'aa' }
   * ```
   *
   * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
   * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
   * with that element value. Otherwise, find returns `Option.none`.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  find(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (predicate(parameter)) {
        this.state.used.add(i);
        return Option.some(parameter);
      }
    }
    return Option.none;
  }
  /**
   * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
   * `Option.none` otherwise.
   *
   * @note This is an asynchronous variant of {@link find}.
   *
   * @example
   * ```typescript
   * // Suppose args are from 'ba aa cc'.
   *
   * console.log(args.find((value) => value.startsWith('a')));
   * // Some { value: 'aa' }
   * ```
   *
   * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
   * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
   * with that element value. Otherwise, find returns `Option.none`.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  async findAsync(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (await predicate(parameter)) {
        this.state.used.add(i);
        return Option.some(parameter);
      }
    }
    return Option.none;
  }
  /**
   * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
   * `Option.none` otherwise.
   *
   * @note This does not support asynchronous results, refer to {@link findMapAsync}.
   *
   * @example
   * ```typescript
   * // Suppose args are from 'ba aa cc'.
   *
   * console.log(args.find((value) => value.startsWith('a')));
   * // Some { value: 'aa' }
   * ```
   *
   * @typeparam T The output type.
   * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
   * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
   * value. Otherwise, find returns `Option.none`.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  findMap(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      if (result.isSome()) {
        this.state.used.add(i);
        return result;
      }
    }
    return Option.none;
  }
  /**
   * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
   * `Option.none` otherwise.
   *
   * @note This is an asynchronous variant of {@link findMap}.
   *
   * @example
   * ```typescript
   * // Suppose args are from 'ba aa cc'.
   *
   * console.log(args.find((value) => value.startsWith('a')));
   * // Some { value: 'aa' }
   * ```
   *
   * @typeparam T The output type.
   * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
   * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
   * value. Otherwise, find returns `Option.none`.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  async findMapAsync(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      if (result.isSome()) {
        this.state.used.add(i);
        return result;
      }
    }
    return Option.none;
  }
  /**
   * Finds and retrieves the first unused parameter that could be transformed.
   *
   * @note This is a variant of {@link findMap} that returns the errors on failure.
   * @note This does not support asynchronous results, refer to {@link findParseAsync}.
   *
   * @example
   * ```typescript
   * const parse = (value) => {
   *   const number = Number(value);
   *   return Number.isNaN(number)
   *     ? Result.err(`Could not parse ${value} to a number`)
   *     : Result.ok(number);
   * };
   *
   * // Suppose args are from 'ba 1 cc'.
   *
   * console.log(args.findParse(parse));
   * // Ok { value: 1 }
   *
   * console.log(args.findParse(parse));
   * // Err {
   * //   error: [
   * //     'Could not parse ba to a number',
   * //     'Could not parse cc to a number'
   * //   ]
   * // }
   * ```
   *
   * @typeparam T The output type.
   * @typeparam E The error type.
   * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
   * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
   * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  findParse(predicate, from = this.state.position) {
    const errors = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      if (result.isOk()) {
        this.state.used.add(i);
        return result;
      }
      errors.push(result.unwrapErr());
    }
    return Result.err(errors);
  }
  /**
   * Finds and retrieves the first unused parameter that could be transformed.
   *
   * @note This is a variant of {@link findMapAsync} that returns the errors on failure.
   * @note This is an asynchronous variant of {@link findParse}.
   *
   * @typeparam T The output type.
   * @typeparam E The error type.
   * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
   * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
   * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The found parameter's value.
   */
  async findParseAsync(predicate, from = this.state.position) {
    const errors = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      if (result.isOk()) {
        this.state.used.add(i);
        return result;
      }
      errors.push(result.unwrapErr());
    }
    return Result.err(errors);
  }
  /**
   * Retrieves multiple unused parameters.
   *
   * @example
   * ```typescript
   * // Assume args are '1 2 3':
   *
   * console.log(join(args.many().unwrap()));
   * // '1 2 3'
   * ```
   *
   * @example
   * ```typescript
   * // Assume args are '1 2 3':
   *
   * console.log(join(args.many(2).unwrap()));
   * // '1 2'
   * ```
   *
   * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.
   * @param from The position where to start looking for unused parameters, defaults to current position.
   * @returns The unused parameters within the range.
   */
  many(limit = Infinity, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      this.state.used.add(i);
      parameters.push(this.results.ordered[i]);
      if (parameters.length >= limit)
        break;
    }
    return parameters.length ? Option.some(parameters) : Option.none;
  }
  filter(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (predicate(parameter)) {
        this.state.used.add(i);
        parameters.push(parameter);
      }
    }
    return Option.some(parameters);
  }
  async filterAsync(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (await predicate(parameter)) {
        this.state.used.add(i);
        parameters.push(parameter);
      }
    }
    return Option.some(parameters);
  }
  filterMap(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      result.inspect((value) => {
        this.state.used.add(i);
        parameters.push(value);
      });
    }
    return Option.some(parameters);
  }
  async filterMapAsync(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      result.inspect((value) => {
        this.state.used.add(i);
        parameters.push(value);
      });
    }
    return Option.some(parameters);
  }
  /**
   * Checks whether any of the flags were given.
   *
   * @example
   * ```typescript
   * // Assume args are '--f --g':
   *
   * console.log(args.flag('f'));
   * // true
   *
   * console.log(args.flag('g', 'h'));
   * // true
   *
   * console.log(args.flag('h'));
   * // false
   * ```
   *
   * @param keys The names of the flags to check.
   * @returns Whether or not any of the flags were given.
   */
  flag(...keys) {
    return keys.some((key) => this.results.flags.has(key));
  }
  /**
   * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.
   *
   * @example
   * ```typescript
   * // Assume args are '--a=1 --b=2 --c=3'.
   * console.log(args.option('a'));
   * // Some { value: '1' }
   *
   * console.log(args.option('b', 'c'));
   * // Some { value: '3' }
   *
   * console.log(args.option('d'));
   * // None {}
   * ```
   *
   * @param keys The names of the options to check.
   * @returns The last value of the option, if any.
   */
  option(...keys) {
    return this.options(...keys).map((values) => values.at(-1));
  }
  /**
   * Gets all values from all options.
   *
   * @example
   * ```typescript
   * // Assume args are '--a=1 --a=1 --b=2 --c=3'.
   * console.log(args.option('a'));
   * // Some { value: ['1', '1'] }
   *
   * console.log(args.option('b', 'c'));
   * // Some { value: ['2', '3'] }
   *
   * console.log(args.option('d'));
   * // None {}
   * ```
   *
   * @param keys The names of the options to check.
   * @returns The values from all the options concatenated, if any.
   */
  options(...keys) {
    const entries = [];
    for (const key of keys) {
      const values = this.results.options.get(key);
      if (values)
        entries.push(...values);
    }
    return entries.length ? Option.some(entries) : Option.none;
  }
  save() {
    return {
      used: new Set(this.state.used),
      position: this.state.position
    };
  }
  restore(state) {
    this.state = state;
  }
  reset() {
    this.restore({ used: /* @__PURE__ */ new Set(), position: 0 });
  }
};
__name(_ArgumentStream, "ArgumentStream");
var ArgumentStream = _ArgumentStream;

// src/lib/lexer/streams/parameters/BaseParameter.ts
var _BaseParameter = class _BaseParameter {
  constructor(separators) {
    __publicField(this, "separators");
    this.separators = separators;
  }
  get leading() {
    return this.separators.join("");
  }
};
__name(_BaseParameter, "BaseParameter");
var BaseParameter = _BaseParameter;

// src/lib/lexer/streams/parameters/QuotedParameter.ts
var _QuotedParameter = class _QuotedParameter extends BaseParameter {
  constructor(separators, part) {
    super(separators);
    __publicField(this, "value");
    __publicField(this, "open");
    __publicField(this, "close");
    this.value = part.value;
    this.open = part.open;
    this.close = part.close;
  }
  get raw() {
    return `${this.open}${this.value}${this.close}`;
  }
};
__name(_QuotedParameter, "QuotedParameter");
var QuotedParameter = _QuotedParameter;

// src/lib/lexer/streams/parameters/WordParameter.ts
var _WordParameter = class _WordParameter extends BaseParameter {
  constructor(separators, part) {
    super(separators);
    __publicField(this, "value");
    this.value = part.value;
  }
  get raw() {
    return this.value;
  }
};
__name(_WordParameter, "WordParameter");
var WordParameter = _WordParameter;

// src/lib/lexer/streams/raw/TokenStream.ts
var _TokenStream = class _TokenStream {
  constructor(lexer, input) {
    __publicField(this, "input");
    __publicField(this, "quotes");
    __publicField(this, "separator");
    __publicField(this, "position", 0);
    this.quotes = lexer.quotes;
    this.separator = lexer.separator;
    this.input = input;
  }
  get finished() {
    return this.position >= this.input.length;
  }
  *[Symbol.iterator]() {
    while (!this.finished) {
      yield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();
    }
  }
  getPossibleSeparator() {
    if (this.input.startsWith(this.separator, this.position)) {
      this.position += this.separator.length;
      return { type: 2 /* Separator */, value: this.separator };
    }
    return null;
  }
  getPossibleQuotedArgument() {
    for (const [open, close] of this.quotes) {
      if (!this.input.startsWith(open, this.position))
        continue;
      const end = this.input.indexOf(close, this.position + open.length);
      if (end === -1)
        continue;
      const value = this.input.slice(this.position + open.length, end);
      this.position = end + close.length;
      return { type: 1 /* Quoted */, value, open, close };
    }
    return null;
  }
  getParameter() {
    const index = this.input.indexOf(this.separator, this.position);
    const value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);
    this.position += value.length;
    return { type: 0 /* Parameter */, value };
  }
};
__name(_TokenStream, "TokenStream");
var TokenStream = _TokenStream;
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["Parameter"] = 0] = "Parameter";
  TokenType2[TokenType2["Quoted"] = 1] = "Quoted";
  TokenType2[TokenType2["Separator"] = 2] = "Separator";
  return TokenType2;
})(TokenType || {});

// src/lib/lexer/streams/ParameterStream.ts
var _ParameterStream = class _ParameterStream {
  constructor(stream) {
    __publicField(this, "stream");
    __publicField(this, "separators", []);
    this.stream = stream;
  }
  *[Symbol.iterator]() {
    for (const part of this.stream) {
      if (part.type === 2 /* Separator */) {
        this.separators.push(part.value);
        continue;
      }
      yield part.type === 1 /* Quoted */ ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);
      this.separators = [];
    }
    return this.separators;
  }
};
__name(_ParameterStream, "ParameterStream");
var ParameterStream = _ParameterStream;

// src/lib/lexer/Lexer.ts
var _Lexer = class _Lexer {
  constructor(options = {}) {
    __publicField(this, "quotes");
    __publicField(this, "separator");
    this.quotes = options.quotes ?? [];
    this.separator = options.separator ?? " ";
  }
  run(input) {
    return new ParameterStream(this.raw(input));
  }
  raw(input) {
    return new TokenStream(this, input);
  }
};
__name(_Lexer, "Lexer");
var Lexer = _Lexer;

// src/lib/parser/ParserResult.ts
var _ParserResult = class _ParserResult {
  constructor(parser) {
    __publicField(this, "ordered", []);
    __publicField(this, "flags", /* @__PURE__ */ new Set());
    __publicField(this, "options", /* @__PURE__ */ new Map());
    __publicField(this, "strategy");
    this.strategy = parser.strategy;
  }
  parse(parameters) {
    for (const parameter of parameters) {
      this.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);
    }
    return this;
  }
  parsePossibleFlag(parameter) {
    return this.strategy.matchFlag(parameter.value).inspect((value) => this.flags.add(value)).isSome();
  }
  parsePossibleOptions(parameter) {
    return this.strategy.matchOption(parameter.value).inspect(([key, value]) => {
      const existing = this.options.get(key);
      if (existing)
        existing.push(value);
      else
        this.options.set(key, [value]);
    }).isSome();
  }
  parseOrdered(parameter) {
    this.ordered.push(parameter);
    return true;
  }
};
__name(_ParserResult, "ParserResult");
var ParserResult = _ParserResult;
var _EmptyStrategy = class _EmptyStrategy {
  matchFlag() {
    return Option.none;
  }
  matchOption() {
    return Option.none;
  }
};
__name(_EmptyStrategy, "EmptyStrategy");
var EmptyStrategy = _EmptyStrategy;

// src/lib/parser/Parser.ts
var _Parser = class _Parser {
  constructor(strategy) {
    __publicField(this, "strategy");
    this.strategy = strategy ?? new EmptyStrategy();
  }
  setUnorderedStrategy(strategy) {
    this.strategy = strategy;
    return this;
  }
  run(input) {
    return new ParserResult(this).parse(input);
  }
};
__name(_Parser, "Parser");
var Parser = _Parser;
var _PrefixedStrategy = class _PrefixedStrategy {
  constructor(prefixes, separators) {
    __publicField(this, "prefixes");
    __publicField(this, "separators");
    this.prefixes = prefixes;
    this.separators = separators;
  }
  matchFlag(input) {
    const prefix = this.prefixes.find((x) => input.startsWith(x));
    if (!prefix)
      return Option.none;
    if (this.separators.some((x) => input.includes(x, prefix.length)))
      return Option.none;
    return Option.some(input.slice(prefix.length));
  }
  matchOption(input) {
    const prefix = this.prefixes.find((x) => input.startsWith(x));
    if (!prefix)
      return Option.none;
    for (const separator of this.separators) {
      const index = input.indexOf(separator, prefix.length + 1);
      if (index === -1)
        continue;
      if (index + separator.length === input.length)
        return Option.none;
      const key = input.slice(prefix.length, index);
      const value = input.slice(index + separator.length);
      return Option.some([key, value]);
    }
    return Option.none;
  }
};
__name(_PrefixedStrategy, "PrefixedStrategy");
var PrefixedStrategy = _PrefixedStrategy;

// src/lib/util/util.ts
function join(parameters) {
  if (parameters.length === 0)
    return "";
  if (parameters.length === 1)
    return parameters[0].value;
  let output = parameters[0].value;
  for (let i = 1; i < parameters.length; i++) {
    const parameter = parameters[i];
    output += parameter.leading + parameter.value;
  }
  return output;
}
__name(join, "join");
function joinRaw(parameters) {
  if (parameters.length === 0)
    return "";
  if (parameters.length === 1)
    return parameters[0].raw;
  let output = parameters[0].raw;
  for (let i = 1; i < parameters.length; i++) {
    const parameter = parameters[i];
    output += parameter.leading + parameter.raw;
  }
  return output;
}
__name(joinRaw, "joinRaw");

export { ArgumentStream, BaseParameter, EmptyStrategy, Lexer, ParameterStream, Parser, ParserResult, PrefixedStrategy, QuotedParameter, TokenStream, TokenType, WordParameter, join, joinRaw };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map