{"version":3,"sources":["../../../../src/lib/structures/Piece.ts"],"names":["Piece"],"mappings":";;;;;;;;;AACA,SAAS,iBAAiC;AAC1C,SAAS,qBAA6C;AAqD/C,IAAM,SAAN,MAAM,OAA0G;AAAA,EA0B/G,YAAY,SAAyC,UAAwB,CAAC,GAAG;AAtBxF;AAAA;AAAA;AAAA,wBAAgB;AAKhB;AAAA;AAAA;AAAA,wBAAgB;AAKhB;AAAA;AAAA;AAAA,wBAAgB;AAKhB;AAAA;AAAA;AAAA,wBAAO;AAKP;AAAA;AAAA;AAAA,wBAAgB;AAGf,SAAK,QAAQ,QAAQ;AACrB,SAAK,WAAW,IAAI,cAAc,QAAQ,MAAM,QAAQ,IAAI;AAC5D,SAAK,OAAO,QAAQ,QAAQ,QAAQ;AACpC,SAAK,UAAU,QAAQ,WAAW;AAClC,SAAK,UAAU;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,YAAuB;AACjC,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,SAA6B;AACnC,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,WAA+B;AACrC,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,SAAS;AACrB,UAAM,KAAK,MAAM,OAAO,KAAK,IAAI;AACjC,SAAK,UAAU;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,SAAS;AACrB,UAAM,KAAK,MAAM,KAAK,KAAK,SAAS,MAAM,KAAK,SAAS,QAAQ;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKO,SAAoB;AAC1B,WAAO;AAAA,MACN,UAAU,KAAK,SAAS,OAAO;AAAA,MAC/B,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,MACd,SAAS,KAAK;AAAA,IACf;AAAA,EACD;AACD;AApFuH;AAAhH,IAAM,QAAN;AAAA,CAgGA,CAAUA,WAAV;AACC,EAAMA,OAAA,WAAW;AAAA,GADR","sourcesContent":["import type { Awaitable } from '@sapphire/utilities';\nimport { container, type Container } from '../shared/Container';\nimport { PieceLocation, type PieceLocationJSON } from './PieceLocation';\nimport type { Store } from './Store';\nimport type { StoreOf, StoreRegistryKey } from './StoreRegistry';\n\n/**\n * The context for the piece, contains extra information from the store,\n * the piece's path, and the store that loaded it.\n */\nexport interface LoaderPieceContext<StoreName extends StoreRegistryKey = StoreRegistryKey> {\n\t/**\n\t * The root directory the piece was loaded from.\n\t */\n\treadonly root: string;\n\n\t/**\n\t * The path the module was loaded from, relative to {@link LoaderPieceContext.root}.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * The module's name extracted from the path.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * The store that loaded the piece.\n\t */\n\treadonly store: StoreOf<StoreName>;\n}\n\n/** @deprecated Use {@linkcode LoaderPieceContext} instead. */\nexport interface PieceContext<StoreName extends StoreRegistryKey = StoreRegistryKey> extends LoaderPieceContext<StoreName> {}\n\n/**\n * The options for the {@link Piece}.\n */\nexport interface PieceOptions {\n\t/**\n\t * The name for the piece.\n\t * @default ''\n\t */\n\treadonly name?: string;\n\n\t/**\n\t * Whether or not the piece should be enabled. If set to false, the piece will be unloaded.\n\t * @default true\n\t */\n\treadonly enabled?: boolean;\n}\n\n/**\n * The piece to be stored in {@link Store} instances.\n */\nexport class Piece<Options extends PieceOptions = PieceOptions, StoreName extends StoreRegistryKey = StoreRegistryKey> {\n\t/**\n\t * The store that contains the piece.\n\t */\n\tpublic readonly store: StoreOf<StoreName>;\n\n\t/**\n\t * The location metadata for the piece's file.\n\t */\n\tpublic readonly location: PieceLocation;\n\n\t/**\n\t * The name of the piece.\n\t */\n\tpublic readonly name: string;\n\n\t/**\n\t * Whether or not the piece is enabled.\n\t */\n\tpublic enabled: boolean;\n\n\t/**\n\t * The raw options passed to this {@link Piece}\n\t */\n\tpublic readonly options: Options;\n\n\tpublic constructor(context: Piece.LoaderContext<StoreName>, options: PieceOptions = {}) {\n\t\tthis.store = context.store;\n\t\tthis.location = new PieceLocation(context.path, context.root);\n\t\tthis.name = options.name ?? context.name;\n\t\tthis.enabled = options.enabled ?? true;\n\t\tthis.options = options as Options;\n\t}\n\n\t/**\n\t * A reference to the {@link Container} object for ease of use.\n\t * @see container\n\t */\n\tpublic get container(): Container {\n\t\treturn container;\n\t}\n\n\t/**\n\t * Per-piece listener that is called when the piece is loaded into the store.\n\t * Useful to set-up asynchronous initialization tasks.\n\t */\n\tpublic onLoad(): Awaitable<unknown> {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Per-piece listener that is called when the piece is unloaded from the store.\n\t * Useful to set-up clean-up tasks.\n\t */\n\tpublic onUnload(): Awaitable<unknown> {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Unloads and disables the piece.\n\t */\n\tpublic async unload() {\n\t\tawait this.store.unload(this.name);\n\t\tthis.enabled = false;\n\t}\n\n\t/**\n\t * Reloads the piece by loading the same path in the store.\n\t */\n\tpublic async reload() {\n\t\tawait this.store.load(this.location.root, this.location.relative);\n\t}\n\n\t/**\n\t * Defines the `JSON.stringify` behavior of this piece.\n\t */\n\tpublic toJSON(): PieceJSON {\n\t\treturn {\n\t\t\tlocation: this.location.toJSON(),\n\t\t\tname: this.name,\n\t\t\tenabled: this.enabled,\n\t\t\toptions: this.options\n\t\t};\n\t}\n}\n\n/**\n * The return type of {@link Piece.toJSON}.\n */\nexport interface PieceJSON {\n\tlocation: PieceLocationJSON;\n\tname: string;\n\tenabled: boolean;\n\toptions: PieceOptions;\n}\n\nexport namespace Piece {\n\texport const Location = PieceLocation;\n\texport type Options = PieceOptions;\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context<StoreName extends StoreRegistryKey = StoreRegistryKey> = LoaderPieceContext<StoreName>;\n\texport type LoaderContext<StoreName extends StoreRegistryKey = StoreRegistryKey> = LoaderPieceContext<StoreName>;\n\texport type JSON = PieceJSON;\n\texport type LocationJSON = PieceLocationJSON;\n}\n"]}