'use strict';

var collection = require('@discordjs/collection');
var utilities = require('@sapphire/utilities');
var path = require('path');
var LoaderError_cjs = require('../errors/LoaderError.cjs');
var Path_cjs = require('../internal/Path.cjs');
var constants_cjs = require('../internal/constants.cjs');
var Container_cjs = require('../shared/Container.cjs');
var LoaderStrategy_cjs = require('../strategies/LoaderStrategy.cjs');
var StoreRegistry_cjs = require('./StoreRegistry.cjs');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var defaultStrategy = new LoaderStrategy_cjs.LoaderStrategy();
var _a, _calledLoadAll, _walk;
var _Store = class _Store extends collection.Collection {
  /**
   * @param constructor The piece constructor this store loads.
   * @param options The options for the store.
   */
  constructor(constructor, options) {
    super();
    __publicField(this, "Constructor");
    __publicField(this, "name");
    __publicField(this, "paths");
    __publicField(this, "strategy");
    /**
     * The queue of manually registered pieces to load.
     */
    __publicField(this, _a, /* @__PURE__ */ new Map());
    /**
     * Whether or not the store has called `loadAll` at least once.
     */
    __privateAdd(this, _calledLoadAll, false);
    /**
     * The walk function for the store.
     */
    __privateAdd(this, _walk, void 0);
    this.Constructor = constructor;
    this.name = options.name;
    this.paths = new Set(options.paths ?? []);
    this.strategy = options.strategy ?? _Store.defaultStrategy;
    __privateSet(this, _walk, typeof this.strategy.walk === "function" ? this.strategy.walk.bind(this.strategy) : defaultStrategy.walk.bind(defaultStrategy));
  }
  /**
   * A reference to the {@link Container} object for ease of use.
   * @see container
   */
  get container() {
    return Container_cjs.container;
  }
  /**
   * Registers a directory into the store.
   * @param path The path to be added.
   * @example
   * ```typescript
   * store
   *   .registerPath(resolve('commands'))
   *   .registerPath(resolve('third-party', 'commands'));
   * ```
   */
  registerPath(path) {
    const root = Path_cjs.resolvePath(path);
    this.paths.add(root);
    _Store.logger?.(`[STORE => ${this.name}] [REGISTER] Registered path '${root}'.`);
    return this;
  }
  /**
   * Adds a piece into the store's list of manually registered pieces. If {@linkcode Store.loadAll()} was called, the
   * piece will be loaded immediately, otherwise it will be queued until {@linkcode Store.loadAll()} is called.
   *
   * All manually registered pieces will be kept even after they are loaded to ensure they can be loaded again if
   * {@linkcode Store.loadAll()} is called again.
   *
   * @remarks
   *
   * - Pieces loaded this way will have their {@linkcode Piece.Context.root root} and
   *   {@linkcode Piece.Context.path path} set to {@linkcode VirtualPath}, and as such, cannot be reloaded.
   * - This method is useful in environments where file system access is limited or unavailable, such as when using
   *   {@link https://en.wikipedia.org/wiki/Serverless_computing Serverless Computing}.
   * - This method will always throw a {@link TypeError} if `entry.piece` is not a class.
   * - This method will always throw a {@linkcode LoaderError} if the piece does not extend the
   *   {@linkcode Store#Constructor store's piece constructor}.
   * - This operation is atomic, if any of the above errors are thrown, the piece will not be loaded.
   *
   * @seealso {@linkcode StoreRegistry.loadPiece()}
   * @since 3.8.0
   * @param entry The entry to load.
   * @example
   * ```typescript
   * import { container } from '@sapphire/pieces';
   *
   * class PingCommand extends Command {
   *   // ...
   * }
   *
   * container.stores.get('commands').loadPiece({
   *   name: 'ping',
   *   piece: PingCommand
   * });
   * ```
   */
  async loadPiece(entry) {
    if (!utilities.isClass(entry.piece)) {
      throw new TypeError(`The piece ${entry.name} is not a Class. ${String(entry.piece)}`);
    }
    if (!utilities.classExtends(entry.piece, this.Constructor)) {
      throw new LoaderError_cjs.LoaderError(LoaderError_cjs.LoaderErrorType.IncorrectType, `The piece ${entry.name} does not extend ${this.name}`);
    }
    this[constants_cjs.ManuallyRegisteredPiecesSymbol].set(entry.name, entry);
    if (__privateGet(this, _calledLoadAll)) {
      const piece = this.construct(entry.piece, {
        name: entry.name,
        root: constants_cjs.VirtualPath,
        path: constants_cjs.VirtualPath,
        extension: constants_cjs.VirtualPath
      });
      await this.insert(piece);
    }
  }
  /**
   * Loads one or more pieces from a path.
   * @param root The root directory the file is from.
   * @param path The path of the file to load, relative to the `root`.
   * @return All the loaded pieces.
   */
  async load(root, path$1) {
    if (root === constants_cjs.VirtualPath) {
      throw new LoaderError_cjs.LoaderError(LoaderError_cjs.LoaderErrorType.VirtualPiece, `Cannot load a virtual file.`);
    }
    const full = path.join(root, path$1);
    const data = this.strategy.filter(full);
    if (data === null) {
      _Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${full}' as 'LoaderStrategy#filter' returned 'null'.`);
      return [];
    }
    const promises = [];
    const finishedData = this.hydrateModuleData(root, data);
    for await (const Ctor of this.strategy.load(this, finishedData)) {
      promises.push(this.insert(this.construct(Ctor, finishedData)));
    }
    return Promise.all(promises);
  }
  /**
   * Unloads a piece given its instance or its name.
   * @param name The name of the file to load.
   * @return Returns the piece that was unloaded.
   */
  async unload(name) {
    const piece = this.resolve(name);
    this.strategy.onUnload(this, piece);
    await piece.onUnload();
    _Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Unloaded piece '${piece.name}'.`);
    this.delete(piece.name);
    _Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Removed piece '${piece.name}'.`);
    return piece;
  }
  /**
   * Unloads all pieces from the store.
   */
  async unloadAll() {
    const promises = [];
    for (const piece of this.values()) {
      promises.push(this.unload(piece));
    }
    const results = await Promise.all(promises);
    this.strategy.onUnloadAll(this);
    _Store.logger?.(`[STORE => ${this.name}] [UNLOAD-ALL] Removed all pieces.`);
    return results;
  }
  /**
   * Loads all pieces from all directories specified by {@link paths}.
   */
  async loadAll() {
    __privateSet(this, _calledLoadAll, true);
    const pieces = [];
    for (const entry of this[constants_cjs.ManuallyRegisteredPiecesSymbol].values()) {
      const piece = this.construct(entry.piece, {
        name: entry.name,
        root: constants_cjs.VirtualPath,
        path: constants_cjs.VirtualPath,
        extension: constants_cjs.VirtualPath
      });
      pieces.push(piece);
    }
    for (const path of this.paths) {
      for await (const piece of this.loadPath(path)) {
        pieces.push(piece);
      }
    }
    _Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Found '${pieces.length}' pieces.`);
    await this.unloadAll();
    _Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Cleared all pieces.`);
    for (const piece of pieces) {
      await this.insert(piece);
    }
    this.strategy.onLoadAll(this);
    _Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Successfully loaded '${this.size}' pieces.`);
  }
  /**
   * Resolves a piece by its name or its instance.
   * @param name The name of the piece or the instance itself.
   * @return The resolved piece.
   */
  resolve(name) {
    if (typeof name === "string") {
      const result = this.get(name);
      if (typeof result === "undefined")
        throw new LoaderError_cjs.LoaderError(LoaderError_cjs.LoaderErrorType.UnloadedPiece, `The piece '${name}' does not exist.`);
      return result;
    }
    if (name instanceof this.Constructor)
      return name;
    throw new LoaderError_cjs.LoaderError(LoaderError_cjs.LoaderErrorType.IncorrectType, `The piece '${name.name}' is not an instance of '${this.Constructor.name}'.`);
  }
  /**
   * Inserts a piece into the store.
   * @param piece The piece to be inserted into the store.
   * @return The inserted piece.
   */
  async insert(piece) {
    if (!piece.enabled)
      return piece;
    this.strategy.onLoad(this, piece);
    await piece.onLoad();
    _Store.logger?.(`[STORE => ${this.name}] [INSERT] Loaded new piece '${piece.name}'.`);
    if (!piece.enabled) {
      this.strategy.onUnload(this, piece);
      await piece.onUnload();
      _Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded new piece '${piece.name}' due to 'enabled' being 'false'.`);
      return piece;
    }
    const previous = super.get(piece.name);
    if (previous) {
      await this.unload(previous);
      _Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded existing piece '${piece.name}' due to conflicting 'name'.`);
    }
    this.set(piece.name, piece);
    _Store.logger?.(`[STORE => ${this.name}] [INSERT] Inserted new piece '${piece.name}'.`);
    return piece;
  }
  /**
   * Constructs a {@link Piece} instance.
   * @param Ctor The {@link Piece}'s constructor used to build the instance.
   * @param data The module's information
   * @return An instance of the constructed piece.
   */
  construct(Ctor, data) {
    return new Ctor({ store: this, root: data.root, path: data.path, name: data.name }, { name: data.name, enabled: true });
  }
  /**
   * Adds the final module data properties.
   * @param root The root directory to add.
   * @param data The module data returned from {@link ILoaderStrategy.filter}.
   * @returns The finished module data.
   */
  hydrateModuleData(root, data) {
    return { root, ...data };
  }
  /**
   * Loads a directory into the store.
   * @param root The directory to load the pieces from.
   * @return An async iterator that yields the pieces to be loaded into the store.
   */
  async *loadPath(root) {
    _Store.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${root}'.`);
    for await (const child of __privateGet(this, _walk).call(this, this, root, _Store.logger)) {
      const data = this.strategy.filter(child);
      if (data === null) {
        _Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${child}' as 'LoaderStrategy#filter' returned 'null'.`);
        continue;
      }
      try {
        const finishedData = this.hydrateModuleData(root, data);
        for await (const Ctor of this.strategy.load(this, finishedData)) {
          yield this.construct(Ctor, finishedData);
        }
      } catch (error) {
        this.strategy.onError(error, data.path);
      }
    }
  }
};
_a = constants_cjs.ManuallyRegisteredPiecesSymbol;
_calledLoadAll = new WeakMap();
_walk = new WeakMap();
__name(_Store, "Store");
/**
 * The default strategy, defaults to {@link LoaderStrategy}, which is constructed on demand when a store is constructed,
 * when none was set beforehand.
 */
__publicField(_Store, "defaultStrategy", defaultStrategy);
/**
 * The default logger, defaults to `null`.
 */
__publicField(_Store, "logger", null);
exports.Store = _Store;
((Store2) => {
  Store2.Registry = StoreRegistry_cjs.StoreRegistry;
})(exports.Store || (exports.Store = {}));
//# sourceMappingURL=out.js.map
//# sourceMappingURL=Store.cjs.map