{"version":3,"sources":["../../../../src/lib/structures/AliasStore.ts"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,kBAAkB;AAE3B,SAAS,aAAa;AAMf,IAAM,cAAN,MAAM,oBAAgG,MAAoB;AAAA,EAA1H;AAAA;AAIN;AAAA;AAAA;AAAA,wBAAgB,WAAU,IAAI,WAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpC,IAAI,KAA4B;AAC/C,WAAO,MAAM,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,GAAG;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMgB,IAAI,KAAsB;AACzC,WAAO,MAAM,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,GAAG;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOgB,OAAO,MAA8B;AACpD,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAG/B,eAAW,SAAS,MAAM,SAAS;AAElC,YAAM,aAAa,KAAK,QAAQ,IAAI,KAAK;AACzC,UAAI,eAAe;AAAO,aAAK,QAAQ,OAAO,KAAK;AAAA,IACpD;AAEA,WAAO,MAAM,OAAO,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAsB,OAAO,OAAU;AACtC,eAAW,OAAO,MAAM,SAAS;AAChC,WAAK,QAAQ,IAAI,KAAK,KAAK;AAAA,IAC5B;AAEA,WAAO,MAAM,OAAO,KAAK;AAAA,EAC1B;AACD;AApDiI;AAA1H,IAAM,aAAN","sourcesContent":["import { Collection } from '@discordjs/collection';\nimport type { AliasPiece } from './AliasPiece';\nimport { Store } from './Store';\nimport type { StoreRegistryKey } from './StoreRegistry';\n\n/**\n * The store class which contains {@link AliasPiece}s.\n */\nexport class AliasStore<T extends AliasPiece, StoreName extends StoreRegistryKey = StoreRegistryKey> extends Store<T, StoreName> {\n\t/**\n\t * The aliases referencing to pieces.\n\t */\n\tpublic readonly aliases = new Collection<string, T>();\n\n\t/**\n\t * Looks up the name by the store, falling back to an alias lookup.\n\t * @param key The key to look for.\n\t */\n\tpublic override get(key: string): T | undefined {\n\t\treturn super.get(key) ?? this.aliases.get(key);\n\t}\n\n\t/**\n\t * Checks whether a key is in the store, or is an alias\n\t * @param key The key to check\n\t */\n\tpublic override has(key: string): boolean {\n\t\treturn super.has(key) || this.aliases.has(key);\n\t}\n\n\t/**\n\t * Unloads a piece given its instance or its name, and removes all the aliases.\n\t * @param name The name of the file to load.\n\t * @return Returns the piece that was unloaded.\n\t */\n\tpublic override unload(name: string | T): Promise<T> {\n\t\tconst piece = this.resolve(name);\n\n\t\t// Unload all aliases for the given piece:\n\t\tfor (const alias of piece.aliases) {\n\t\t\t// We don't want to delete aliases that were overriden by another piece:\n\t\t\tconst aliasPiece = this.aliases.get(alias);\n\t\t\tif (aliasPiece === piece) this.aliases.delete(alias);\n\t\t}\n\n\t\treturn super.unload(piece);\n\t}\n\n\t/**\n\t * Inserts a piece into the store, and adds all the aliases.\n\t * @param piece The piece to be inserted into the store.\n\t * @return The inserted piece.\n\t */\n\tpublic override async insert(piece: T) {\n\t\tfor (const key of piece.aliases) {\n\t\t\tthis.aliases.set(key, piece);\n\t\t}\n\n\t\treturn super.insert(piece);\n\t}\n}\n"]}