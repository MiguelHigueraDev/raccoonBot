{"version":3,"sources":["../../../../src/lib/strategies/LoaderStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { isNullish, type Awaitable } from '@sapphire/utilities';\nimport { opendir } from 'fs/promises';\nimport { basename, extname, join } from 'path';\nimport { pathToFileURL } from 'url';\nimport { MissingExportsError } from '../errors/MissingExportsError';\nimport { getRootData } from '../internal/RootScan';\nimport { mjsImport } from '../internal/internal';\nimport type { Piece } from '../structures/Piece';\nimport type { Store, StoreLogger } from '../structures/Store';\nimport type {\n\tAsyncPreloadResult,\n\tFilterResult,\n\tHydratedModuleData,\n\tILoaderResult,\n\tILoaderResultEntry,\n\tILoaderStrategy,\n\tModuleData\n} from './ILoaderStrategy';\nimport { classExtends, isClass } from './Shared';\n\n/**\n * A multi-purpose feature-complete loader strategy supporting multi-piece modules as well as supporting both ECMAScript\n * Modules and CommonJS with reloading support.\n */\nexport class LoaderStrategy<T extends Piece> implements ILoaderStrategy<T> {\n\tpublic clientUsesESModules = getRootData().type === 'ESM';\n\tpublic supportedExtensions = ['.js', '.cjs', '.mjs'];\n\tprivate readonly filterDtsFiles: boolean = false;\n\n\tpublic constructor() {\n\t\t/**\n\t\t *\n\t\t * Under various conditions we need to support loading TypeScript files. These conditions are:\n\t\t *\n\t\t * - {@linkplain https://github.com/TypeStrong/ts-node `ts-node`} is being used.\n\t\t * - {@linkplain https://github.com/wclr/ts-node-dev `ts-node-dev`} is being used.\n\t\t * - {@linkplain https://deno.com `Deno`} is being used.\n\t\t * - {@linkplain https://bun.sh `bun`} is being used.\n\t\t *\n\t\t * Each of these packages and runtimes support loading TypeScript files directly and do not need to be compiled\n\t\t * to JavaScript first.\n\t\t */\n\t\tconst shouldLoadTsFiles =\n\t\t\tReflect.has(process, Symbol.for('ts-node.register.instance')) || // ts-node support\n\t\t\tReflect.has(globalThis, 'Deno') || // Deno support\n\t\t\t!isNullish(process.env.TS_NODE_DEV) || // ts-node-dev support\n\t\t\t'bun' in process.versions; // bun support\n\n\t\tif (shouldLoadTsFiles) {\n\t\t\tthis.supportedExtensions.push('.ts', '.cts', '.mts');\n\t\t\tthis.filterDtsFiles = true;\n\t\t}\n\t}\n\n\tpublic filter(path: string): FilterResult {\n\t\t// Retrieve the file extension.\n\t\tconst extension = extname(path);\n\t\tif (!this.supportedExtensions.includes(extension)) return null;\n\n\t\tif (this.filterDtsFiles && path.endsWith('.d.ts')) return null;\n\n\t\t// Retrieve the name of the file, return null if empty.\n\t\tconst name = basename(path, extension);\n\t\tif (name === '' || name.startsWith('_')) return null;\n\n\t\t// Return the name and extension.\n\t\treturn { extension, path, name };\n\t}\n\n\tpublic async preload(file: ModuleData): AsyncPreloadResult<T> {\n\t\tconst mjs = ['.mjs', '.mts'].includes(file.extension) || (['.js', '.ts'].includes(file.extension) && this.clientUsesESModules);\n\t\tif (mjs) {\n\t\t\tconst url = pathToFileURL(file.path);\n\t\t\turl.searchParams.append('d', Date.now().toString());\n\t\t\turl.searchParams.append('name', file.name);\n\t\t\turl.searchParams.append('extension', file.extension);\n\t\t\treturn mjsImport(url);\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n\t\tconst mod = require(file.path);\n\t\tdelete require.cache[require.resolve(file.path)];\n\t\treturn mod;\n\t}\n\n\tpublic async *load(store: Store<T>, file: HydratedModuleData): ILoaderResult<T> {\n\t\tlet yielded = false;\n\t\tconst result = await this.preload(file);\n\n\t\t// Support `module.exports`:\n\t\tif (isClass(result) && classExtends(result, store.Constructor)) {\n\t\t\tyield result;\n\t\t\tyielded = true;\n\t\t}\n\n\t\t// Support any other export:\n\t\tfor (const value of Object.values(result)) {\n\t\t\tif (isClass(value) && classExtends(value, store.Constructor)) {\n\t\t\t\tyield value as ILoaderResultEntry<T>;\n\t\t\t\tyielded = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!yielded) {\n\t\t\tthrow new MissingExportsError(file.path);\n\t\t}\n\t}\n\n\tpublic onLoad(store: Store<T>, piece: T): Awaitable<unknown>;\n\tpublic onLoad(): unknown {\n\t\treturn undefined;\n\t}\n\n\tpublic onLoadAll(store: Store<T>): Awaitable<unknown>;\n\tpublic onLoadAll(): unknown {\n\t\treturn undefined;\n\t}\n\n\tpublic onUnload(store: Store<T>, piece: T): Awaitable<unknown>;\n\tpublic onUnload(): unknown {\n\t\treturn undefined;\n\t}\n\n\tpublic onUnloadAll(store: Store<T>): Awaitable<unknown>;\n\tpublic onUnloadAll(): unknown {\n\t\treturn undefined;\n\t}\n\n\tpublic onError(error: Error, path: string): void {\n\t\tconsole.error(`Error when loading '${path}':`, error);\n\t}\n\n\tpublic async *walk(store: Store<T>, path: string, logger?: StoreLogger | null): AsyncIterableIterator<string> {\n\t\tlogger?.(`[STORE => ${store.name}] [WALK] Loading all pieces from '${path}'.`);\n\t\ttry {\n\t\t\tconst dir = await opendir(path);\n\t\t\tfor await (const item of dir) {\n\t\t\t\tif (item.isFile()) yield join(dir.path, item.name);\n\t\t\t\telse if (item.isDirectory()) yield* this.walk(store, join(dir.path, item.name), logger);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Specifically ignore ENOENT, which is commonly raised by fs operations\n\t\t\t// to indicate that a component of the specified pathname does not exist.\n\t\t\t// No entity (file or directory) could be found by the given path.\n\t\t\tif ((error as ErrorWithCode).code !== 'ENOENT') this.onError(error as Error, path);\n\t\t}\n\t}\n}\n\ntype ErrorWithCode = Error & { code: string };\n"]}