import { __name, __publicField, __require } from '../../chunk-LIQV5WSN.mjs';
import { isNullish } from '@sapphire/utilities';
import { opendir } from 'fs/promises';
import { extname, basename, join } from 'path';
import { pathToFileURL } from 'url';
import { MissingExportsError } from '../errors/MissingExportsError.mjs';
import { getRootData } from '../internal/RootScan.mjs';
import { mjsImport } from '../internal/internal.mjs';
import { isClass, classExtends } from './Shared.mjs';

var _LoaderStrategy = class _LoaderStrategy {
  constructor() {
    __publicField(this, "clientUsesESModules", getRootData().type === "ESM");
    __publicField(this, "supportedExtensions", [".js", ".cjs", ".mjs"]);
    __publicField(this, "filterDtsFiles", false);
    const shouldLoadTsFiles = Reflect.has(process, Symbol.for("ts-node.register.instance")) || // ts-node support
    Reflect.has(globalThis, "Deno") || // Deno support
    !isNullish(process.env.TS_NODE_DEV) || // ts-node-dev support
    "bun" in process.versions;
    if (shouldLoadTsFiles) {
      this.supportedExtensions.push(".ts", ".cts", ".mts");
      this.filterDtsFiles = true;
    }
  }
  filter(path) {
    const extension = extname(path);
    if (!this.supportedExtensions.includes(extension))
      return null;
    if (this.filterDtsFiles && path.endsWith(".d.ts"))
      return null;
    const name = basename(path, extension);
    if (name === "" || name.startsWith("_"))
      return null;
    return { extension, path, name };
  }
  async preload(file) {
    const mjs = [".mjs", ".mts"].includes(file.extension) || [".js", ".ts"].includes(file.extension) && this.clientUsesESModules;
    if (mjs) {
      const url = pathToFileURL(file.path);
      url.searchParams.append("d", Date.now().toString());
      url.searchParams.append("name", file.name);
      url.searchParams.append("extension", file.extension);
      return mjsImport(url);
    }
    const mod = __require(file.path);
    delete __require.cache[__require.resolve(file.path)];
    return mod;
  }
  async *load(store, file) {
    let yielded = false;
    const result = await this.preload(file);
    if (isClass(result) && classExtends(result, store.Constructor)) {
      yield result;
      yielded = true;
    }
    for (const value of Object.values(result)) {
      if (isClass(value) && classExtends(value, store.Constructor)) {
        yield value;
        yielded = true;
      }
    }
    if (!yielded) {
      throw new MissingExportsError(file.path);
    }
  }
  onLoad() {
    return void 0;
  }
  onLoadAll() {
    return void 0;
  }
  onUnload() {
    return void 0;
  }
  onUnloadAll() {
    return void 0;
  }
  onError(error, path) {
    console.error(`Error when loading '${path}':`, error);
  }
  async *walk(store, path, logger) {
    logger?.(`[STORE => ${store.name}] [WALK] Loading all pieces from '${path}'.`);
    try {
      const dir = await opendir(path);
      for await (const item of dir) {
        if (item.isFile())
          yield join(dir.path, item.name);
        else if (item.isDirectory())
          yield* this.walk(store, join(dir.path, item.name), logger);
      }
    } catch (error) {
      if (error.code !== "ENOENT")
        this.onError(error, path);
    }
  }
};
__name(_LoaderStrategy, "LoaderStrategy");
var LoaderStrategy = _LoaderStrategy;

export { LoaderStrategy };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=LoaderStrategy.mjs.map