import { __name, __privateAdd, __privateGet } from '../../chunk-LIQV5WSN.mjs';
import { Collection } from '@discordjs/collection';
import { isClass } from '@sapphire/utilities';
import { join } from 'path';
import '../errors/LoaderError.mjs';
import { resolvePath } from '../internal/Path.mjs';
import { getRootData } from '../internal/RootScan.mjs';
import { ManuallyRegisteredPiecesSymbol } from '../internal/constants.mjs';

var _pendingManuallyRegisteredPieces;
var _StoreRegistry = class _StoreRegistry extends Collection {
  constructor() {
    super(...arguments);
    /**
     * The queue of pieces to load.
     */
    __privateAdd(this, _pendingManuallyRegisteredPieces, new Collection());
  }
  /**
   * Loads all the registered stores.
   * @since 2.1.0
   */
  async load() {
    const promises = [];
    for (const store of this.values()) {
      promises.push(store.loadAll());
    }
    await Promise.all(promises);
  }
  /**
   * Registers all user directories from the process working directory, the default value is obtained by assuming
   * CommonJS (high accuracy) but with fallback for ECMAScript Modules (reads package.json's `main` entry, fallbacks
   * to `process.cwd()`).
   *
   * By default, if you have this folder structure:
   * ```
   * /home/me/my-bot
   * ├─ src
   * │  ├─ commands
   * │  ├─ events
   * │  └─ main.js
   * └─ package.json
   * ```
   *
   * And you run `node src/main.js`, the directories `/home/me/my-bot/src/commands` and `/home/me/my-bot/src/events` will
   * be registered for the commands and events stores respectively, since both directories are located in the same
   * directory as your main file.
   *
   * **Note**: this also registers directories for all other stores, even if they don't have a folder, this allows you
   * to create new pieces and hot-load them later anytime.
   * @since 2.1.0
   * @param rootDirectory The root directory to register pieces at.
   */
  registerPath(rootDirectory = getRootData().root) {
    const root = resolvePath(rootDirectory);
    for (const store of this.values()) {
      store.registerPath(join(root, store.name));
    }
  }
  /**
   * Registers a store.
   *
   * @remarks
   *
   * - This method will allow {@linkcode StoreRegistry} to manage the store, meaning:
   *   - {@linkcode StoreRegistry.registerPath()} will call the store's
   *     {@linkcode Store.registerPath() registerPath()} method on call.
   *   - {@linkcode StoreRegistry.load()} will call the store's {@linkcode Store.load() load()} method on call.
   *   - {@linkcode StoreRegistry.loadPiece()} will call the store's {@linkcode Store.loadPiece() loadPiece()} method
   *     on call.
   * - This will also add all the manually registered pieces by {@linkcode StoreRegistry.loadPiece()} in the store.
   *
   * It is generally recommended to register a store as early as possible, before any of the aforementioned methods
   * are called, otherwise you will have to manually call the aforementioned methods for the store to work properly.
   *
   * If there were manually registered pieces for this store with {@linkcode StoreRegistry.loadPiece()}, this method
   * will add them to the store and delete the queue. Note, however, that this method will not call the store's
   * {@linkcode Store.loadPiece() loadPiece()} method, and as such, the pieces will not be loaded until
   * {@linkcode Store.loadAll()} is called.
   *
   * @since 2.1.0
   * @param store The store to register.
   */
  register(store) {
    this.set(store.name, store);
    const queue = __privateGet(this, _pendingManuallyRegisteredPieces).get(store.name);
    if (queue) {
      for (const entry of queue) {
        store[ManuallyRegisteredPiecesSymbol].set(entry.name, entry);
      }
      __privateGet(this, _pendingManuallyRegisteredPieces).delete(store.name);
    }
    return this;
  }
  /**
   * Deregisters a store.
   * @since 2.1.0
   * @param store The store to deregister.
   */
  deregister(store) {
    this.delete(store.name);
    return this;
  }
  /**
   * If the store was {@link StoreRegistry.register registered}, this method will call the store's
   * {@linkcode Store.loadPiece() loadPiece()} method.
   *
   * If it was called, the entry will be loaded immediately without queueing.
   *
   * @remarks
   *
   * - Pieces loaded this way will have their {@linkcode Piece.Context.root root} and
   *   {@linkcode Piece.Context.path path} set to {@linkcode VirtualPath}, and as such, cannot be reloaded.
   * - This method is useful in environments where file system access is limited or unavailable, such as when using
   *   {@link https://en.wikipedia.org/wiki/Serverless_computing Serverless Computing}.
   * - This method will not throw an error if a store with the given name does not exist, it will simply be queued
   *   until it's registered.
   * - This method will always throw a {@link TypeError} if `entry.piece` is not a class.
   * - If the store is registered, this method will always throw a {@linkcode LoaderError} if the piece does not
   *   extend the registered {@linkcode Store.Constructor store's piece constructor}.
   * - This operation is atomic, if any of the above errors are thrown, the piece will not be loaded.
   *
   * @seealso {@linkcode Store.loadPiece()}
   * @since 3.8.0
   * @param entry The entry to load.
   * @example
   * ```typescript
   * import { container } from '@sapphire/pieces';
   *
   * class PingCommand extends Command {
   *   // ...
   * }
   *
   * container.stores.loadPiece({
   *   store: 'commands',
   *   name: 'ping',
   *   piece: PingCommand
   * });
   * ```
   */
  async loadPiece(entry) {
    const store = this.get(entry.store);
    if (store) {
      await store.loadPiece(entry);
    } else {
      if (!isClass(entry.piece)) {
        throw new TypeError(`The piece ${entry.name} is not a Class. ${String(entry.piece)}`);
      }
      __privateGet(this, _pendingManuallyRegisteredPieces).ensure(entry.store, () => []).push({ name: entry.name, piece: entry.piece });
    }
  }
};
_pendingManuallyRegisteredPieces = new WeakMap();
__name(_StoreRegistry, "StoreRegistry");
var StoreRegistry = _StoreRegistry;

export { StoreRegistry };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=StoreRegistry.mjs.map