type Awaitable<T> = PromiseLike<T> | T;

/**
 * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a
 * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error
 * and containing an error value.
 *
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 *
 * @see {@link https://doc.rust-lang.org/std/result/index.html}
 */
interface IResult<T, E> {
    /**
     * Returns `true` if the result is `Ok`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isOk(), true);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isOk(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}
     */
    isOk(): this is ResultOk<T>;
    /**
     * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.isOkAnd((value) => value > 1), true);
     * ```
     * @example
     * ```typescript
     * const x = ok(0);
     * assert.equal(x.isOkAnd((value) => value > 1), false);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isOkAnd((value) => value > 1), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}
     */
    isOkAnd<R extends boolean>(cb: (value: T) => R): this is ResultOk<T> & R;
    /**
     * Returns `true` if the result is `Err`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isErr(), false);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isErr(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}
     */
    isErr(): this is ResultErr<E>;
    /**
     * Returns `true` if the result is `Err` and the value inside of it matches a predicate.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);
     * ```
     * @example
     * ```typescript
     * const x = err(new Error('Some error message'));
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);
     * ```
     * @example
     * ```typescript
     * const x = err(new TypeError('Some error message'));
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}
     */
    isErrAnd<R extends boolean>(cb: (error: E) => R): this is ResultErr<E> & R;
    /**
     * Converts from `Result<T, E>` to `Option<T>`.
     *
     * Converts itself into an `Option<T>`, and discarding the error, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.ok(), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.ok(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}
     */
    ok(): Option<T>;
    /**
     * Converts from `Result<T, E>` to `Option<E>`.
     *
     * Converts itself into an `Option<E>`, and discarding the successful value, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.err(), none);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.err(), 'Some error message');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}
     */
    err(): Option<E>;
    /**
     * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.map((value) => value * 2), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.map((value) => value * 2), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}
     */
    map<U>(cb: (value: T) => U): Result<U, E>;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     *
     * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(0);
     * assert.equal(
     *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),
     *   err('zero is not divisible')
     * );
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto<IT, IE>(cb: (value: T) => Result<IT, IE>): Result<IT, E | IE>;
    /**
     * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use `mapOrElse`, which is lazily evaluated.
     * @param defaultValue The default value to use.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x = ok('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}
     */
    mapOr<U>(defaultValue: U, cb: (value: T) => U): U;
    /**
     * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`
     * to a contained `Ok` value.
     *
     * This function can be used to unpack a successful result while handling an error.
     * @param op The predicate that is run on `Err`.
     * @param cb The predicate that is run on `Ok`.
     *
     * @example
     * ```typescript
     * const x: Result<string, string> = ok('hello');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Result<string, string> = err('Some error message');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}
     */
    mapOrElse<U>(op: (error: E) => U, cb: (value: T) => U): U;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErr((error) => error.message), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErr((error) => error.message), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}
     */
    mapErr<F>(cb: (error: E) => F): Result<T, F>;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     *
     * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapErrInto<IT, IE>(cb: (error: E) => Result<IT, IE>): Result<T | IT, IE>;
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}
     */
    inspect(cb: (value: T) => void): this;
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectAsync(cb: (value: T) => Awaitable<void>): Promise<this>;
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`).
     * @param cb The predicate.
     * @seealso {@link inspectErrAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspectErr(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspectErr(console.log);
     * // Logs: Some error message
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}
     */
    inspectErr(cb: (error: E) => void): this;
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspectErr} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectErrAsync(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectErrAsync(console.log);
     * // Logs: Some error message
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectErrAsync(cb: (error: E) => Awaitable<void>): Promise<this>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    iter(): Generator<T>;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}
     */
    expect(message: string): T;
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.expectErr('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}
     */
    expectErr(message: string): E;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrap(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}
     */
    unwrap(): T;
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.unwrapErr(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.unwrapErr(), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}
     */
    unwrapErr(): E;
    /**
     * Returns the contained `Ok` value or the provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param defaultValue The default value.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(9);
     * assert.equal(x.unwrapOr(2), 9);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Error');
     * assert.equal(x.unwrapOr(2), 2);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}
     */
    unwrapOr<V>(defaultValue: V): T | V;
    /**
     * Returns the contained `Ok` value or computes it from a closure.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param op The predicate.
     *
     * @example
     * ```typescript
     * const count = (x: string) => x.length;
     *
     * assert.equal(ok(2).unwrapOrElse(count), 2);
     * assert.equal(err('hello').unwrapOrElse(count), 5);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}
     */
    unwrapOrElse<V>(op: (error: E) => V): T | V;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws the contained error.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrapRaw(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrapRaw(), {
     *   name: 'Error',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     */
    unwrapRaw(): T | never;
    /**
     * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Early error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = ok('Hello');
     * assert.equal(x.and(y), ok('Hello'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}
     */
    and<U>(result: Result<U, E>): Result<U, E>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? err('overflowed') : ok(4 / value);
     * }
     *
     * assert.equal(ok(2).andThen(fractionOf4), ok(4));
     * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));
     * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen<U>(cb: (value: T) => Result<U, E>): Result<U, E>;
    /**
     * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended
     * to use {@link orElse}, which is lazily evaluated.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = ok(2);
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = ok(100);
     * assert.equal(x.or(y), ok(2));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}
     */
    or<F>(result: Result<T, F>): Result<T, F>;
    /**
     * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * This function can be used for control flow based on result values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const square = (x: number): Result<number, string> => ok(x * x);
     * const wrapErr = (x: number): Result<number, string> => err(x);
     *
     * assert.equal(ok(2).orElse(square).orElse(square), ok(2));
     * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));
     * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));
     * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}
     */
    orElse<F>(cb: (error: E) => Result<T, F>): Result<T, F>;
    /**
     * Returns `true` if the result is an `Ok` and the given value strict equals it.
     * @param value The value to compare.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.contains(2), true);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(3);
     * assert.equal(x.contains(2), false);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.contains(2), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}
     */
    contains(value: T): boolean;
    /**
     * Returns `true` if the result is an `Err` and the given error strict equals it.
     * @param error The error to compare.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.containsErr('Some error message'), false);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.containsErr('Some error message'), true);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some other error message');
     * assert.equal(x.containsErr('Some error message'), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}
     */
    containsErr(error: E): boolean;
    /**
     * Transposes a `Result` of an `Option` into an `Option` of a `Result`.
     *
     * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.
     *
     * @example
     * ```typescript
     * const x: Result<Option<number>, Error> = ok(some(5));
     * const y: Option<Result<number, Error>> = some(ok(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}
     */
    transpose<IT>(this: Result<Option<IT>, E>): Option<Result<IT, E>>;
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(ok('Hello'));
     * assert.equal(x.flatten(), ok('Hello'));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(err(6));
     * assert.equal(x.flatten(), err(6));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = err(6);
     * assert.equal(x.flatten(), err(6));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten<IT>(this: Result<Result<IT, E>, E>): Result<IT, E>;
    /**
     * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.
     *
     * @example
     * ```typescript
     * let x: Result<number, number> = ok(3);
     * assert.equal(x.intoOkOrErr(), 3);
     * ```
     * @example
     * ```typescript
     * let x: Result<number, number> = err(4);
     * assert.equal(x.intoOkOrErr(), 4);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}
     */
    intoOkOrErr(): T | E;
    /**
     * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).
     *
     * @example
     * ```typescript
     * let x = ok(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), ok(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise(): Promise<Result<Awaited<T>, Awaited<E>>>;
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq(other: Result<T, E>): boolean;
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other: Result<T, E>): boolean;
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const result = ok(4).match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 4);
     * ```
     * @example
     * ```typescript
     * const result = err('Hello').match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 0);
     * ```
     */
    match<OkValue, ErrValue>(branches: {
        ok(value: T): OkValue;
        err(error: E): ErrValue;
    }): OkValue | ErrValue;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IResult.iter}
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    [Symbol.iterator](): Generator<T>;
}

declare class ResultOk<T> implements IResult<T, any> {
    private readonly value;
    constructor(value: T);
    isOk(): this is ResultOk<T>;
    isOkAnd<R extends boolean>(cb: (value: T) => R): R;
    isErr(): false;
    isErrAnd(cb?: (error: never) => boolean): false;
    ok(): OptionSome<T>;
    err(): OptionNone;
    map<U>(cb: (value: T) => U): ResultOk<U>;
    mapInto<R extends Result<any, any>>(cb: (value: T) => R): R;
    mapOr<U>(_: U, cb: (value: T) => U): U;
    mapOrElse<U>(_: (error: never) => U, cb: (value: T) => U): U;
    mapErr(cb?: (error: never) => any): this;
    mapErrInto(cb: (error: never) => Result<any, any>): this;
    inspect(cb: (value: T) => void): this;
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    inspectErr(cb?: (error: never) => void): this;
    inspectErrAsync(cb?: (error: never) => Awaitable<unknown>): Promise<this>;
    iter(): Generator<T>;
    expect(message?: string): T;
    expectErr(message: string): never;
    unwrap(): T;
    unwrapErr(): never;
    unwrapOr(defaultValue: unknown): T;
    unwrapOrElse(op: (error: any) => unknown): T;
    unwrapRaw(): T;
    and<R extends Result<any, any>>(result: R): R;
    andThen<R extends Result<any, any>>(cb: (value: T) => R): R;
    or(result: Result<T, any>): this;
    orElse(cb: (error: never) => Result<T, any>): this;
    contains(value: T): boolean;
    containsErr(error?: unknown): false;
    transpose(this: ResultOk<OptionNone>): OptionNone;
    transpose<Inner>(this: ResultOk<OptionSome<Inner>>): OptionSome<ResultOk<Inner>>;
    transpose<Inner>(this: ResultOk<Option<Inner>>): Option<ResultOk<Inner>>;
    flatten<Inner extends Result<any, any>>(this: ResultOk<Inner>): Inner;
    intoOkOrErr(): T;
    intoPromise(): Promise<ResultOk<Awaited<T>>>;
    eq(other: ResultErr<any>): false;
    eq(other: Result<T, any>): boolean;
    ne(other: ResultErr<any>): true;
    ne(other: Result<T, any>): boolean;
    match<OkValue, ErrValue>(branches: {
        ok(value: T): OkValue;
        err(error: never): ErrValue;
    }): OkValue;
    [Symbol.iterator](): Generator<T>;
}
/**
 * Creates an Ok with no value.
 * @return A successful Result.
 */
declare function createOk(): ResultOk<unknown>;
/**
 * Creates an Ok.
 * @typeparam T The result's type.
 * @param x Value to use.
 * @return A successful Result.
 */
declare function createOk<T>(x: T): ResultOk<T>;

declare class ResultError<E> extends Error {
    readonly value: E;
    constructor(message: string, value: E);
    get name(): string;
}

/**
 * The union of the two variations of `Result`.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
type Result<T, E> = Result.Ok<T> | Result.Err<E>;
declare namespace Result {
    type Resolvable<T, E> = T | Result<T, E>;
    function is<T, E>(value: Result<T, E>): true;
    function is(value: any): value is Result<unknown, unknown>;
    /**
     * Creates a {@link Result} out of a callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E>;
    /**
     * Creates a {@link Result} out of a promise or async callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>>;
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    function all<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>, UnwrapErrArray<T>[number]>;
    /**
     * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    function any<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>[number], UnwrapErrArray<T>>;
    const err: typeof createErr;
    const ok: typeof createOk;
    type Err<E> = ResultErr<E>;
    type Ok<T> = ResultOk<T>;
    type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;
    type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;
    type UnwrapOkArray<T extends readonly Result<any, any>[] | []> = {
        -readonly [P in keyof T]: UnwrapOk<T[P]>;
    };
    type UnwrapErrArray<T extends readonly Result<any, any>[] | []> = {
        -readonly [P in keyof T]: UnwrapErr<T[P]>;
    };
}

interface IOption<T> {
    /**
     * Returns `true` if the option is a `Some` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isSome(), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isSome(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}
     */
    isSome(): this is OptionSome<T>;
    /**
     * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isSomeAnd((x) => x > 1), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(0);
     * assert.equal(x.isSomeAnd((x) => x > 1), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isSomeAnd((x) => x > 1), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}
     */
    isSomeAnd(cb: (value: T) => boolean): boolean;
    /**
     * Returns `true` if the option is a `None` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isNone(), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isNone(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}
     */
    isNone(): this is OptionNone;
    /**
     * Returns the contained `Some` value.
     * @param message The message for the error.
     * If the value is an `Err`, it throws an {@link OptionError} with the given message.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'OptionError',
     *   message: 'Whoops'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}
     */
    expect(message: string): T;
    /**
     * Returns the contained `Some` value.
     *
     * If the value is an `Err`, it throws an {@link OptionError} with the message.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.unwrap(), {
     *   name: 'OptionError',
     *   message: 'Unwrap failed'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}
     */
    unwrap(): T;
    /**
     * Returns the contained `Some` value or a provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOr(0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOr(0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}
     */
    unwrapOr<V>(defaultValue: V): T | V;
    /**
     * Returns the contained Some value or computes it from a closure.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOrElse(() => 0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOrElse(() => 0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}
     */
    unwrapOrElse<V>(cb: () => V): T | V;
    /**
     * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const maybeSomeString = some('Hello, world!');
     * const maybeSomeLength = maybeSomeString.map((value) => value.length);
     *
     * assert.equal(maybeSomeLength, some(13));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}
     */
    map<U>(cb: (value: T) => U): Option<U>;
    /**
     * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, some(13));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, none);
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto<Inner>(cb: (value: T) => Option<Inner>): Option<Inner>;
    /**
     * Returns the provided default result (if none), or applies a function to the contained value (if any).
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link mapOrElse}, which is lazily evaluated.
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}
     */
    mapOr<U>(defaultValue: U, cb: (value: T) => U): U;
    /**
     * Computes a default function result (if none), or applies a different function to the contained value (if any).
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}
     */
    mapOrElse<U>(defaultValue: () => U, cb: (value: T) => U): U;
    /**
     * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some('Hello, world!'));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some(13));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapNoneInto<Inner>(cb: () => Option<Inner>): Option<T | Inner>;
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * some(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * none.inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}
     */
    inspect(cb: (value: T) => void): this;
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await some(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await none.inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectAsync(cb: (value: T) => Awaitable<void>): Promise<this>;
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.
     *
     * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link okOrElse}, which is lazily evaluated.
     * @param err The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOr(0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOr(0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}
     */
    okOr<E>(err: E): Result<T, E>;
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.
     * @param cb The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOrElse(() => 0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOrElse(() => 0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}
     */
    okOrElse<E>(cb: () => E): Result<T, E>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link Option.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    iter(): Generator<T>;
    /**
     * Returns `None` if the option is `None`, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), some('foo'));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}
     */
    and<U>(option: Option<U>): Option<U>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? none : some(4 / value);
     * }
     *
     * assert.equal(some(2).andThen(fractionOf4), some(4));
     * assert.equal(some(0).andThen(fractionOf4), none);
     * assert.equal(none.andThen(fractionOf4), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen<U>(cb: (value: T) => Option<U>): Option<U>;
    /**
     * Returns the option if it contains a value, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(100));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.or(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}
     */
    or(option: Option<T>): Option<T>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const nobody = (): Option<string> => none;
     * const vikings = (): Option<string> => some('vikings');
     *
     * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));
     * assert.equal(none.orElse(vikings), some('vikings'));
     * assert.equal(none.orElse(nobody), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}
     */
    orElse(cb: () => Option<T>): Option<T>;
    /**
     * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.
     * @param option The option to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}
     */
    xor(option: Option<T>): Option<T>;
    /**
     * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:
     *
     * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and
     * - `None` if `predicate` returns `false`.
     * @param predicate The predicate.
     *
     * @example
     * ```typescript
     * function isEven(value: number) {
     *   return n % 2 === 0;
     * }
     *
     * assert.equal(none.filter(isEven), none);
     * assert.equal(some(3).filter(isEven), none);
     * assert.equal(some(4).filter(isEven), some(4));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}
     */
    filter(predicate: (value: T) => boolean): Option<T>;
    /**
     * Returns `true` if the option is a `Some` value containing the given value.
     * @param value The value to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.contains(2), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(3);
     * assert.equal(x.contains(2), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.contains(2), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}
     */
    contains(value: T): boolean;
    /**
     * Zips self with another `Option`.
     *
     * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     *
     * @example
     * ```typescript
     * const x = some(1);
     * const y = some('hi');
     * const z = none;
     *
     * assert.equal(x.zip(y), some([1, 'hi']));
     * assert.equal(x.zip(z), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}
     */
    zip<U>(other: Option<U>): Option<[T, U]>;
    /**
     * Zips self and another `Option` with function `f`.
     *
     * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     * @param f The function that computes the returned value.
     *
     * @example
     * ```typescript
     * class Point {
     *   public readonly x: number;
     *   public readonly y: number;
     *
     *   public constructor(x: number, y: number) {
     *     this.x = x;
     *     this.y = y;
     *   }
     * }
     *
     * const x = some(17.5);
     * const y = some(42.7);
     *
     * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));
     * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}
     */
    zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;
    /**
     * Unzips an option containing a tuple of two options.
     *
     * If self is `Some((a, b))` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.
     *
     * @example
     * ```typescript
     * const x: Option<[number, string]> = some([1, 'hi']);
     * assert.equal(x.unzip(), [some(1), some('hi')]);
     * ```
     * @example
     * ```typescript
     * const x: Option<[number, string]> = none;
     * assert.equal(x.unzip(), [none, none]);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}
     */
    unzip<Inner, U>(this: Option<readonly [Inner, U]>): [Option<Inner>, Option<U>];
    /**
     * Transposes an `Option` of a `Result` into a `Result` of an `Option`.
     *
     * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.
     *
     * @example
     * ```typescript
     * const x: Option<Result<number, Error>> = some(ok(5));
     * const y: Result<Option<number>, Error> = ok(some(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}
     */
    transpose<IT, E>(this: Option<Result<IT, E>>): Result<Option<IT>, E>;
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(some(6));
     * assert.equal(x.flatten(), some(6));
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(none);
     * assert.equal(x.flatten(), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = none;
     * assert.equal(x.flatten(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten<IT>(this: Option<Option<IT>>): Option<IT>;
    /**
     * Returns a `Promise` object with the awaited value (if `Some`).
     *
     * @example
     * ```typescript
     * let x = some(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), some(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise(): Promise<Option<Awaited<T>>>;
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq(other: Option<T>): boolean;
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other: Option<T>): boolean;
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const option = some(4).match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 4);
     * ```
     * @example
     * ```typescript
     * const option = none.match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 0);
     * ```
     */
    match<SomeValue, NoneValue>(branches: {
        some(value: T): SomeValue;
        none(): NoneValue;
    }): SomeValue | NoneValue;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IOption.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    [Symbol.iterator](): Generator<T>;
}

declare class OptionSome<T> implements IOption<T> {
    private readonly value;
    constructor(value: T);
    isSome(): this is OptionSome<T>;
    isSomeAnd<R extends boolean>(cb: (value: T) => R): R;
    isNone(): false;
    expect(message: string): T;
    unwrap(): T;
    unwrapOr(defaultValue: unknown): T;
    unwrapOrElse(cb: () => unknown): T;
    map<U>(cb: (value: T) => U): OptionSome<U>;
    mapInto<R extends Option<any>>(cb: (value: T) => R): R;
    mapOr<U>(_: U, cb: (value: T) => U): U;
    mapOrElse<U>(_: () => U, cb: (value: T) => U): U;
    mapNoneInto(cb: () => Option<any>): this;
    inspect(cb: (value: T) => void): this;
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    okOr(err?: any): ResultOk<T>;
    okOrElse(cb: () => any): ResultOk<T>;
    iter(): Generator<T>;
    and<R extends Option<any>>(option: R): R;
    andThen<R extends Option<any>>(cb: (value: T) => R): R;
    or(option: Option<any>): this;
    orElse(cb?: () => Option<any>): this;
    xor(option: OptionSome<T>): OptionNone;
    xor(option: OptionNone): this;
    xor(option: Option<T>): this | OptionNone;
    filter(predicate: (value: T) => true): this;
    filter(predicate: (value: T) => false): OptionNone;
    filter(predicate: (value: T) => boolean): this | OptionNone;
    contains(value: T): boolean;
    zip(other: OptionNone): OptionNone;
    zip<U>(other: OptionSome<U>): OptionSome<[T, U]>;
    zip<U>(other: Option<U>): Option<[T, U]>;
    zipWith<U, R>(other: OptionNone, f: (s: T, o: U) => R): OptionNone;
    zipWith<U, R>(other: OptionSome<U>, f: (s: T, o: U) => R): OptionSome<R>;
    zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;
    unzip<I, U>(this: OptionSome<readonly [I, U]>): [OptionSome<I>, OptionSome<U>];
    transpose<Inner>(this: OptionSome<ResultOk<Inner>>): ResultOk<OptionSome<Inner>>;
    transpose<Inner>(this: OptionSome<ResultErr<Inner>>): ResultErr<OptionSome<Inner>>;
    transpose<IT, E>(this: OptionSome<Result<IT, E>>): Result<OptionSome<IT>, E>;
    flatten<Inner extends Option<any>>(this: OptionSome<Inner>): Inner;
    intoPromise(): Promise<OptionSome<Awaited<T>>>;
    eq(other: OptionNone): false;
    eq(other: Option<T>): boolean;
    ne(other: OptionNone): true;
    ne(other: Option<T>): boolean;
    match<SomeValue, NoneValue>(branches: {
        some(value: T): SomeValue;
        none(): NoneValue;
    }): SomeValue;
    [Symbol.iterator](): Generator<T>;
}
declare function createSome<T>(value: T): OptionSome<T>;

declare class ResultErr<E> implements IResult<any, E> {
    private readonly error;
    constructor(error: E);
    isOk(): false;
    isOkAnd(cb?: (value: never) => boolean): false;
    isErr(): this is ResultErr<E>;
    isErrAnd(cb: (error: E) => boolean): boolean;
    ok(): OptionNone;
    err(): OptionSome<E>;
    map(cb?: (value: never) => unknown): this;
    mapInto(cb: (value: never) => Result<any, any>): this;
    mapOr<U>(defaultValue: U, cb?: (value: never) => U): U;
    mapOrElse<U>(op: (error: E) => U, cb?: (value: never) => U): U;
    mapErr<F>(cb: (error: E) => F): ResultErr<F>;
    mapErrInto<R extends Result<any, any>>(cb: (error: E) => R): R;
    inspect(cb?: (value: never) => void): this;
    inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;
    inspectErr(cb: (error: E) => void): this;
    inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this>;
    iter(): Generator<never>;
    expect(message: string): never;
    expectErr(message?: string): E;
    unwrap(): never;
    unwrapErr(): E;
    unwrapOr<T>(defaultValue: T): T;
    unwrapOrElse<T>(op: (error: E) => T): T;
    unwrapRaw(): never;
    and(result?: Result<any, E>): this;
    andThen(cb?: (value: never) => Result<any, E>): this;
    or<R extends Result<any, any>>(result: R): R;
    orElse<R extends Result<any, any>>(cb: (error: E) => R): R;
    contains(value?: any): false;
    containsErr(error: E): boolean;
    transpose(): OptionSome<this>;
    flatten(): this;
    intoOkOrErr(): E;
    intoPromise(): Promise<ResultErr<Awaited<E>>>;
    eq(other: ResultOk<any>): false;
    eq(other: Result<any, E>): boolean;
    ne(other: ResultOk<any>): true;
    ne(other: Result<any, E>): boolean;
    match<OkValue, ErrValue>(branches: {
        ok(value: never): OkValue;
        err(error: E): ErrValue;
    }): ErrValue;
    [Symbol.iterator](): Generator<never>;
}
/**
 * Creates an Err with no error.
 * @return An erroneous Result.
 */
declare function createErr(): ResultErr<unknown>;
/**
 * Creates an Err.
 * @typeparam E The error's type.
 * @param x Value to use.
 * @return An erroneous Result.
 */
declare function createErr<E>(x: E): ResultErr<E>;

declare class OptionNone implements IOption<any> {
    isSome(): false;
    isSomeAnd(cb?: (value: never) => boolean): false;
    isNone(): this is OptionNone;
    expect(message: string): never;
    unwrap(): never;
    unwrapOr<R>(defaultValue: R): R;
    unwrapOrElse<R>(cb: () => R): R;
    map(cb: (value: never) => any): this;
    mapInto(cb: (value: never) => Option<any>): this;
    mapOr<R>(defaultValue: R, cb?: (value: never) => R): R;
    mapOrElse<R>(defaultValue: () => R, cb?: (value: never) => R): R;
    mapNoneInto<R extends Option<any>>(cb: () => R): R;
    inspect(cb?: (value: never) => void): this;
    inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;
    okOr<E>(error: E): ResultErr<E>;
    okOrElse<E>(cb: () => E): ResultErr<E>;
    iter(): Generator<never>;
    and(option: Option<any>): this;
    andThen(cb: (value: never) => Option<any>): this;
    or<R extends Option<any>>(option: R): R;
    orElse<R extends Option<any>>(cb: () => R): R;
    xor<T>(option: OptionNone): OptionNone;
    xor<T>(option: OptionSome<T>): OptionSome<T>;
    xor<T>(option: Option<T>): OptionSome<T> | OptionNone;
    filter(predicate: (value: never) => boolean): OptionNone;
    contains(value?: any): false;
    zip(other: Option<any>): OptionNone;
    zipWith(other: Option<any>, f: (s: never, o: never) => any): OptionNone;
    unzip(): [OptionNone, OptionNone];
    transpose(): ResultOk<OptionNone>;
    flatten(): OptionNone;
    intoPromise(): Promise<OptionNone>;
    eq(other: OptionNone): true;
    eq(other: OptionSome<any>): false;
    eq(other: Option<any>): boolean;
    ne(other: OptionNone): false;
    ne(other: OptionSome<any>): true;
    ne(other: Option<any>): boolean;
    match<SomeValue, NoneValue>(branches: {
        some(value: never): SomeValue;
        none(): NoneValue;
    }): NoneValue;
    [Symbol.iterator](): Generator<never>;
}
declare const createNone: OptionNone;

declare class OptionError extends Error {
    get name(): string;
}

/**
 * The union of the two variations of `Option`.
 * @typeparam T The value's type.
 */
type Option<T> = Option.Some<T> | Option.None;
declare namespace Option {
    type Resolvable<T> = T | null | undefined | Option<T>;
    function is<T>(value: Option<T>): true;
    function is(value: any): value is Option<unknown>;
    /**
     * Creates an {@link Option} out of a value or callback.
     * @typeparam T The result's type.
     */
    function from<T>(op: Resolvable<T> | (() => Resolvable<T>)): Option<T>;
    /**
     * Creates an {@link Option} out of a value or callback.
     * @typeparam T The result's type.
     */
    function fromAsync<T>(op: Awaitable<Resolvable<T>> | (() => Awaitable<Resolvable<T>>)): Promise<Option<T>>;
    /**
     * Creates a {@link Some} that is the combination of all collected {@link Some} values as an array, or the first
     * {@link None} encountered.
     * @param options An array of {@link Option}s.
     * @returns A new {@link Option}.
     */
    function all<T extends readonly Option<any>[]>(options: [...T]): Option<UnwrapSomeArray<T>>;
    /**
     * Returns the first encountered {@link Some}, or a {@link None} if none was found.
     * @param options An array of {@link Option}s.
     * @returns A new {@link Option}.
     */
    function any<T extends readonly Option<any>[]>(options: [...T]): Option<UnwrapSomeArray<T>[number]>;
    const none: OptionNone;
    const some: typeof createSome;
    type Some<T> = OptionSome<T>;
    type None = OptionNone;
    type UnwrapSome<T extends Option<any>> = T extends Some<infer S> ? S : never;
    type UnwrapSomeArray<T extends readonly Option<any>[] | []> = {
        -readonly [P in keyof T]: UnwrapSome<T[P]>;
    };
}

export { ResultErr as Err, type IOption, type IResult, OptionNone as None, ResultOk as Ok, Option, OptionError, Result, ResultError, OptionSome as Some, createErr as err, createNone as none, createOk as ok, createSome as some };
