{"version":3,"sources":["../../src/lib/common/utils.ts","../../src/lib/Result/ResultError.ts","../../src/lib/Result/Ok.ts","../../src/lib/Option/Some.ts","../../src/lib/Result/Err.ts","../../src/lib/Option/OptionError.ts","../../src/lib/Option/None.ts","../../src/lib/Option.ts","../../src/lib/Result.ts"],"names":["Option","Result"],"mappings":"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","sourcesContent":["export type Awaitable<T> = PromiseLike<T> | T;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { createNone, type OptionNone } from '../Option/None';\nimport { createSome, type OptionSome } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { ResultErr } from './Err';\nimport type { IResult } from './IResult';\nimport { ResultError } from './ResultError';\n\nexport class ResultOk<T> implements IResult<T, any> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isOk(): this is ResultOk<T> {\n\t\treturn true;\n\t}\n\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErrAnd(cb?: (error: never) => boolean): false;\n\tpublic isErrAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic ok(): OptionSome<T> {\n\t\treturn createSome(this.value);\n\t}\n\n\tpublic err(): OptionNone {\n\t\treturn createNone;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): ResultOk<U> {\n\t\treturn createOk(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: (error: never) => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapErr(cb?: (error: never) => any): this;\n\tpublic mapErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapErrInto(cb: (error: never) => Result<any, any>): this;\n\tpublic mapErrInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic inspectErr(cb?: (error: never) => void): this;\n\tpublic inspectErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectErrAsync(cb?: (error: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectErrAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic expect(message?: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic expectErr(message: string): never {\n\t\tthrow new ResultError(message, this.value);\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapErr(): never {\n\t\tthrow new ResultError('Unwrap failed', this.value);\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(op: (error: any) => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapRaw(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic and<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic andThen<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(result: Result<T, any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb: (error: never) => Result<T, any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic containsErr(error?: unknown): false;\n\tpublic containsErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic transpose(this: ResultOk<OptionNone>): OptionNone;\n\tpublic transpose<Inner>(this: ResultOk<OptionSome<Inner>>): OptionSome<ResultOk<Inner>>;\n\tpublic transpose<Inner>(this: ResultOk<Option<Inner>>): Option<ResultOk<Inner>>;\n\tpublic transpose<IT>(this: ResultOk<Option<IT>>): Option<ResultOk<IT>> {\n\t\treturn this.value.match({\n\t\t\tsome: (value) => createSome(createOk(value)),\n\t\t\tnone: () => createNone\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Result<any, any>>(this: ResultOk<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic intoOkOrErr() {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<ResultOk<Awaited<T>>> {\n\t\treturn createOk(await this.value);\n\t}\n\n\tpublic eq(other: ResultErr<any>): false;\n\tpublic eq(other: Result<T, any>): boolean;\n\tpublic eq(other: Result<T, any>): boolean {\n\t\treturn other.isOkAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: ResultErr<any>): true;\n\tpublic ne(other: Result<T, any>): boolean;\n\tpublic ne(other: Result<T, any>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: T): OkValue; err(error: never): ErrValue }): OkValue {\n\t\treturn branches.ok(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\n/**\n * Creates an Ok with no value.\n * @return A successful Result.\n */\nexport function createOk(): ResultOk<unknown>;\n\n/**\n * Creates an Ok.\n * @typeparam T The result's type.\n * @param x Value to use.\n * @return A successful Result.\n */\nexport function createOk<T>(x: T): ResultOk<T>;\nexport function createOk<T>(x?: T): ResultOk<T | undefined> {\n\treturn new ResultOk(x);\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport type { Result } from '../Result';\nimport { createErr, type ResultErr } from '../Result/Err';\nimport { createOk, type ResultOk } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { createNone, type OptionNone } from './None';\n\nexport class OptionSome<T> implements IOption<T> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isSome(): this is OptionSome<T> {\n\t\treturn true;\n\t}\n\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isNone(): false {\n\t\treturn false;\n\t}\n\n\tpublic expect(message: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(cb: () => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): OptionSome<U> {\n\t\treturn createSome(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: () => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapNoneInto(cb: () => Option<any>): this;\n\tpublic mapNoneInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic okOr(err?: any): ResultOk<T>;\n\tpublic okOr(): ResultOk<T> {\n\t\treturn createOk(this.value);\n\t}\n\n\tpublic okOrElse(cb: () => any): ResultOk<T>;\n\tpublic okOrElse(): ResultOk<T> {\n\t\treturn createOk(this.value);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic and<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic andThen<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(option: Option<any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb?: () => Option<any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic xor(option: OptionSome<T>): OptionNone;\n\tpublic xor(option: OptionNone): this;\n\tpublic xor(option: Option<T>): this | OptionNone;\n\tpublic xor(option: Option<T>): this | OptionNone {\n\t\treturn option.isSome() ? createNone : this;\n\t}\n\n\tpublic filter(predicate: (value: T) => true): this;\n\tpublic filter(predicate: (value: T) => false): OptionNone;\n\tpublic filter(predicate: (value: T) => boolean): this | OptionNone;\n\tpublic filter(predicate: (value: T) => boolean): this | OptionNone {\n\t\treturn predicate(this.value) ? this : createNone;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic zip(other: OptionNone): OptionNone;\n\tpublic zip<U>(other: OptionSome<U>): OptionSome<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]> {\n\t\treturn other.map((o) => [this.value, o] as [T, U]);\n\t}\n\n\tpublic zipWith<U, R>(other: OptionNone, f: (s: T, o: U) => R): OptionNone;\n\tpublic zipWith<U, R>(other: OptionSome<U>, f: (s: T, o: U) => R): OptionSome<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R> {\n\t\treturn other.map((o) => f(this.value, o));\n\t}\n\n\tpublic unzip<I, U>(this: OptionSome<readonly [I, U]>): [OptionSome<I>, OptionSome<U>] {\n\t\tconst [s, o] = this.value;\n\t\treturn [createSome(s), createSome(o)];\n\t}\n\n\tpublic transpose<Inner>(this: OptionSome<ResultOk<Inner>>): ResultOk<OptionSome<Inner>>;\n\tpublic transpose<Inner>(this: OptionSome<ResultErr<Inner>>): ResultErr<OptionSome<Inner>>;\n\tpublic transpose<IT, E>(this: OptionSome<Result<IT, E>>): Result<OptionSome<IT>, E>;\n\tpublic transpose<IT, E>(this: OptionSome<Result<IT, E>>): Result<OptionSome<IT>, E> {\n\t\treturn this.value.match({\n\t\t\tok: (v) => createOk(createSome(v)),\n\t\t\terr: (e) => createErr(e)\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Option<any>>(this: OptionSome<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<OptionSome<Awaited<T>>> {\n\t\treturn createSome(await this.value);\n\t}\n\n\tpublic eq(other: OptionNone): false;\n\tpublic eq(other: Option<T>): boolean;\n\tpublic eq(other: Option<T>): boolean {\n\t\treturn other.isSomeAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: OptionNone): true;\n\tpublic ne(other: Option<T>): boolean;\n\tpublic ne(other: Option<T>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: T): SomeValue; none(): NoneValue }): SomeValue {\n\t\treturn branches.some(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\nexport function createSome<T>(value: T): OptionSome<T> {\n\treturn new OptionSome<T>(value);\n}\n","import type { Awaitable } from '../common/utils';\nimport { createNone, type OptionNone } from '../Option/None';\nimport { createSome, type OptionSome } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { IResult } from './IResult';\nimport type { ResultOk } from './Ok';\nimport { ResultError } from './ResultError';\n\nexport class ResultErr<E> implements IResult<any, E> {\n\tprivate readonly error: E;\n\n\tpublic constructor(error: E) {\n\t\tthis.error = error;\n\t}\n\n\tpublic isOk(): false {\n\t\treturn false;\n\t}\n\n\tpublic isOkAnd(cb?: (value: never) => boolean): false;\n\tpublic isOkAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErr(): this is ResultErr<E> {\n\t\treturn true;\n\t}\n\n\tpublic isErrAnd(cb: (error: E) => boolean): boolean {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic ok(): OptionNone {\n\t\treturn createNone;\n\t}\n\n\tpublic err(): OptionSome<E> {\n\t\treturn createSome(this.error);\n\t}\n\n\tpublic map(cb?: (value: never) => unknown): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Result<any, any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<U>(defaultValue: U, cb?: (value: never) => U): U;\n\tpublic mapOr<U>(defaultValue: U): U {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<U>(op: (error: E) => U, cb?: (value: never) => U): U;\n\tpublic mapOrElse<U>(op: (error: E) => U): U {\n\t\treturn op(this.error);\n\t}\n\n\tpublic mapErr<F>(cb: (error: E) => F): ResultErr<F> {\n\t\treturn createErr(cb(this.error));\n\t}\n\n\tpublic mapErrInto<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic inspectErr(cb: (error: E) => void): this {\n\t\tcb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new ResultError(message, this.error);\n\t}\n\n\tpublic expectErr(message?: string): E;\n\tpublic expectErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new ResultError('Unwrap failed', this.error);\n\t}\n\n\tpublic unwrapErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrapOr<T>(defaultValue: T): T {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<T>(op: (error: E) => T): T {\n\t\treturn op(this.error);\n\t}\n\n\tpublic unwrapRaw(): never {\n\t\t// eslint-disable-next-line @typescript-eslint/no-throw-literal\n\t\tthrow this.error;\n\t}\n\n\tpublic and(result?: Result<any, E>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb?: (value: never) => Result<any, E>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic orElse<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.error === error;\n\t}\n\n\tpublic transpose(): OptionSome<this> {\n\t\treturn createSome(this);\n\t}\n\n\tpublic flatten(): this {\n\t\treturn this;\n\t}\n\n\tpublic intoOkOrErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic async intoPromise(): Promise<ResultErr<Awaited<E>>> {\n\t\treturn createErr(await this.error);\n\t}\n\n\tpublic eq(other: ResultOk<any>): false;\n\tpublic eq(other: Result<any, E>): boolean;\n\tpublic eq(other: Result<any, E>): boolean {\n\t\treturn other.isErrAnd((error) => this.error === error);\n\t}\n\n\tpublic ne(other: ResultOk<any>): true;\n\tpublic ne(other: Result<any, E>): boolean;\n\tpublic ne(other: Result<any, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: never): OkValue; err(error: E): ErrValue }): ErrValue {\n\t\treturn branches.err(this.error);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\n/**\n * Creates an Err with no error.\n * @return An erroneous Result.\n */\nexport function createErr(): ResultErr<unknown>;\n\n/**\n * Creates an Err.\n * @typeparam E The error's type.\n * @param x Value to use.\n * @return An erroneous Result.\n */\nexport function createErr<E>(x: E): ResultErr<E>;\nexport function createErr<E>(x?: E): ResultErr<unknown> {\n\treturn new ResultErr(x);\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { createErr, type ResultErr } from '../Result/Err';\nimport { createOk, type ResultOk } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { OptionError } from './OptionError';\nimport type { OptionSome } from './Some';\n\nexport class OptionNone implements IOption<any> {\n\tpublic isSome(): false {\n\t\treturn false;\n\t}\n\n\tpublic isSomeAnd(cb?: (value: never) => boolean): false;\n\tpublic isSomeAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isNone(): this is OptionNone {\n\t\treturn true;\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new OptionError(message);\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new OptionError('Unwrap failed');\n\t}\n\n\tpublic unwrapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<R>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic map(cb: (value: never) => any): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Option<any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<R>(defaultValue: R, cb?: (value: never) => R): R;\n\tpublic mapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<R>(defaultValue: () => R, cb?: (value: never) => R): R;\n\tpublic mapOrElse<R>(defaultValue: () => R): R {\n\t\treturn defaultValue();\n\t}\n\n\tpublic mapNoneInto<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic okOr<E>(error: E): ResultErr<E> {\n\t\treturn createErr(error);\n\t}\n\n\tpublic okOrElse<E>(cb: () => E): ResultErr<E> {\n\t\treturn createErr(cb());\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic and(option: Option<any>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb: (value: never) => Option<any>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic orElse<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic xor<T>(option: OptionNone): OptionNone;\n\tpublic xor<T>(option: OptionSome<T>): OptionSome<T>;\n\tpublic xor<T>(option: Option<T>): OptionSome<T> | OptionNone;\n\tpublic xor<T>(option: OptionSome<T> | OptionNone): OptionSome<T> | OptionNone {\n\t\treturn option.isSome() ? option : this;\n\t}\n\n\tpublic filter(predicate: (value: never) => boolean): OptionNone;\n\tpublic filter(): OptionNone {\n\t\treturn this;\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic zip(other: Option<any>): OptionNone;\n\tpublic zip(): OptionNone {\n\t\treturn this;\n\t}\n\n\tpublic zipWith(other: Option<any>, f: (s: never, o: never) => any): OptionNone;\n\tpublic zipWith(): OptionNone {\n\t\treturn this;\n\t}\n\n\tpublic unzip(): [OptionNone, OptionNone] {\n\t\treturn [this, this];\n\t}\n\n\tpublic transpose(): ResultOk<OptionNone> {\n\t\treturn createOk(this);\n\t}\n\n\tpublic flatten(): OptionNone {\n\t\treturn this;\n\t}\n\n\tpublic intoPromise(): Promise<OptionNone> {\n\t\treturn Promise.resolve(createNone);\n\t}\n\n\tpublic eq(other: OptionNone): true;\n\tpublic eq(other: OptionSome<any>): false;\n\tpublic eq(other: Option<any>): boolean;\n\tpublic eq(other: Option<any>): boolean {\n\t\treturn other.isNone();\n\t}\n\n\tpublic ne(other: OptionNone): false;\n\tpublic ne(other: OptionSome<any>): true;\n\tpublic ne(other: Option<any>): boolean;\n\tpublic ne(other: Option<any>): boolean {\n\t\treturn other.isSome();\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: never): SomeValue; none(): NoneValue }): NoneValue {\n\t\treturn branches.none();\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\nexport const createNone = new OptionNone();\n","import { isFunction, type Awaitable } from './common/utils';\nimport { createNone, OptionNone } from './Option/None';\nimport { createSome, OptionSome } from './Option/Some';\n\nexport type * from './Option/IOption';\nexport * from './Option/OptionError';\nexport { createSome as some, createNone as none, type OptionNone as None, type OptionSome as Some };\n\n/**\n * The union of the two variations of `Option`.\n * @typeparam T The value's type.\n */\nexport type Option<T> = Option.Some<T> | Option.None;\n\nexport namespace Option {\n\texport type Resolvable<T> = T | null | undefined | Option<T>;\n\tfunction resolve<T>(value: Resolvable<T>) {\n\t\tif (value === null || value === undefined) return none;\n\t\tif (is(value)) return value;\n\t\treturn some(value);\n\t}\n\n\texport function is<T>(value: Option<T>): true;\n\texport function is(value: any): value is Option<unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof OptionNone || value instanceof OptionSome;\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport function from<T>(op: Resolvable<T> | (() => Resolvable<T>)): Option<T> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport async function fromAsync<T>(op: Awaitable<Resolvable<T>> | (() => Awaitable<Resolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Some} that is the combination of all collected {@link Some} values as an array, or the first\n\t * {@link None} encountered.\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\texport function all<T extends readonly Option<any>[]>(options: [...T]): Option<UnwrapSomeArray<T>> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const option of options) {\n\t\t\tif (option.isNone()) {\n\t\t\t\treturn option;\n\t\t\t}\n\n\t\t\tvalues.push(option.unwrap());\n\t\t}\n\n\t\treturn some(values as UnwrapSomeArray<T>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Some}, or a {@link None} if none was found.\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\texport function any<T extends readonly Option<any>[]>(options: [...T]): Option<UnwrapSomeArray<T>[number]> {\n\t\tfor (const result of options) {\n\t\t\tif (result.isSome()) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn none;\n\t}\n\n\texport const none = createNone;\n\texport const some = createSome;\n\n\texport type Some<T> = OptionSome<T>;\n\texport type None = OptionNone;\n\n\texport type UnwrapSome<T extends Option<any>> = T extends Some<infer S> ? S : never;\n\texport type UnwrapSomeArray<T extends readonly Option<any>[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapSome<T[P]>;\n\t};\n}\n","import { isFunction, type Awaitable } from './common/utils';\nimport { createErr, ResultErr } from './Result/Err';\nimport { createOk, ResultOk } from './Result/Ok';\n\nexport type * from './Result/IResult';\nexport * from './Result/ResultError';\nexport { createOk as ok, createErr as err, type ResultOk as Ok, type ResultErr as Err };\n\n/**\n * The union of the two variations of `Result`.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport type Result<T, E> = Result.Ok<T> | Result.Err<E>;\n\nexport namespace Result {\n\texport type Resolvable<T, E> = T | Result<T, E>;\n\tfunction resolve<T, E>(value: Resolvable<T, E>) {\n\t\tif (is(value)) return value;\n\t\treturn ok(value);\n\t}\n\n\texport function is<T, E>(value: Result<T, E>): true;\n\texport function is(value: any): value is Result<unknown, unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof ResultOk || value instanceof ResultErr;\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport async function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\texport function all<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>, UnwrapErrArray<T>[number]> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isErr()) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tvalues.push(result.unwrap());\n\t\t}\n\n\t\treturn ok(values as UnwrapOkArray<T>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\texport function any<T extends readonly Result<any, any>[]>(results: [...T]): Result<UnwrapOkArray<T>[number], UnwrapErrArray<T>> {\n\t\tconst errors: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isOk()) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn err(errors as UnwrapErrArray<T>);\n\t}\n\n\texport const err = createErr;\n\texport const ok = createOk;\n\n\texport type Err<E> = ResultErr<E>;\n\texport type Ok<T> = ResultOk<T>;\n\n\texport type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;\n\n\texport type UnwrapOkArray<T extends readonly Result<any, any>[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapOk<T[P]>;\n\t};\n\texport type UnwrapErrArray<T extends readonly Result<any, any>[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapErr<T[P]>;\n\t};\n}\n"]}