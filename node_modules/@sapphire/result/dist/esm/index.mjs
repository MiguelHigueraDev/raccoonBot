var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/common/utils.ts
function isFunction(input) {
  return typeof input === "function";
}
__name(isFunction, "isFunction");

// src/lib/Result/ResultError.ts
var _ResultError = class _ResultError extends Error {
  constructor(message, value) {
    super(message);
    __publicField(this, "value");
    this.value = value;
  }
  get name() {
    return this.constructor.name;
  }
};
__name(_ResultError, "ResultError");
var ResultError = _ResultError;

// src/lib/Result/Ok.ts
var _ResultOk = class _ResultOk {
  constructor(value) {
    __publicField(this, "value");
    this.value = value;
  }
  isOk() {
    return true;
  }
  isOkAnd(cb) {
    return cb(this.value);
  }
  isErr() {
    return false;
  }
  isErrAnd() {
    return false;
  }
  ok() {
    return createSome(this.value);
  }
  err() {
    return createNone;
  }
  map(cb) {
    return createOk(cb(this.value));
  }
  mapInto(cb) {
    return cb(this.value);
  }
  mapOr(_, cb) {
    return cb(this.value);
  }
  mapOrElse(_, cb) {
    return cb(this.value);
  }
  mapErr() {
    return this;
  }
  mapErrInto() {
    return this;
  }
  inspect(cb) {
    cb(this.value);
    return this;
  }
  async inspectAsync(cb) {
    await cb(this.value);
    return this;
  }
  inspectErr() {
    return this;
  }
  inspectErrAsync() {
    return Promise.resolve(this);
  }
  *iter() {
    yield this.value;
  }
  expect() {
    return this.value;
  }
  expectErr(message) {
    throw new ResultError(message, this.value);
  }
  unwrap() {
    return this.value;
  }
  unwrapErr() {
    throw new ResultError("Unwrap failed", this.value);
  }
  unwrapOr() {
    return this.value;
  }
  unwrapOrElse() {
    return this.value;
  }
  unwrapRaw() {
    return this.value;
  }
  and(result) {
    return result;
  }
  andThen(cb) {
    return cb(this.value);
  }
  or() {
    return this;
  }
  orElse() {
    return this;
  }
  contains(value) {
    return this.value === value;
  }
  containsErr() {
    return false;
  }
  transpose() {
    return this.value.match({
      some: (value) => createSome(createOk(value)),
      none: () => createNone
    });
  }
  flatten() {
    return this.value;
  }
  intoOkOrErr() {
    return this.value;
  }
  async intoPromise() {
    return createOk(await this.value);
  }
  eq(other) {
    return other.isOkAnd((value) => this.value === value);
  }
  ne(other) {
    return !this.eq(other);
  }
  match(branches) {
    return branches.ok(this.value);
  }
  *[Symbol.iterator]() {
    yield this.value;
  }
};
__name(_ResultOk, "ResultOk");
var ResultOk = _ResultOk;
function createOk(x) {
  return new ResultOk(x);
}
__name(createOk, "createOk");

// src/lib/Option/Some.ts
var _OptionSome = class _OptionSome {
  constructor(value) {
    __publicField(this, "value");
    this.value = value;
  }
  isSome() {
    return true;
  }
  isSomeAnd(cb) {
    return cb(this.value);
  }
  isNone() {
    return false;
  }
  expect() {
    return this.value;
  }
  unwrap() {
    return this.value;
  }
  unwrapOr() {
    return this.value;
  }
  unwrapOrElse() {
    return this.value;
  }
  map(cb) {
    return createSome(cb(this.value));
  }
  mapInto(cb) {
    return cb(this.value);
  }
  mapOr(_, cb) {
    return cb(this.value);
  }
  mapOrElse(_, cb) {
    return cb(this.value);
  }
  mapNoneInto() {
    return this;
  }
  inspect(cb) {
    cb(this.value);
    return this;
  }
  async inspectAsync(cb) {
    await cb(this.value);
    return this;
  }
  okOr() {
    return createOk(this.value);
  }
  okOrElse() {
    return createOk(this.value);
  }
  *iter() {
    yield this.value;
  }
  and(option) {
    return option;
  }
  andThen(cb) {
    return cb(this.value);
  }
  or() {
    return this;
  }
  orElse() {
    return this;
  }
  xor(option) {
    return option.isSome() ? createNone : this;
  }
  filter(predicate) {
    return predicate(this.value) ? this : createNone;
  }
  contains(value) {
    return this.value === value;
  }
  zip(other) {
    return other.map((o) => [this.value, o]);
  }
  zipWith(other, f) {
    return other.map((o) => f(this.value, o));
  }
  unzip() {
    const [s, o] = this.value;
    return [createSome(s), createSome(o)];
  }
  transpose() {
    return this.value.match({
      ok: (v) => createOk(createSome(v)),
      err: (e) => createErr(e)
    });
  }
  flatten() {
    return this.value;
  }
  async intoPromise() {
    return createSome(await this.value);
  }
  eq(other) {
    return other.isSomeAnd((value) => this.value === value);
  }
  ne(other) {
    return !this.eq(other);
  }
  match(branches) {
    return branches.some(this.value);
  }
  *[Symbol.iterator]() {
    yield this.value;
  }
};
__name(_OptionSome, "OptionSome");
var OptionSome = _OptionSome;
function createSome(value) {
  return new OptionSome(value);
}
__name(createSome, "createSome");

// src/lib/Result/Err.ts
var _ResultErr = class _ResultErr {
  constructor(error) {
    __publicField(this, "error");
    this.error = error;
  }
  isOk() {
    return false;
  }
  isOkAnd() {
    return false;
  }
  isErr() {
    return true;
  }
  isErrAnd(cb) {
    return cb(this.error);
  }
  ok() {
    return createNone;
  }
  err() {
    return createSome(this.error);
  }
  map() {
    return this;
  }
  mapInto() {
    return this;
  }
  mapOr(defaultValue) {
    return defaultValue;
  }
  mapOrElse(op) {
    return op(this.error);
  }
  mapErr(cb) {
    return createErr(cb(this.error));
  }
  mapErrInto(cb) {
    return cb(this.error);
  }
  inspect() {
    return this;
  }
  inspectAsync() {
    return Promise.resolve(this);
  }
  inspectErr(cb) {
    cb(this.error);
    return this;
  }
  async inspectErrAsync(cb) {
    await cb(this.error);
    return this;
  }
  *iter() {
  }
  expect(message) {
    throw new ResultError(message, this.error);
  }
  expectErr() {
    return this.error;
  }
  unwrap() {
    throw new ResultError("Unwrap failed", this.error);
  }
  unwrapErr() {
    return this.error;
  }
  unwrapOr(defaultValue) {
    return defaultValue;
  }
  unwrapOrElse(op) {
    return op(this.error);
  }
  unwrapRaw() {
    throw this.error;
  }
  and() {
    return this;
  }
  andThen() {
    return this;
  }
  or(result) {
    return result;
  }
  orElse(cb) {
    return cb(this.error);
  }
  contains() {
    return false;
  }
  containsErr(error) {
    return this.error === error;
  }
  transpose() {
    return createSome(this);
  }
  flatten() {
    return this;
  }
  intoOkOrErr() {
    return this.error;
  }
  async intoPromise() {
    return createErr(await this.error);
  }
  eq(other) {
    return other.isErrAnd((error) => this.error === error);
  }
  ne(other) {
    return !this.eq(other);
  }
  match(branches) {
    return branches.err(this.error);
  }
  *[Symbol.iterator]() {
  }
};
__name(_ResultErr, "ResultErr");
var ResultErr = _ResultErr;
function createErr(x) {
  return new ResultErr(x);
}
__name(createErr, "createErr");

// src/lib/Option/OptionError.ts
var _OptionError = class _OptionError extends Error {
  get name() {
    return this.constructor.name;
  }
};
__name(_OptionError, "OptionError");
var OptionError = _OptionError;

// src/lib/Option/None.ts
var _OptionNone = class _OptionNone {
  isSome() {
    return false;
  }
  isSomeAnd() {
    return false;
  }
  isNone() {
    return true;
  }
  expect(message) {
    throw new OptionError(message);
  }
  unwrap() {
    throw new OptionError("Unwrap failed");
  }
  unwrapOr(defaultValue) {
    return defaultValue;
  }
  unwrapOrElse(cb) {
    return cb();
  }
  map() {
    return this;
  }
  mapInto() {
    return this;
  }
  mapOr(defaultValue) {
    return defaultValue;
  }
  mapOrElse(defaultValue) {
    return defaultValue();
  }
  mapNoneInto(cb) {
    return cb();
  }
  inspect() {
    return this;
  }
  inspectAsync() {
    return Promise.resolve(this);
  }
  okOr(error) {
    return createErr(error);
  }
  okOrElse(cb) {
    return createErr(cb());
  }
  *iter() {
  }
  and() {
    return this;
  }
  andThen() {
    return this;
  }
  or(option) {
    return option;
  }
  orElse(cb) {
    return cb();
  }
  xor(option) {
    return option.isSome() ? option : this;
  }
  filter() {
    return this;
  }
  contains() {
    return false;
  }
  zip() {
    return this;
  }
  zipWith() {
    return this;
  }
  unzip() {
    return [this, this];
  }
  transpose() {
    return createOk(this);
  }
  flatten() {
    return this;
  }
  intoPromise() {
    return Promise.resolve(createNone);
  }
  eq(other) {
    return other.isNone();
  }
  ne(other) {
    return other.isSome();
  }
  match(branches) {
    return branches.none();
  }
  *[Symbol.iterator]() {
  }
};
__name(_OptionNone, "OptionNone");
var OptionNone = _OptionNone;
var createNone = new OptionNone();

// src/lib/Option.ts
var Option;
((Option2) => {
  function resolve(value) {
    if (value === null || value === void 0)
      return Option2.none;
    if (is(value))
      return value;
    return (0, Option2.some)(value);
  }
  __name(resolve, "resolve");
  function is(value) {
    return value instanceof OptionNone || value instanceof OptionSome;
  }
  Option2.is = is;
  __name(is, "is");
  function from(op) {
    if (!isFunction(op))
      return resolve(op);
    try {
      return resolve(op());
    } catch {
      return Option2.none;
    }
  }
  Option2.from = from;
  __name(from, "from");
  async function fromAsync(op) {
    try {
      return resolve(await (isFunction(op) ? op() : op));
    } catch {
      return Option2.none;
    }
  }
  Option2.fromAsync = fromAsync;
  __name(fromAsync, "fromAsync");
  function all(options) {
    const values = [];
    for (const option of options) {
      if (option.isNone()) {
        return option;
      }
      values.push(option.unwrap());
    }
    return (0, Option2.some)(values);
  }
  Option2.all = all;
  __name(all, "all");
  function any(options) {
    for (const result of options) {
      if (result.isSome()) {
        return result;
      }
    }
    return Option2.none;
  }
  Option2.any = any;
  __name(any, "any");
  Option2.none = createNone;
  Option2.some = createSome;
})(Option || (Option = {}));

// src/lib/Result.ts
var Result;
((Result2) => {
  function resolve(value) {
    if (is(value))
      return value;
    return (0, Result2.ok)(value);
  }
  __name(resolve, "resolve");
  function is(value) {
    return value instanceof ResultOk || value instanceof ResultErr;
  }
  Result2.is = is;
  __name(is, "is");
  function from(op) {
    if (!isFunction(op))
      return resolve(op);
    try {
      return resolve(op());
    } catch (error) {
      return (0, Result2.err)(error);
    }
  }
  Result2.from = from;
  __name(from, "from");
  async function fromAsync(op) {
    try {
      return resolve(await (isFunction(op) ? op() : op));
    } catch (error) {
      return (0, Result2.err)(error);
    }
  }
  Result2.fromAsync = fromAsync;
  __name(fromAsync, "fromAsync");
  function all(results) {
    const values = [];
    for (const result of results) {
      if (result.isErr()) {
        return result;
      }
      values.push(result.unwrap());
    }
    return (0, Result2.ok)(values);
  }
  Result2.all = all;
  __name(all, "all");
  function any(results) {
    const errors = [];
    for (const result of results) {
      if (result.isOk()) {
        return result;
      }
      errors.push(result.unwrapErr());
    }
    return (0, Result2.err)(errors);
  }
  Result2.any = any;
  __name(any, "any");
  Result2.err = createErr;
  Result2.ok = createOk;
})(Result || (Result = {}));

export { Option, OptionError, Result, ResultError, createErr as err, createNone as none, createOk as ok, createSome as some };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map