declare class RateLimitManager<K = string> extends Map<K, RateLimit<K>> {
    /**
     * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.
     */
    readonly time: number;
    /**
     * The amount of times a {@link RateLimit} can drip before it's limited.
     */
    readonly limit: number;
    /**
     * The interval to sweep expired {@link RateLimit ratelimits}.
     */
    private sweepInterval;
    /**
     * @param time The amount of milliseconds for the ratelimits from this manager to expire.
     * @param limit The amount of times a {@link RateLimit} can drip before it's limited.
     */
    constructor(time: number, limit?: number);
    /**
     * Gets a {@link RateLimit} from this manager or creates it if it does not exist.
     * @param id The id for the {@link RateLimit}
     */
    acquire(id: K): RateLimit<K>;
    /**
     * Creates a {@link RateLimit} for this manager.
     * @param id The id the {@link RateLimit} belongs to
     */
    create(id: K): RateLimit<K>;
    /**
     * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.
     * @param id The id the {@link RateLimit} belongs to
     * @param value The {@link RateLimit} to set
     */
    set(id: K, value: RateLimit<K>): this;
    /**
     * Wraps Collection's sweep method to clear the interval when this manager is empty.
     */
    sweep(): void;
    /**
     * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.
     */
    static sweepIntervalDuration: number;
}

declare class RateLimit<K = string> {
    /**
     * The remaining amount of times this entry can be dripped before the bucket is empty.
     */
    remaining: number;
    /**
     * The timestamp that represents when this entry will reset back to a available state.
     */
    expires: number;
    /**
     * The {@link RateLimitManager} this entry is for.
     */
    private manager;
    /**
     * @param manager The manager for this entry.
     */
    constructor(manager: RateLimitManager<K>);
    /**
     * Whether this entry is expired or not, allowing the bucket to be reset.
     */
    get expired(): boolean;
    /**
     * Whether this entry is limited or not.
     */
    get limited(): boolean;
    /**
     * The remaining time in milliseconds before resetting.
     */
    get remainingTime(): number;
    /**
     * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.
     */
    consume(): this;
    /**
     * Resets the entry back to it's full state.
     */
    reset(): this;
    /**
     * Resets the entry's {@link RateLimit.remaining} uses back to full state.
     */
    resetRemaining(): this;
    /**
     * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.
     */
    resetTime(): this;
}

export { RateLimit, RateLimitManager };
