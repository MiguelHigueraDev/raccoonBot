var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/RateLimit.ts
var _RateLimit = class _RateLimit {
  /**
   * @param manager The manager for this entry.
   */
  constructor(manager) {
    /**
     * The remaining amount of times this entry can be dripped before the bucket is empty.
     */
    __publicField(this, "remaining");
    /**
     * The timestamp that represents when this entry will reset back to a available state.
     */
    __publicField(this, "expires");
    /**
     * The {@link RateLimitManager} this entry is for.
     */
    __publicField(this, "manager");
    this.manager = manager;
    this.reset();
  }
  /**
   * Whether this entry is expired or not, allowing the bucket to be reset.
   */
  get expired() {
    return this.remainingTime === 0;
  }
  /**
   * Whether this entry is limited or not.
   */
  get limited() {
    return this.remaining === 0 && !this.expired;
  }
  /**
   * The remaining time in milliseconds before resetting.
   */
  get remainingTime() {
    return Math.max(this.expires - Date.now(), 0);
  }
  /**
   * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.
   */
  consume() {
    if (this.limited)
      throw new Error("Cannot consume a limited bucket");
    if (this.expired)
      this.reset();
    this.remaining--;
    return this;
  }
  /**
   * Resets the entry back to it's full state.
   */
  reset() {
    return this.resetRemaining().resetTime();
  }
  /**
   * Resets the entry's {@link RateLimit.remaining} uses back to full state.
   */
  resetRemaining() {
    this.remaining = this.manager.limit;
    return this;
  }
  /**
   * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.
   */
  resetTime() {
    this.expires = Date.now() + this.manager.time;
    return this;
  }
};
__name(_RateLimit, "RateLimit");
var RateLimit = _RateLimit;

// src/lib/RateLimitManager.ts
var _RateLimitManager = class _RateLimitManager extends Map {
  /**
   * @param time The amount of milliseconds for the ratelimits from this manager to expire.
   * @param limit The amount of times a {@link RateLimit} can drip before it's limited.
   */
  constructor(time, limit = 1) {
    super();
    /**
     * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.
     */
    __publicField(this, "time");
    /**
     * The amount of times a {@link RateLimit} can drip before it's limited.
     */
    __publicField(this, "limit");
    /**
     * The interval to sweep expired {@link RateLimit ratelimits}.
     */
    __publicField(this, "sweepInterval");
    this.time = time;
    this.limit = limit;
  }
  /**
   * Gets a {@link RateLimit} from this manager or creates it if it does not exist.
   * @param id The id for the {@link RateLimit}
   */
  acquire(id) {
    return this.get(id) ?? this.create(id);
  }
  /**
   * Creates a {@link RateLimit} for this manager.
   * @param id The id the {@link RateLimit} belongs to
   */
  create(id) {
    const value = new RateLimit(this);
    this.set(id, value);
    return value;
  }
  /**
   * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.
   * @param id The id the {@link RateLimit} belongs to
   * @param value The {@link RateLimit} to set
   */
  set(id, value) {
    this.sweepInterval ?? (this.sweepInterval = setInterval(this.sweep.bind(this), _RateLimitManager.sweepIntervalDuration));
    return super.set(id, value);
  }
  /**
   * Wraps Collection's sweep method to clear the interval when this manager is empty.
   */
  sweep() {
    for (const [id, value] of this.entries()) {
      if (value.expired)
        this.delete(id);
    }
    if (this.size === 0 && this.sweepInterval !== void 0 && this.sweepInterval !== null) {
      clearInterval(this.sweepInterval);
      this.sweepInterval = null;
    }
  }
};
__name(_RateLimitManager, "RateLimitManager");
/**
 * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.
 */
__publicField(_RateLimitManager, "sweepIntervalDuration", 3e4);
var RateLimitManager = _RateLimitManager;

export { RateLimit, RateLimitManager };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map