var SapphireSnowflake = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/lib/RateLimit.ts
  var _RateLimit = class _RateLimit {
    /**
     * @param manager The manager for this entry.
     */
    constructor(manager) {
      /**
       * The remaining amount of times this entry can be dripped before the bucket is empty.
       */
      __publicField(this, "remaining");
      /**
       * The timestamp that represents when this entry will reset back to a available state.
       */
      __publicField(this, "expires");
      /**
       * The {@link RateLimitManager} this entry is for.
       */
      __publicField(this, "manager");
      this.manager = manager;
      this.reset();
    }
    /**
     * Whether this entry is expired or not, allowing the bucket to be reset.
     */
    get expired() {
      return this.remainingTime === 0;
    }
    /**
     * Whether this entry is limited or not.
     */
    get limited() {
      return this.remaining === 0 && !this.expired;
    }
    /**
     * The remaining time in milliseconds before resetting.
     */
    get remainingTime() {
      return Math.max(this.expires - Date.now(), 0);
    }
    /**
     * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.
     */
    consume() {
      if (this.limited)
        throw new Error("Cannot consume a limited bucket");
      if (this.expired)
        this.reset();
      this.remaining--;
      return this;
    }
    /**
     * Resets the entry back to it's full state.
     */
    reset() {
      return this.resetRemaining().resetTime();
    }
    /**
     * Resets the entry's {@link RateLimit.remaining} uses back to full state.
     */
    resetRemaining() {
      this.remaining = this.manager.limit;
      return this;
    }
    /**
     * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.
     */
    resetTime() {
      this.expires = Date.now() + this.manager.time;
      return this;
    }
  };
  __name(_RateLimit, "RateLimit");
  var RateLimit = _RateLimit;

  // src/lib/RateLimitManager.ts
  var _RateLimitManager = class _RateLimitManager extends Map {
    /**
     * @param time The amount of milliseconds for the ratelimits from this manager to expire.
     * @param limit The amount of times a {@link RateLimit} can drip before it's limited.
     */
    constructor(time, limit = 1) {
      super();
      /**
       * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.
       */
      __publicField(this, "time");
      /**
       * The amount of times a {@link RateLimit} can drip before it's limited.
       */
      __publicField(this, "limit");
      /**
       * The interval to sweep expired {@link RateLimit ratelimits}.
       */
      __publicField(this, "sweepInterval");
      this.time = time;
      this.limit = limit;
    }
    /**
     * Gets a {@link RateLimit} from this manager or creates it if it does not exist.
     * @param id The id for the {@link RateLimit}
     */
    acquire(id) {
      return this.get(id) ?? this.create(id);
    }
    /**
     * Creates a {@link RateLimit} for this manager.
     * @param id The id the {@link RateLimit} belongs to
     */
    create(id) {
      const value = new RateLimit(this);
      this.set(id, value);
      return value;
    }
    /**
     * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.
     * @param id The id the {@link RateLimit} belongs to
     * @param value The {@link RateLimit} to set
     */
    set(id, value) {
      this.sweepInterval ?? (this.sweepInterval = setInterval(this.sweep.bind(this), _RateLimitManager.sweepIntervalDuration));
      return super.set(id, value);
    }
    /**
     * Wraps Collection's sweep method to clear the interval when this manager is empty.
     */
    sweep() {
      for (const [id, value] of this.entries()) {
        if (value.expired)
          this.delete(id);
      }
      if (this.size === 0 && this.sweepInterval !== void 0 && this.sweepInterval !== null) {
        clearInterval(this.sweepInterval);
        this.sweepInterval = null;
      }
    }
  };
  __name(_RateLimitManager, "RateLimitManager");
  /**
   * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.
   */
  __publicField(_RateLimitManager, "sweepIntervalDuration", 3e4);
  var RateLimitManager = _RateLimitManager;

  exports.RateLimit = RateLimit;
  exports.RateLimitManager = RateLimitManager;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.global.js.map